#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UMG

#include "Basic.hpp"

#include "UMG_classes.hpp"
#include "UMG_parameters.hpp"


namespace SDK
{

// Function UMG.Widget.ForceLayoutPrepass
// (Final, Native, Public, BlueprintCallable)

void UWidget::ForceLayoutPrepass()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceLayoutPrepass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.Widget.ForceVolatile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::ForceVolatile(bool bForce)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceVolatile");

	Params::Widget_ForceVolatile Parms{};

	Parms.bForce = bForce;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.InvalidateLayoutAndVolatility
// (Final, Native, Public, BlueprintCallable)

void UWidget::InvalidateLayoutAndVolatility()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InvalidateLayoutAndVolatility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.Widget.RemoveFromParent
// (Native, Public, BlueprintCallable)

void UWidget::RemoveFromParent()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveFromParent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.Widget.ResetCursor
// (Final, Native, Public, BlueprintCallable)

void UWidget::ResetCursor()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetCursor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.Widget.SetAllNavigationRules
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUINavigationRule                       Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WidgetToFocus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetAllNavigationRules(EUINavigationRule Rule, class FName WidgetToFocus)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllNavigationRules");

	Params::Widget_SetAllNavigationRules Parms{};

	Parms.Rule = Rule;
	Parms.WidgetToFocus = WidgetToFocus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetClipping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWidgetClipping                         InClipping                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetClipping(EWidgetClipping InClipping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetClipping");

	Params::Widget_SetClipping Parms{};

	Parms.InClipping = InClipping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetCursor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMouseCursor                            InCursor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetCursor(EMouseCursor InCursor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCursor");

	Params::Widget_SetCursor Parms{};

	Parms.InCursor = InCursor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetFocus
// (Final, Native, Public, BlueprintCallable)

void UWidget::SetFocus()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFocus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.Widget.SetIsEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetIsEnabled(bool bInIsEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsEnabled");

	Params::Widget_SetIsEnabled Parms{};

	Parms.bInIsEnabled = bInIsEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetKeyboardFocus
// (Final, Native, Public, BlueprintCallable)

void UWidget::SetKeyboardFocus()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetKeyboardFocus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.Widget.SetNavigationRule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUINavigation                           Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUINavigationRule                       Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WidgetToFocus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetNavigationRule(EUINavigation Direction, EUINavigationRule Rule, class FName WidgetToFocus)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNavigationRule");

	Params::Widget_SetNavigationRule Parms{};

	Parms.Direction = Direction;
	Parms.Rule = Rule;
	Parms.WidgetToFocus = WidgetToFocus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetNavigationRuleBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUINavigation                           Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUINavigationRule                       Rule                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetNavigationRuleBase(EUINavigation Direction, EUINavigationRule Rule)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNavigationRuleBase");

	Params::Widget_SetNavigationRuleBase Parms{};

	Parms.Direction = Direction;
	Parms.Rule = Rule;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetNavigationRuleCustom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUINavigation                           Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EUINavigation Navigation)>InCustomDelegate                                       (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UWidget::SetNavigationRuleCustom(EUINavigation Direction, TDelegate<void(EUINavigation Navigation)> InCustomDelegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNavigationRuleCustom");

	Params::Widget_SetNavigationRuleCustom Parms{};

	Parms.Direction = Direction;
	Parms.InCustomDelegate = InCustomDelegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetNavigationRuleCustomBoundary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUINavigation                           Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(EUINavigation Navigation)>InCustomDelegate                                       (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UWidget::SetNavigationRuleCustomBoundary(EUINavigation Direction, TDelegate<void(EUINavigation Navigation)> InCustomDelegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNavigationRuleCustomBoundary");

	Params::Widget_SetNavigationRuleCustomBoundary Parms{};

	Parms.Direction = Direction;
	Parms.InCustomDelegate = InCustomDelegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetNavigationRuleExplicit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUINavigation                           Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetNavigationRuleExplicit(EUINavigation Direction, class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNavigationRuleExplicit");

	Params::Widget_SetNavigationRuleExplicit Parms{};

	Parms.Direction = Direction;
	Parms.InWidget = InWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetRenderOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetRenderOpacity(float InOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderOpacity");

	Params::Widget_SetRenderOpacity Parms{};

	Parms.InOpacity = InOpacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetRenderScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetRenderScale(const struct FVector2D& Scale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderScale");

	Params::Widget_SetRenderScale Parms{};

	Parms.Scale = std::move(Scale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetRenderShear
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Shear                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetRenderShear(const struct FVector2D& Shear)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderShear");

	Params::Widget_SetRenderShear Parms{};

	Parms.Shear = std::move(Shear);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetRenderTransform
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FWidgetTransform                 InTransform                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UWidget::SetRenderTransform(const struct FWidgetTransform& InTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderTransform");

	Params::Widget_SetRenderTransform Parms{};

	Parms.InTransform = std::move(InTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetRenderTransformAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetRenderTransformAngle(float Angle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderTransformAngle");

	Params::Widget_SetRenderTransformAngle Parms{};

	Parms.Angle = Angle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetRenderTransformPivot
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Pivot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetRenderTransformPivot(const struct FVector2D& Pivot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderTransformPivot");

	Params::Widget_SetRenderTransformPivot Parms{};

	Parms.Pivot = std::move(Pivot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetRenderTranslation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Translation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetRenderTranslation(const struct FVector2D& Translation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderTranslation");

	Params::Widget_SetRenderTranslation Parms{};

	Parms.Translation = std::move(Translation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetToolTip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetToolTip(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetToolTip");

	Params::Widget_SetToolTip Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetToolTipText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InToolTipText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWidget::SetToolTipText(const class FText& InToolTipText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetToolTipText");

	Params::Widget_SetToolTipText Parms{};

	Parms.InToolTipText = std::move(InToolTipText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetUserFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetUserFocus(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUserFocus");

	Params::Widget_SetUserFocus Parms{};

	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.SetVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidget::SetVisibility(ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVisibility");

	Params::Widget_SetVisibility Parms{};

	Parms.InVisibility = InVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Widget.GetAccessibleSummaryText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UWidget::GetAccessibleSummaryText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAccessibleSummaryText");

	Params::Widget_GetAccessibleSummaryText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetAccessibleText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UWidget::GetAccessibleText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAccessibleText");

	Params::Widget_GetAccessibleText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetCachedGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGeometry                  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FGeometry UWidget::GetCachedGeometry() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCachedGeometry");

	Params::Widget_GetCachedGeometry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetClipping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWidgetClipping                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWidgetClipping UWidget::GetClipping() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClipping");

	Params::Widget_GetClipping Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetDesiredSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidget::GetDesiredSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDesiredSize");

	Params::Widget_GetDesiredSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetGameInstance
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameInstance* UWidget::GetGameInstance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGameInstance");

	Params::Widget_GetGameInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetIsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::GetIsEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIsEnabled");

	Params::Widget_GetIsEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetOwningLocalPlayer
// (BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULocalPlayer*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayer* UWidget::GetOwningLocalPlayer() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningLocalPlayer");

	Params::Widget_GetOwningLocalPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetOwningPlayer
// (BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UWidget::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningPlayer");

	Params::Widget_GetOwningPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetPaintSpaceGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGeometry                  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FGeometry UWidget::GetPaintSpaceGeometry() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPaintSpaceGeometry");

	Params::Widget_GetPaintSpaceGeometry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetParent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPanelWidget*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPanelWidget* UWidget::GetParent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParent");

	Params::Widget_GetParent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetRenderOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWidget::GetRenderOpacity() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRenderOpacity");

	Params::Widget_GetRenderOpacity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetRenderTransformAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWidget::GetRenderTransformAngle() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRenderTransformAngle");

	Params::Widget_GetRenderTransformAngle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetTickSpaceGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGeometry                  ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FGeometry UWidget::GetTickSpaceGeometry() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTickSpaceGeometry");

	Params::Widget_GetTickSpaceGeometry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.GetVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UWidget::GetVisibility() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVisibility");

	Params::Widget_GetVisibility Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.HasAnyUserFocus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::HasAnyUserFocus() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasAnyUserFocus");

	Params::Widget_HasAnyUserFocus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.HasFocusedDescendants
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::HasFocusedDescendants() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasFocusedDescendants");

	Params::Widget_HasFocusedDescendants Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.HasKeyboardFocus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::HasKeyboardFocus() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasKeyboardFocus");

	Params::Widget_HasKeyboardFocus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.HasMouseCapture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::HasMouseCapture() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasMouseCapture");

	Params::Widget_HasMouseCapture Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.HasMouseCaptureByUser
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   UserIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointerIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::HasMouseCaptureByUser(int32 UserIndex, int32 PointerIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasMouseCaptureByUser");

	Params::Widget_HasMouseCaptureByUser Parms{};

	Parms.UserIndex = UserIndex;
	Parms.PointerIndex = PointerIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.HasUserFocus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::HasUserFocus(class APlayerController* PlayerController) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasUserFocus");

	Params::Widget_HasUserFocus Parms{};

	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.HasUserFocusedDescendants
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::HasUserFocusedDescendants(class APlayerController* PlayerController) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasUserFocusedDescendants");

	Params::Widget_HasUserFocusedDescendants Parms{};

	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.IsHovered
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::IsHovered() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsHovered");

	Params::Widget_IsHovered Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Widget.IsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidget::IsVisible() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsVisible");

	Params::Widget_IsVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ExpandableArea.SetIsExpanded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsExpanded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExpandableArea::SetIsExpanded(bool IsExpanded)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsExpanded");

	Params::ExpandableArea_SetIsExpanded Parms{};

	Parms.IsExpanded = IsExpanded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ExpandableArea.SetIsExpanded_Animated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsExpanded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExpandableArea::SetIsExpanded_Animated(bool IsExpanded)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsExpanded_Animated");

	Params::ExpandableArea_SetIsExpanded_Animated Parms{};

	Parms.IsExpanded = IsExpanded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ExpandableArea.GetIsExpanded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExpandableArea::GetIsExpanded() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIsExpanded");

	Params::ExpandableArea_GetIsExpanded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Slider.SetIndentHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlider::SetIndentHandle(bool InValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIndentHandle");

	Params::Slider_SetIndentHandle Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Slider.SetLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlider::SetLocked(bool InValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLocked");

	Params::Slider_SetLocked Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Slider.SetMaxValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlider::SetMaxValue(float InValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaxValue");

	Params::Slider_SetMaxValue Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Slider.SetMinValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlider::SetMinValue(float InValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinValue");

	Params::Slider_SetMinValue Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Slider.SetSliderBarColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlider::SetSliderBarColor(const struct FLinearColor& InValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSliderBarColor");

	Params::Slider_SetSliderBarColor Parms{};

	Parms.InValue = std::move(InValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Slider.SetSliderHandleColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlider::SetSliderHandleColor(const struct FLinearColor& InValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSliderHandleColor");

	Params::Slider_SetSliderHandleColor Parms{};

	Parms.InValue = std::move(InValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Slider.SetStepSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlider::SetStepSize(float InValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStepSize");

	Params::Slider_SetStepSize Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Slider.SetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlider::SetValue(float InValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetValue");

	Params::Slider_SetValue Parms{};

	Parms.InValue = InValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Slider.GetNormalizedValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USlider::GetNormalizedValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNormalizedValue");

	Params::Slider_GetNormalizedValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Slider.GetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USlider::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::Slider_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ColorBinding.GetLinearValue
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UColorBinding::GetLinearValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinearValue");

	Params::ColorBinding_GetLinearValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ColorBinding.GetSlateValue
// (Final, Native, Public, Const)
// Parameters:
// struct FSlateColor                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateColor UColorBinding::GetSlateValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSlateValue");

	Params::ColorBinding_GetSlateValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.OverlaySlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlaySlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::OverlaySlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.OverlaySlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UOverlaySlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::OverlaySlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.OverlaySlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlaySlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::OverlaySlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Int32Binding.GetValue
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInt32Binding::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::Int32Binding_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.PressAndReleaseKey
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetInteractionComponent::PressAndReleaseKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PressAndReleaseKey");

	Params::WidgetInteractionComponent_PressAndReleaseKey Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.PressKey
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRepeat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetInteractionComponent::PressKey(const struct FKey& Key, bool bRepeat)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PressKey");

	Params::WidgetInteractionComponent_PressKey Parms{};

	Parms.Key = std::move(Key);
	Parms.bRepeat = bRepeat;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.PressPointerKey
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInteractionComponent::PressPointerKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PressPointerKey");

	Params::WidgetInteractionComponent_PressPointerKey Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetInteractionComponent.ReleaseKey
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetInteractionComponent::ReleaseKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReleaseKey");

	Params::WidgetInteractionComponent_ReleaseKey Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.ReleasePointerKey
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInteractionComponent::ReleasePointerKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReleasePointerKey");

	Params::WidgetInteractionComponent_ReleasePointerKey Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetInteractionComponent.ScrollWheel
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ScrollDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInteractionComponent::ScrollWheel(float ScrollDelta)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScrollWheel");

	Params::WidgetInteractionComponent_ScrollWheel Parms{};

	Parms.ScrollDelta = ScrollDelta;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetInteractionComponent.SendKeyChar
// (Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Characters                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRepeat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetInteractionComponent::SendKeyChar(const class FString& Characters, bool bRepeat)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SendKeyChar");

	Params::WidgetInteractionComponent_SendKeyChar Parms{};

	Parms.Characters = std::move(Characters);
	Parms.bRepeat = bRepeat;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.SetCustomHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWidgetInteractionComponent::SetCustomHitResult(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCustomHitResult");

	Params::WidgetInteractionComponent_SetCustomHitResult Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetInteractionComponent.SetFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          FocusWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInteractionComponent::SetFocus(class UWidget* FocusWidget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFocus");

	Params::WidgetInteractionComponent_SetFocus Parms{};

	Parms.FocusWidget = FocusWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetInteractionComponent.Get2DHitLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidgetInteractionComponent::Get2DHitLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Get2DHitLocation");

	Params::WidgetInteractionComponent_Get2DHitLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.GetHoveredWidgetComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidgetComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetComponent* UWidgetInteractionComponent::GetHoveredWidgetComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHoveredWidgetComponent");

	Params::WidgetInteractionComponent_GetHoveredWidgetComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.GetLastHitResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHitResult                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

const struct FHitResult UWidgetInteractionComponent::GetLastHitResult() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastHitResult");

	Params::WidgetInteractionComponent_GetLastHitResult Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.IsOverFocusableWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetInteractionComponent::IsOverFocusableWidget() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOverFocusableWidget");

	Params::WidgetInteractionComponent_IsOverFocusableWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.IsOverHitTestVisibleWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetInteractionComponent::IsOverHitTestVisibleWidget() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOverHitTestVisibleWidget");

	Params::WidgetInteractionComponent_IsOverHitTestVisibleWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetInteractionComponent.IsOverInteractableWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetInteractionComponent::IsOverInteractableWidget() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOverInteractableWidget");

	Params::WidgetInteractionComponent_IsOverInteractableWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.AddChild
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPanelSlot*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPanelSlot* UPanelWidget::AddChild(class UWidget* Content)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddChild");

	Params::PanelWidget_AddChild Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.ClearChildren
// (Native, Public, BlueprintCallable)

void UPanelWidget::ClearChildren()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearChildren");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.PanelWidget.RemoveChild
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPanelWidget::RemoveChild(class UWidget* Content)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveChild");

	Params::PanelWidget_RemoveChild Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.RemoveChildAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPanelWidget::RemoveChildAt(int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveChildAt");

	Params::PanelWidget_RemoveChildAt Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.GetAllChildren
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UWidget*>                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UWidget*> UPanelWidget::GetAllChildren() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllChildren");

	Params::PanelWidget_GetAllChildren Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.GetChildAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UPanelWidget::GetChildAt(int32 Index_0) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetChildAt");

	Params::PanelWidget_GetChildAt Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.GetChildIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          Content                                                (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPanelWidget::GetChildIndex(const class UWidget* Content) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetChildIndex");

	Params::PanelWidget_GetChildIndex Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.GetChildrenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPanelWidget::GetChildrenCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetChildrenCount");

	Params::PanelWidget_GetChildrenCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.HasAnyChildren
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPanelWidget::HasAnyChildren() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasAnyChildren");

	Params::PanelWidget_HasAnyChildren Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.PanelWidget.HasChild
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPanelWidget::HasChild(class UWidget* Content) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasChild");

	Params::PanelWidget_HasChild Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetSwitcher.SetActiveWidget
// (Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetSwitcher::SetActiveWidget(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActiveWidget");

	Params::WidgetSwitcher_SetActiveWidget Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetSwitcher.SetActiveWidgetIndex
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetSwitcher::SetActiveWidgetIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActiveWidgetIndex");

	Params::WidgetSwitcher_SetActiveWidgetIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetSwitcher.GetActiveWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UWidgetSwitcher::GetActiveWidget() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveWidget");

	Params::WidgetSwitcher_GetActiveWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetSwitcher.GetActiveWidgetIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWidgetSwitcher::GetActiveWidgetIndex() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveWidgetIndex");

	Params::WidgetSwitcher_GetActiveWidgetIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetSwitcher.GetNumWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWidgetSwitcher::GetNumWidgets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumWidgets");

	Params::WidgetSwitcher_GetNumWidgets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetSwitcher.GetWidgetAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UWidgetSwitcher::GetWidgetAtIndex(int32 Index_0) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWidgetAtIndex");

	Params::WidgetSwitcher_GetWidgetAtIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CircularThrobber.SetNumberOfPieces
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNumberOfPieces                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCircularThrobber::SetNumberOfPieces(int32 InNumberOfPieces)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNumberOfPieces");

	Params::CircularThrobber_SetNumberOfPieces Parms{};

	Parms.InNumberOfPieces = InNumberOfPieces;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CircularThrobber.SetPeriod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPeriod                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCircularThrobber::SetPeriod(float InPeriod)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPeriod");

	Params::CircularThrobber_SetPeriod Parms{};

	Parms.InPeriod = InPeriod;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CircularThrobber.SetRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCircularThrobber::SetRadius(float InRadius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRadius");

	Params::CircularThrobber_SetRadius Parms{};

	Parms.InRadius = InRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetAnimation.BindToAnimationFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UWidgetAnimation::BindToAnimationFinished(class UUserWidget* Widget, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BindToAnimationFinished");

	Params::WidgetAnimation_BindToAnimationFinished Parms{};

	Parms.Widget = Widget;
	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetAnimation.BindToAnimationStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UWidgetAnimation::BindToAnimationStarted(class UUserWidget* Widget, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BindToAnimationStarted");

	Params::WidgetAnimation_BindToAnimationStarted Parms{};

	Parms.Widget = Widget;
	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetAnimation.UnbindAllFromAnimationFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetAnimation::UnbindAllFromAnimationFinished(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindAllFromAnimationFinished");

	Params::WidgetAnimation_UnbindAllFromAnimationFinished Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetAnimation.UnbindAllFromAnimationStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetAnimation::UnbindAllFromAnimationStarted(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindAllFromAnimationStarted");

	Params::WidgetAnimation_UnbindAllFromAnimationStarted Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetAnimation.UnbindFromAnimationFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UWidgetAnimation::UnbindFromAnimationFinished(class UUserWidget* Widget, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindFromAnimationFinished");

	Params::WidgetAnimation_UnbindFromAnimationFinished Parms{};

	Parms.Widget = Widget;
	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetAnimation.UnbindFromAnimationStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UWidgetAnimation::UnbindFromAnimationStarted(class UUserWidget* Widget, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindFromAnimationStarted");

	Params::WidgetAnimation_UnbindFromAnimationStarted Parms{};

	Parms.Widget = Widget;
	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetAnimation.GetEndTime
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWidgetAnimation::GetEndTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEndTime");

	Params::WidgetAnimation_GetEndTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetAnimation.GetStartTime
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWidgetAnimation::GetStartTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStartTime");

	Params::WidgetAnimation_GetStartTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TextLayoutWidget.SetJustification
// (Native, Public, BlueprintCallable)
// Parameters:
// ETextJustify                            InJustification                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextLayoutWidget::SetJustification(ETextJustify InJustification)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetJustification");

	Params::TextLayoutWidget_SetJustification Parms{};

	Parms.InJustification = InJustification;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.AddToPlayerScreen
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ZOrder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::AddToPlayerScreen(int32 ZOrder)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddToPlayerScreen");

	Params::UserWidget_AddToPlayerScreen Parms{};

	Parms.ZOrder = ZOrder;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.AddToViewport
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ZOrder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::AddToViewport(int32 ZOrder)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddToViewport");

	Params::UserWidget_AddToViewport Parms{};

	Parms.ZOrder = ZOrder;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.BindToAnimationEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// EWidgetAnimationEvent                   AnimationEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UserTag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::BindToAnimationEvent(class UWidgetAnimation* Animation, TDelegate<void()> Delegate, EWidgetAnimationEvent AnimationEvent, class FName UserTag)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BindToAnimationEvent");

	Params::UserWidget_BindToAnimationEvent Parms{};

	Parms.Animation = Animation;
	Parms.Delegate = Delegate;
	Parms.AnimationEvent = AnimationEvent;
	Parms.UserTag = UserTag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.BindToAnimationFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::BindToAnimationFinished(class UWidgetAnimation* Animation, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BindToAnimationFinished");

	Params::UserWidget_BindToAnimationFinished Parms{};

	Parms.Animation = Animation;
	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.BindToAnimationStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::BindToAnimationStarted(class UWidgetAnimation* Animation, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BindToAnimationStarted");

	Params::UserWidget_BindToAnimationStarted Parms{};

	Parms.Animation = Animation;
	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.CancelLatentActions
// (Final, Native, Public, BlueprintCallable)

void UUserWidget::CancelLatentActions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CancelLatentActions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.Construct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UUserWidget::Construct()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Construct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.Destruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UUserWidget::Destruct()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Destruct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.FlushAnimations
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UUserWidget::FlushAnimations()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FlushAnimations");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.IsAnimationPlayingForward
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::IsAnimationPlayingForward(const class UWidgetAnimation* InAnimation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAnimationPlayingForward");

	Params::UserWidget_IsAnimationPlayingForward Parms{};

	Parms.InAnimation = InAnimation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.ListenForInputAction
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::ListenForInputAction(class FName ActionName, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ListenForInputAction");

	Params::UserWidget_ListenForInputAction Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnAddedToFocusPath
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FFocusEvent                      InFocusEvent                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::OnAddedToFocusPath(const struct FFocusEvent& InFocusEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnAddedToFocusPath");

	Params::UserWidget_OnAddedToFocusPath Parms{};

	Parms.InFocusEvent = std::move(InFocusEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnAnalogValueChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FAnalogInputEvent                InAnalogInputEvent                                     (Parm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnAnalogValueChanged(const struct FGeometry& MyGeometry, const struct FAnalogInputEvent& InAnalogInputEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnAnalogValueChanged");

	Params::UserWidget_OnAnalogValueChanged Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InAnalogInputEvent = std::move(InAnalogInputEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnAnimationFinished
// (BlueprintCosmetic, Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::OnAnimationFinished(const class UWidgetAnimation* Animation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnAnimationFinished");

	Params::UserWidget_OnAnimationFinished Parms{};

	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnAnimationStarted
// (BlueprintCosmetic, Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::OnAnimationStarted(const class UWidgetAnimation* Animation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnAnimationStarted");

	Params::UserWidget_OnAnimationStarted Parms{};

	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnDragCancelled
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::OnDragCancelled(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnDragCancelled");

	Params::UserWidget_OnDragCancelled Parms{};

	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnDragDetected
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    PointerEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UDragDropOperation*               Operation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::OnDragDetected(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation** Operation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnDragDetected");

	Params::UserWidget_OnDragDetected Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);

	UObject::ProcessEvent(Func, &Parms);

	if (Operation != nullptr)
		*Operation = Parms.Operation;
}


// Function UMG.UserWidget.OnDragEnter
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    PointerEvent                                           (Parm, NativeAccessSpecifierPublic)
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnDragEnter");

	Params::UserWidget_OnDragEnter Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnDragLeave
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (Parm, NativeAccessSpecifierPublic)
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::OnDragLeave(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnDragLeave");

	Params::UserWidget_OnDragLeave Parms{};

	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnDragOver
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    PointerEvent                                           (Parm, NativeAccessSpecifierPublic)
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::OnDragOver(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnDragOver");

	Params::UserWidget_OnDragOver Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnDrop
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    PointerEvent                                           (Parm, NativeAccessSpecifierPublic)
// class UDragDropOperation*               Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnDrop");

	Params::UserWidget_OnDrop Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnFocusLost
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FFocusEvent                      InFocusEvent                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::OnFocusLost(const struct FFocusEvent& InFocusEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnFocusLost");

	Params::UserWidget_OnFocusLost Parms{};

	Parms.InFocusEvent = std::move(InFocusEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnFocusReceived
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FFocusEvent                      InFocusEvent                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnFocusReceived(const struct FGeometry& MyGeometry, const struct FFocusEvent& InFocusEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnFocusReceived");

	Params::UserWidget_OnFocusReceived Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InFocusEvent = std::move(InFocusEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnInitialized
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UUserWidget::OnInitialized()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.OnKeyChar
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FCharacterEvent                  InCharacterEvent                                       (Parm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnKeyChar(const struct FGeometry& MyGeometry, const struct FCharacterEvent& InCharacterEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnKeyChar");

	Params::UserWidget_OnKeyChar Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InCharacterEvent = std::move(InCharacterEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnKeyDown
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FKeyEvent                        InKeyEvent                                             (Parm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnKeyDown");

	Params::UserWidget_OnKeyDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InKeyEvent = std::move(InKeyEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnKeyUp
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FKeyEvent                        InKeyEvent                                             (Parm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnKeyUp(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnKeyUp");

	Params::UserWidget_OnKeyUp Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InKeyEvent = std::move(InKeyEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnMotionDetected
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMotionEvent                     InMotionEvent                                          (Parm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnMotionDetected(const struct FGeometry& MyGeometry, const struct FMotionEvent& InMotionEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMotionDetected");

	Params::UserWidget_OnMotionDetected Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InMotionEvent = std::move(InMotionEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnMouseButtonDoubleClick
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        InMyGeometry                                           (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnMouseButtonDoubleClick(const struct FGeometry& InMyGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMouseButtonDoubleClick");

	Params::UserWidget_OnMouseButtonDoubleClick Parms{};

	Parms.InMyGeometry = std::move(InMyGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnMouseButtonDown
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMouseButtonDown");

	Params::UserWidget_OnMouseButtonDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnMouseButtonUp
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnMouseButtonUp(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMouseButtonUp");

	Params::UserWidget_OnMouseButtonUp Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnMouseCaptureLost
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UUserWidget::OnMouseCaptureLost()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMouseCaptureLost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.OnMouseEnter
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidget::OnMouseEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMouseEnter");

	Params::UserWidget_OnMouseEnter Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnMouseLeave
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUserWidget::OnMouseLeave(const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMouseLeave");

	Params::UserWidget_OnMouseLeave Parms{};

	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnMouseMove
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnMouseMove(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMouseMove");

	Params::UserWidget_OnMouseMove Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnMouseWheel
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnMouseWheel(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnMouseWheel");

	Params::UserWidget_OnMouseWheel Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnPreviewKeyDown
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FKeyEvent                        InKeyEvent                                             (Parm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnPreviewKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPreviewKeyDown");

	Params::UserWidget_OnPreviewKeyDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InKeyEvent = std::move(InKeyEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnPreviewMouseButtonDown
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnPreviewMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPreviewMouseButtonDown");

	Params::UserWidget_OnPreviewMouseButtonDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnRemovedFromFocusPath
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FFocusEvent                      InFocusEvent                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::OnRemovedFromFocusPath(const struct FFocusEvent& InFocusEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRemovedFromFocusPath");

	Params::UserWidget_OnRemovedFromFocusPath Parms{};

	Parms.InFocusEvent = std::move(InFocusEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.OnTouchEnded
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InTouchEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnTouchEnded(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnTouchEnded");

	Params::UserWidget_OnTouchEnded Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InTouchEvent = std::move(InTouchEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnTouchForceChanged
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InTouchEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnTouchForceChanged(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnTouchForceChanged");

	Params::UserWidget_OnTouchForceChanged Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InTouchEvent = std::move(InTouchEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnTouchGesture
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    GestureEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnTouchGesture(const struct FGeometry& MyGeometry, const struct FPointerEvent& GestureEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnTouchGesture");

	Params::UserWidget_OnTouchGesture Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.GestureEvent = std::move(GestureEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnTouchMoved
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InTouchEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnTouchMoved(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnTouchMoved");

	Params::UserWidget_OnTouchMoved Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InTouchEvent = std::move(InTouchEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnTouchStarted
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InTouchEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UUserWidget::OnTouchStarted(const struct FGeometry& MyGeometry, const struct FPointerEvent& InTouchEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnTouchStarted");

	Params::UserWidget_OnTouchStarted Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InTouchEvent = std::move(InTouchEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.PauseAnimation
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUserWidget::PauseAnimation(const class UWidgetAnimation* InAnimation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PauseAnimation");

	Params::UserWidget_PauseAnimation Parms{};

	Parms.InAnimation = InAnimation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.PlayAnimation
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGSequencePlayMode                    PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoreState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGSequencePlayer*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGSequencePlayer* UUserWidget::PlayAnimation(class UWidgetAnimation* InAnimation, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, bool bRestoreState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayAnimation");

	Params::UserWidget_PlayAnimation Parms{};

	Parms.InAnimation = InAnimation;
	Parms.StartAtTime = StartAtTime;
	Parms.NumLoopsToPlay = NumLoopsToPlay;
	Parms.PlayMode = PlayMode;
	Parms.PlaybackSpeed = PlaybackSpeed;
	Parms.bRestoreState = bRestoreState;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.PlayAnimationForward
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoreState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGSequencePlayer*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGSequencePlayer* UUserWidget::PlayAnimationForward(class UWidgetAnimation* InAnimation, float PlaybackSpeed, bool bRestoreState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayAnimationForward");

	Params::UserWidget_PlayAnimationForward Parms{};

	Parms.InAnimation = InAnimation;
	Parms.PlaybackSpeed = PlaybackSpeed;
	Parms.bRestoreState = bRestoreState;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.PlayAnimationReverse
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoreState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGSequencePlayer*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGSequencePlayer* UUserWidget::PlayAnimationReverse(class UWidgetAnimation* InAnimation, float PlaybackSpeed, bool bRestoreState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayAnimationReverse");

	Params::UserWidget_PlayAnimationReverse Parms{};

	Parms.InAnimation = InAnimation;
	Parms.PlaybackSpeed = PlaybackSpeed;
	Parms.bRestoreState = bRestoreState;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.PlayAnimationTimeRange
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndAtTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGSequencePlayMode                    PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestoreState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGSequencePlayer*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGSequencePlayer* UUserWidget::PlayAnimationTimeRange(class UWidgetAnimation* InAnimation, float StartAtTime, float EndAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed, bool bRestoreState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayAnimationTimeRange");

	Params::UserWidget_PlayAnimationTimeRange Parms{};

	Parms.InAnimation = InAnimation;
	Parms.StartAtTime = StartAtTime;
	Parms.EndAtTime = EndAtTime;
	Parms.NumLoopsToPlay = NumLoopsToPlay;
	Parms.PlayMode = PlayMode;
	Parms.PlaybackSpeed = PlaybackSpeed;
	Parms.bRestoreState = bRestoreState;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.PlaySound
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::PlaySound(class USoundBase* SoundToPlay)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlaySound");

	Params::UserWidget_PlaySound Parms{};

	Parms.SoundToPlay = SoundToPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.PreConstruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsDesignTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::PreConstruct(bool IsDesignTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PreConstruct");

	Params::UserWidget_PreConstruct Parms{};

	Parms.IsDesignTime = IsDesignTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.RegisterInputComponent
// (Final, Native, Protected, BlueprintCallable)

void UUserWidget::RegisterInputComponent()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegisterInputComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.RemoveFromViewport
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UUserWidget::RemoveFromViewport()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveFromViewport");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.ReverseAnimation
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::ReverseAnimation(const class UWidgetAnimation* InAnimation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReverseAnimation");

	Params::UserWidget_ReverseAnimation Parms{};

	Parms.InAnimation = InAnimation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetAlignmentInViewport
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Alignment                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetAlignmentInViewport(const struct FVector2D& Alignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAlignmentInViewport");

	Params::UserWidget_SetAlignmentInViewport Parms{};

	Parms.Alignment = std::move(Alignment);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetAnchorsInViewport
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// struct FAnchors                         Anchors                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::SetAnchorsInViewport(const struct FAnchors& Anchors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnchorsInViewport");

	Params::UserWidget_SetAnchorsInViewport Parms{};

	Parms.Anchors = std::move(Anchors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetAnimationCurrentTime
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetAnimationCurrentTime(const class UWidgetAnimation* InAnimation, float InTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimationCurrentTime");

	Params::UserWidget_SetAnimationCurrentTime Parms{};

	Parms.InAnimation = InAnimation;
	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetColorAndOpacity
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColorAndOpacity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColorAndOpacity");

	Params::UserWidget_SetColorAndOpacity Parms{};

	Parms.InColorAndOpacity = std::move(InColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetDesiredSizeInViewport
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetDesiredSizeInViewport(const struct FVector2D& Size)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDesiredSizeInViewport");

	Params::UserWidget_SetDesiredSizeInViewport Parms{};

	Parms.Size = std::move(Size);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetForegroundColor
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateColor                      InForegroundColor                                      (Parm, NativeAccessSpecifierPublic)

void UUserWidget::SetForegroundColor(const struct FSlateColor& InForegroundColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForegroundColor");

	Params::UserWidget_SetForegroundColor Parms{};

	Parms.InForegroundColor = std::move(InForegroundColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetInputActionBlocking
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bShouldBlock                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetInputActionBlocking(bool bShouldBlock)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInputActionBlocking");

	Params::UserWidget_SetInputActionBlocking Parms{};

	Parms.bShouldBlock = bShouldBlock;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetInputActionPriority
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   NewPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetInputActionPriority(int32 NewPriority)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInputActionPriority");

	Params::UserWidget_SetInputActionPriority Parms{};

	Parms.NewPriority = NewPriority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetNumLoopsToPlay
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetNumLoopsToPlay(const class UWidgetAnimation* InAnimation, int32 NumLoopsToPlay)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNumLoopsToPlay");

	Params::UserWidget_SetNumLoopsToPlay Parms{};

	Parms.InAnimation = InAnimation;
	Parms.NumLoopsToPlay = NumLoopsToPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetOwningPlayer
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                LocalPlayerController                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetOwningPlayer(class APlayerController* LocalPlayerController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOwningPlayer");

	Params::UserWidget_SetOwningPlayer Parms{};

	Parms.LocalPlayerController = LocalPlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetPadding
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::UserWidget_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetPlaybackSpeed
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetPlaybackSpeed(const class UWidgetAnimation* InAnimation, float PlaybackSpeed)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlaybackSpeed");

	Params::UserWidget_SetPlaybackSpeed Parms{};

	Parms.InAnimation = InAnimation;
	Parms.PlaybackSpeed = PlaybackSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.SetPositionInViewport
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveDPIScale                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::SetPositionInViewport(const struct FVector2D& Position, bool bRemoveDPIScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPositionInViewport");

	Params::UserWidget_SetPositionInViewport Parms{};

	Parms.Position = std::move(Position);
	Parms.bRemoveDPIScale = bRemoveDPIScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.StopAllAnimations
// (Final, Native, Public, BlueprintCallable)

void UUserWidget::StopAllAnimations()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllAnimations");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.StopAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::StopAnimation(const class UWidgetAnimation* InAnimation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAnimation");

	Params::UserWidget_StopAnimation Parms{};

	Parms.InAnimation = InAnimation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.StopAnimationsAndLatentActions
// (Final, Native, Public, BlueprintCallable)

void UUserWidget::StopAnimationsAndLatentActions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAnimationsAndLatentActions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.StopListeningForAllInputActions
// (Final, Native, Protected, BlueprintCallable)

void UUserWidget::StopListeningForAllInputActions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopListeningForAllInputActions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.StopListeningForInputAction
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::StopListeningForInputAction(class FName ActionName, EInputEvent EventType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopListeningForInputAction");

	Params::UserWidget_StopListeningForInputAction Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.Tick
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::Tick(const struct FGeometry& MyGeometry, float InDeltaTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Tick");

	Params::UserWidget_Tick Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InDeltaTime = InDeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.UnbindAllFromAnimationFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::UnbindAllFromAnimationFinished(class UWidgetAnimation* Animation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindAllFromAnimationFinished");

	Params::UserWidget_UnbindAllFromAnimationFinished Parms{};

	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.UnbindAllFromAnimationStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserWidget::UnbindAllFromAnimationStarted(class UWidgetAnimation* Animation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindAllFromAnimationStarted");

	Params::UserWidget_UnbindAllFromAnimationStarted Parms{};

	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.UnbindFromAnimationFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::UnbindFromAnimationFinished(class UWidgetAnimation* Animation, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindFromAnimationFinished");

	Params::UserWidget_UnbindFromAnimationFinished Parms{};

	Parms.Animation = Animation;
	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.UnbindFromAnimationStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::UnbindFromAnimationStarted(class UWidgetAnimation* Animation, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindFromAnimationStarted");

	Params::UserWidget_UnbindFromAnimationStarted Parms{};

	Parms.Animation = Animation;
	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserWidget.UnregisterInputComponent
// (Final, Native, Protected, BlueprintCallable)

void UUserWidget::UnregisterInputComponent()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnregisterInputComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserWidget.GetAlignmentInViewport
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UUserWidget::GetAlignmentInViewport() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAlignmentInViewport");

	Params::UserWidget_GetAlignmentInViewport Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.GetAnchorsInViewport
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAnchors                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAnchors UUserWidget::GetAnchorsInViewport() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnchorsInViewport");

	Params::UserWidget_GetAnchorsInViewport Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.GetAnimationCurrentTime
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUserWidget::GetAnimationCurrentTime(const class UWidgetAnimation* InAnimation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnimationCurrentTime");

	Params::UserWidget_GetAnimationCurrentTime Parms{};

	Parms.InAnimation = InAnimation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.GetIsVisible
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::GetIsVisible() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIsVisible");

	Params::UserWidget_GetIsVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.GetOwningPlayerCameraManager
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerCameraManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerCameraManager* UUserWidget::GetOwningPlayerCameraManager() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningPlayerCameraManager");

	Params::UserWidget_GetOwningPlayerCameraManager Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.GetOwningPlayerPawn
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UUserWidget::GetOwningPlayerPawn() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningPlayerPawn");

	Params::UserWidget_GetOwningPlayerPawn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.IsAnimationPlaying
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidgetAnimation*                 InAnimation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::IsAnimationPlaying(const class UWidgetAnimation* InAnimation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAnimationPlaying");

	Params::UserWidget_IsAnimationPlaying Parms{};

	Parms.InAnimation = InAnimation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.IsAnyAnimationPlaying
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::IsAnyAnimationPlaying() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAnyAnimationPlaying");

	Params::UserWidget_IsAnyAnimationPlaying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.IsInteractable
// (BlueprintCosmetic, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::IsInteractable() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInteractable");

	Params::UserWidget_IsInteractable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.IsInViewport
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::IsInViewport() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInViewport");

	Params::UserWidget_IsInViewport Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.IsListeningForInputAction
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::IsListeningForInputAction(class FName ActionName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsListeningForInputAction");

	Params::UserWidget_IsListeningForInputAction Parms{};

	Parms.ActionName = ActionName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.IsPlayingAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserWidget::IsPlayingAnimation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlayingAnimation");

	Params::UserWidget_IsPlayingAnimation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserWidget.OnPaint
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FPaintContext                    Context                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUserWidget::OnPaint(struct FPaintContext& Context) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPaint");

	Params::UserWidget_OnPaint Parms{};

	Parms.Context = std::move(Context);

	UObject::ProcessEvent(Func, &Parms);

	Context = std::move(Parms.Context);
}


// Function UMG.InputKeySelector.SetAllowGamepadKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllowGamepadKeys                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputKeySelector::SetAllowGamepadKeys(bool bInAllowGamepadKeys)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllowGamepadKeys");

	Params::InputKeySelector_SetAllowGamepadKeys Parms{};

	Parms.bInAllowGamepadKeys = bInAllowGamepadKeys;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.InputKeySelector.SetAllowModifierKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllowModifierKeys                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputKeySelector::SetAllowModifierKeys(bool bInAllowModifierKeys)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllowModifierKeys");

	Params::InputKeySelector_SetAllowModifierKeys Parms{};

	Parms.bInAllowModifierKeys = bInAllowModifierKeys;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.InputKeySelector.SetEscapeKeys
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FKey>                     InKeys                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInputKeySelector::SetEscapeKeys(const TArray<struct FKey>& InKeys)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEscapeKeys");

	Params::InputKeySelector_SetEscapeKeys Parms{};

	Parms.InKeys = std::move(InKeys);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.InputKeySelector.SetKeySelectionText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InKeySelectionText                                     (Parm, NativeAccessSpecifierPublic)

void UInputKeySelector::SetKeySelectionText(const class FText& InKeySelectionText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetKeySelectionText");

	Params::InputKeySelector_SetKeySelectionText Parms{};

	Parms.InKeySelectionText = std::move(InKeySelectionText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.InputKeySelector.SetNoKeySpecifiedText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InNoKeySpecifiedText                                   (Parm, NativeAccessSpecifierPublic)

void UInputKeySelector::SetNoKeySpecifiedText(const class FText& InNoKeySpecifiedText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNoKeySpecifiedText");

	Params::InputKeySelector_SetNoKeySpecifiedText Parms{};

	Parms.InNoKeySpecifiedText = std::move(InNoKeySpecifiedText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.InputKeySelector.SetSelectedKey
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputChord                      InSelectedKey                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputKeySelector::SetSelectedKey(const struct FInputChord& InSelectedKey)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSelectedKey");

	Params::InputKeySelector_SetSelectedKey Parms{};

	Parms.InSelectedKey = std::move(InSelectedKey);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.InputKeySelector.SetTextBlockVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        InVisibility                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputKeySelector::SetTextBlockVisibility(const ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextBlockVisibility");

	Params::InputKeySelector_SetTextBlockVisibility Parms{};

	Parms.InVisibility = InVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.InputKeySelector.GetIsSelectingKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputKeySelector::GetIsSelectingKey() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIsSelectingKey");

	Params::InputKeySelector_GetIsSelectingKey Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserListEntry.BP_OnEntryReleased
// (Event, Protected, BlueprintEvent)

void IUserListEntry::BP_OnEntryReleased()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_OnEntryReleased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.UserListEntry.BP_OnItemExpansionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsExpanded                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IUserListEntry::BP_OnItemExpansionChanged(bool bIsExpanded)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_OnItemExpansionChanged");

	Params::UserListEntry_BP_OnItemExpansionChanged Parms{};

	Parms.bIsExpanded = bIsExpanded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserListEntry.BP_OnItemSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IUserListEntry::BP_OnItemSelectionChanged(bool bIsSelected)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_OnItemSelectionChanged");

	Params::UserListEntry_BP_OnItemSelectionChanged Parms{};

	Parms.bIsSelected = bIsSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UserObjectListEntry.OnListItemObjectSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UObject*                          ListItemObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IUserObjectListEntry::OnListItemObjectSet(class UObject* ListItemObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnListItemObjectSet");

	Params::UserObjectListEntry_OnListItemObjectSet Parms{};

	Parms.ListItemObject = ListItemObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ContentWidget.SetContent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPanelSlot*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPanelSlot* UContentWidget::SetContent(class UWidget* Content)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetContent");

	Params::ContentWidget_SetContent Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ContentWidget.GetContent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UContentWidget::GetContent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetContent");

	Params::ContentWidget_GetContent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ContentWidget.GetContentSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPanelSlot*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPanelSlot* UContentWidget::GetContentSlot() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetContentSlot");

	Params::ContentWidget_GetContentSlot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SizeBox.ClearHeightOverride
// (Final, Native, Public, BlueprintCallable)

void USizeBox::ClearHeightOverride()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearHeightOverride");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SizeBox.ClearMaxAspectRatio
// (Final, Native, Public, BlueprintCallable)

void USizeBox::ClearMaxAspectRatio()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMaxAspectRatio");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SizeBox.ClearMaxDesiredHeight
// (Final, Native, Public, BlueprintCallable)

void USizeBox::ClearMaxDesiredHeight()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMaxDesiredHeight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SizeBox.ClearMaxDesiredWidth
// (Final, Native, Public, BlueprintCallable)

void USizeBox::ClearMaxDesiredWidth()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMaxDesiredWidth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SizeBox.ClearMinAspectRatio
// (Final, Native, Public, BlueprintCallable)

void USizeBox::ClearMinAspectRatio()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMinAspectRatio");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SizeBox.ClearMinDesiredHeight
// (Final, Native, Public, BlueprintCallable)

void USizeBox::ClearMinDesiredHeight()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMinDesiredHeight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SizeBox.ClearMinDesiredWidth
// (Final, Native, Public, BlueprintCallable)

void USizeBox::ClearMinDesiredWidth()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMinDesiredWidth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SizeBox.ClearWidthOverride
// (Final, Native, Public, BlueprintCallable)

void USizeBox::ClearWidthOverride()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearWidthOverride");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SizeBox.SetHeightOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHeightOverride                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBox::SetHeightOverride(float InHeightOverride)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHeightOverride");

	Params::SizeBox_SetHeightOverride Parms{};

	Parms.InHeightOverride = InHeightOverride;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBox.SetMaxAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMaxAspectRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBox::SetMaxAspectRatio(float InMaxAspectRatio)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaxAspectRatio");

	Params::SizeBox_SetMaxAspectRatio Parms{};

	Parms.InMaxAspectRatio = InMaxAspectRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBox.SetMaxDesiredHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMaxDesiredHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBox::SetMaxDesiredHeight(float InMaxDesiredHeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaxDesiredHeight");

	Params::SizeBox_SetMaxDesiredHeight Parms{};

	Parms.InMaxDesiredHeight = InMaxDesiredHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBox.SetMaxDesiredWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMaxDesiredWidth                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBox::SetMaxDesiredWidth(float InMaxDesiredWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaxDesiredWidth");

	Params::SizeBox_SetMaxDesiredWidth Parms{};

	Parms.InMaxDesiredWidth = InMaxDesiredWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBox.SetMinAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinAspectRatio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBox::SetMinAspectRatio(float InMinAspectRatio)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinAspectRatio");

	Params::SizeBox_SetMinAspectRatio Parms{};

	Parms.InMinAspectRatio = InMinAspectRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBox.SetMinDesiredHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinDesiredHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBox::SetMinDesiredHeight(float InMinDesiredHeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinDesiredHeight");

	Params::SizeBox_SetMinDesiredHeight Parms{};

	Parms.InMinDesiredHeight = InMinDesiredHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBox.SetMinDesiredWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinDesiredWidth                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBox::SetMinDesiredWidth(float InMinDesiredWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinDesiredWidth");

	Params::SizeBox_SetMinDesiredWidth Parms{};

	Parms.InMinDesiredWidth = InMinDesiredWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBox.SetWidthOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWidthOverride                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBox::SetWidthOverride(float InWidthOverride)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWidthOverride");

	Params::SizeBox_SetWidthOverride Parms{};

	Parms.InWidthOverride = InWidthOverride;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.DragDropOperation.DragCancelled
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDragDropOperation::DragCancelled(const struct FPointerEvent& PointerEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DragCancelled");

	Params::DragDropOperation_DragCancelled Parms{};

	Parms.PointerEvent = std::move(PointerEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.DragDropOperation.Dragged
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDragDropOperation::Dragged(const struct FPointerEvent& PointerEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Dragged");

	Params::DragDropOperation_Dragged Parms{};

	Parms.PointerEvent = std::move(PointerEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.DragDropOperation.Drop
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDragDropOperation::Drop(const struct FPointerEvent& PointerEvent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Drop");

	Params::DragDropOperation_Drop Parms{};

	Parms.PointerEvent = std::move(PointerEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.GetDynamicMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UBorder::GetDynamicMaterial()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDynamicMaterial");

	Params::Border_GetDynamicMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Border.SetBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBorder::SetBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrush");

	Params::Border_SetBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetBrushColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InBrushColor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorder::SetBrushColor(const struct FLinearColor& InBrushColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushColor");

	Params::Border_SetBrushColor Parms{};

	Parms.InBrushColor = std::move(InBrushColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetBrushFromAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USlateBrushAsset*                 Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorder::SetBrushFromAsset(class USlateBrushAsset* Asset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromAsset");

	Params::Border_SetBrushFromAsset Parms{};

	Parms.Asset = Asset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetBrushFromMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorder::SetBrushFromMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromMaterial");

	Params::Border_SetBrushFromMaterial Parms{};

	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetBrushFromTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorder::SetBrushFromTexture(class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromTexture");

	Params::Border_SetBrushFromTexture Parms{};

	Parms.Texture = Texture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetContentColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InContentColorAndOpacity                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorder::SetContentColorAndOpacity(const struct FLinearColor& InContentColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetContentColorAndOpacity");

	Params::Border_SetContentColorAndOpacity Parms{};

	Parms.InContentColorAndOpacity = std::move(InContentColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetDesiredSizeScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorder::SetDesiredSizeScale(const struct FVector2D& InScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDesiredSizeScale");

	Params::Border_SetDesiredSizeScale Parms{};

	Parms.InScale = std::move(InScale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorder::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::Border_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBorder::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::Border_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Border.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorder::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::Border_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.DynamicEntryBoxBase.SetEntrySpacing
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InEntrySpacing                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEntryBoxBase::SetEntrySpacing(const struct FVector2D& InEntrySpacing)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEntrySpacing");

	Params::DynamicEntryBoxBase_SetEntrySpacing Parms{};

	Parms.InEntrySpacing = std::move(InEntrySpacing);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.DynamicEntryBoxBase.SetRadialSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRadialBoxSettings               InSettings                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDynamicEntryBoxBase::SetRadialSettings(const struct FRadialBoxSettings& InSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRadialSettings");

	Params::DynamicEntryBoxBase_SetRadialSettings Parms{};

	Parms.InSettings = std::move(InSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.DynamicEntryBoxBase.GetAllEntries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UUserWidget*>        ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UUserWidget*> UDynamicEntryBoxBase::GetAllEntries() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllEntries");

	Params::DynamicEntryBoxBase_GetAllEntries Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.DynamicEntryBoxBase.GetNumEntries
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDynamicEntryBoxBase::GetNumEntries() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumEntries");

	Params::DynamicEntryBoxBase_GetNumEntries Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Button.SetBackgroundColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InBackgroundColor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButton::SetBackgroundColor(const struct FLinearColor& InBackgroundColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBackgroundColor");

	Params::Button_SetBackgroundColor Parms{};

	Parms.InBackgroundColor = std::move(InBackgroundColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Button.SetClickMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EButtonClickMethod                      InClickMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButton::SetClickMethod(EButtonClickMethod InClickMethod)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetClickMethod");

	Params::Button_SetClickMethod Parms{};

	Parms.InClickMethod = InClickMethod;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Button.SetColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColorAndOpacity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButton::SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColorAndOpacity");

	Params::Button_SetColorAndOpacity Parms{};

	Parms.InColorAndOpacity = std::move(InColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Button.SetPressMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EButtonPressMethod                      InPressMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButton::SetPressMethod(EButtonPressMethod InPressMethod)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPressMethod");

	Params::Button_SetPressMethod Parms{};

	Parms.InPressMethod = InPressMethod;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Button.SetStyle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FButtonStyle                     InStyle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UButton::SetStyle(const struct FButtonStyle& InStyle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStyle");

	Params::Button_SetStyle Parms{};

	Parms.InStyle = std::move(InStyle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Button.SetTouchMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EButtonTouchMethod                      InTouchMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButton::SetTouchMethod(EButtonTouchMethod InTouchMethod)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTouchMethod");

	Params::Button_SetTouchMethod Parms{};

	Parms.InTouchMethod = InTouchMethod;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Button.IsPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UButton::IsPressed() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPressed");

	Params::Button_IsPressed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TextBlock.GetDynamicFontMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UTextBlock::GetDynamicFontMaterial()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDynamicFontMaterial");

	Params::TextBlock_GetDynamicFontMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TextBlock.GetDynamicOutlineMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UTextBlock::GetDynamicOutlineMaterial()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDynamicOutlineMaterial");

	Params::TextBlock_GetDynamicOutlineMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TextBlock.SetAutoWrapText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InAutoTextWrap                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlock::SetAutoWrapText(bool InAutoTextWrap)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAutoWrapText");

	Params::TextBlock_SetAutoWrapText Parms{};

	Parms.InAutoTextWrap = InAutoTextWrap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetColorAndOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateColor                      InColorAndOpacity                                      (Parm, NativeAccessSpecifierPublic)

void UTextBlock::SetColorAndOpacity(const struct FSlateColor& InColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColorAndOpacity");

	Params::TextBlock_SetColorAndOpacity Parms{};

	Parms.InColorAndOpacity = std::move(InColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetFont
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateFontInfo                   InFontInfo                                             (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlock::SetFont(const struct FSlateFontInfo& InFontInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFont");

	Params::TextBlock_SetFont Parms{};

	Parms.InFontInfo = std::move(InFontInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetMinDesiredWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinDesiredWidth                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlock::SetMinDesiredWidth(float InMinDesiredWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinDesiredWidth");

	Params::TextBlock_SetMinDesiredWidth Parms{};

	Parms.InMinDesiredWidth = InMinDesiredWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlock::SetOpacity(float InOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOpacity");

	Params::TextBlock_SetOpacity Parms{};

	Parms.InOpacity = InOpacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetShadowColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InShadowColorAndOpacity                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlock::SetShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowColorAndOpacity");

	Params::TextBlock_SetShadowColorAndOpacity Parms{};

	Parms.InShadowColorAndOpacity = std::move(InShadowColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetShadowOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InShadowOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlock::SetShadowOffset(const struct FVector2D& InShadowOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowOffset");

	Params::TextBlock_SetShadowOffset Parms{};

	Parms.InShadowOffset = std::move(InShadowOffset);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetStrikeBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InStrikeBrush                                          (Parm, NativeAccessSpecifierPublic)

void UTextBlock::SetStrikeBrush(const struct FSlateBrush& InStrikeBrush)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStrikeBrush");

	Params::TextBlock_SetStrikeBrush Parms{};

	Parms.InStrikeBrush = std::move(InStrikeBrush);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetText
// (Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UTextBlock::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetText");

	Params::TextBlock_SetText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetTextOverflowPolicy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextOverflowPolicy                     InOverflowPolicy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlock::SetTextOverflowPolicy(ETextOverflowPolicy InOverflowPolicy)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextOverflowPolicy");

	Params::TextBlock_SetTextOverflowPolicy Parms{};

	Parms.InOverflowPolicy = InOverflowPolicy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.SetTextTransformPolicy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextTransformPolicy                    InTransformPolicy                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextBlock::SetTextTransformPolicy(ETextTransformPolicy InTransformPolicy)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextTransformPolicy");

	Params::TextBlock_SetTextTransformPolicy Parms{};

	Parms.InTransformPolicy = InTransformPolicy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TextBlock.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTextBlock::GetText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetText");

	Params::TextBlock_GetText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CanvasPanel.AddChildToCanvas
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCanvasPanelSlot*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCanvasPanelSlot* UCanvasPanel::AddChildToCanvas(class UWidget* Content)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddChildToCanvas");

	Params::CanvasPanel_AddChildToCanvas Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ScrollBox.EndInertialScrolling
// (Final, Native, Public, BlueprintCallable)

void UScrollBox::EndInertialScrolling()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EndInertialScrolling");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ScrollBox.ScrollToEnd
// (Final, Native, Public, BlueprintCallable)

void UScrollBox::ScrollToEnd()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScrollToEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ScrollBox.ScrollToStart
// (Final, Native, Public, BlueprintCallable)

void UScrollBox::ScrollToStart()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScrollToStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ScrollBox.ScrollWidgetIntoView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          WidgetToFind                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AnimateScroll                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDescendantScrollDestination            ScrollDestination                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Padding                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::ScrollWidgetIntoView(class UWidget* WidgetToFind, bool AnimateScroll, EDescendantScrollDestination ScrollDestination, float Padding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScrollWidgetIntoView");

	Params::ScrollBox_ScrollWidgetIntoView Parms{};

	Parms.WidgetToFind = WidgetToFind;
	Parms.AnimateScroll = AnimateScroll;
	Parms.ScrollDestination = ScrollDestination;
	Parms.Padding = Padding;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetAllowOverscroll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewAllowOverscroll                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetAllowOverscroll(bool NewAllowOverscroll)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllowOverscroll");

	Params::ScrollBox_SetAllowOverscroll Parms{};

	Parms.NewAllowOverscroll = NewAllowOverscroll;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetAlwaysShowScrollbar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewAlwaysShowScrollbar                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetAlwaysShowScrollbar(bool NewAlwaysShowScrollbar)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAlwaysShowScrollbar");

	Params::ScrollBox_SetAlwaysShowScrollbar Parms{};

	Parms.NewAlwaysShowScrollbar = NewAlwaysShowScrollbar;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetAnimateWheelScrolling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldAnimateWheelScrolling                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetAnimateWheelScrolling(bool bShouldAnimateWheelScrolling)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimateWheelScrolling");

	Params::ScrollBox_SetAnimateWheelScrolling Parms{};

	Parms.bShouldAnimateWheelScrolling = bShouldAnimateWheelScrolling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetConsumeMouseWheel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EConsumeMouseWheel                      NewConsumeMouseWheel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetConsumeMouseWheel(EConsumeMouseWheel NewConsumeMouseWheel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConsumeMouseWheel");

	Params::ScrollBox_SetConsumeMouseWheel Parms{};

	Parms.NewConsumeMouseWheel = NewConsumeMouseWheel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetNavigationDestination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDescendantScrollDestination            NewNavigationDestination                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetNavigationDestination(const EDescendantScrollDestination NewNavigationDestination)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNavigationDestination");

	Params::ScrollBox_SetNavigationDestination Parms{};

	Parms.NewNavigationDestination = NewNavigationDestination;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetOrientation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOrientation                            NewOrientation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetOrientation(EOrientation NewOrientation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOrientation");

	Params::ScrollBox_SetOrientation Parms{};

	Parms.NewOrientation = NewOrientation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetScrollbarPadding
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMargin                          NewScrollbarPadding                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UScrollBox::SetScrollbarPadding(const struct FMargin& NewScrollbarPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScrollbarPadding");

	Params::ScrollBox_SetScrollbarPadding Parms{};

	Parms.NewScrollbarPadding = std::move(NewScrollbarPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetScrollbarThickness
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        NewScrollbarThickness                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetScrollbarThickness(const struct FVector2D& NewScrollbarThickness)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScrollbarThickness");

	Params::ScrollBox_SetScrollbarThickness Parms{};

	Parms.NewScrollbarThickness = std::move(NewScrollbarThickness);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetScrollBarVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        NewScrollBarVisibility                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetScrollBarVisibility(ESlateVisibility NewScrollBarVisibility)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScrollBarVisibility");

	Params::ScrollBox_SetScrollBarVisibility Parms{};

	Parms.NewScrollBarVisibility = NewScrollBarVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetScrollOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewScrollOffset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetScrollOffset(float NewScrollOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScrollOffset");

	Params::ScrollBox_SetScrollOffset Parms{};

	Parms.NewScrollOffset = NewScrollOffset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetScrollWhenFocusChanges
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EScrollWhenFocusChanges                 NewScrollWhenFocusChanges                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetScrollWhenFocusChanges(EScrollWhenFocusChanges NewScrollWhenFocusChanges)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScrollWhenFocusChanges");

	Params::ScrollBox_SetScrollWhenFocusChanges Parms{};

	Parms.NewScrollWhenFocusChanges = NewScrollWhenFocusChanges;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.SetWheelScrollMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewWheelScrollMultiplier                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBox::SetWheelScrollMultiplier(float NewWheelScrollMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWheelScrollMultiplier");

	Params::ScrollBox_SetWheelScrollMultiplier Parms{};

	Parms.NewWheelScrollMultiplier = NewWheelScrollMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBox.GetScrollOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UScrollBox::GetScrollOffset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScrollOffset");

	Params::ScrollBox_GetScrollOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ScrollBox.GetScrollOffsetOfEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UScrollBox::GetScrollOffsetOfEnd() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScrollOffsetOfEnd");

	Params::ScrollBox_GetScrollOffsetOfEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ScrollBox.GetViewOffsetFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UScrollBox::GetViewOffsetFraction() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetViewOffsetFraction");

	Params::ScrollBox_GetViewOffsetFraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.HorizontalBoxSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHorizontalBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::HorizontalBoxSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.HorizontalBoxSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UHorizontalBoxSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::HorizontalBoxSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.HorizontalBoxSlot.SetSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateChildSize                  InSize                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UHorizontalBoxSlot::SetSize(const struct FSlateChildSize& InSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSize");

	Params::HorizontalBoxSlot_SetSize Parms{};

	Parms.InSize = std::move(InSize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.HorizontalBoxSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHorizontalBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::HorizontalBoxSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.GetDynamicMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UImage::GetDynamicMaterial()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDynamicMaterial");

	Params::Image_GetDynamicMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Image.SetBrush
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UImage::SetBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrush");

	Params::Image_SetBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushFromAsset
// (Native, Public, BlueprintCallable)
// Parameters:
// class USlateBrushAsset*                 Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetBrushFromAsset(class USlateBrushAsset* Asset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromAsset");

	Params::Image_SetBrushFromAsset Parms{};

	Parms.Asset = Asset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushFromAtlasInterface
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlateTextureAtlasInterface>AtlasRegion                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetBrushFromAtlasInterface(TScriptInterface<class ISlateTextureAtlasInterface> AtlasRegion, bool bMatchSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromAtlasInterface");

	Params::Image_SetBrushFromAtlasInterface Parms{};

	Parms.AtlasRegion = AtlasRegion;
	Parms.bMatchSize = bMatchSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushFromMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetBrushFromMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromMaterial");

	Params::Image_SetBrushFromMaterial Parms{};

	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushFromSoftMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UMaterialInterface>SoftMaterial                                           (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetBrushFromSoftMaterial(TSoftObjectPtr<class UMaterialInterface> SoftMaterial)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromSoftMaterial");

	Params::Image_SetBrushFromSoftMaterial Parms{};

	Parms.SoftMaterial = SoftMaterial;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushFromSoftTexture
// (Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UTexture2D>        SoftTexture                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetBrushFromSoftTexture(TSoftObjectPtr<class UTexture2D> SoftTexture, bool bMatchSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromSoftTexture");

	Params::Image_SetBrushFromSoftTexture Parms{};

	Parms.SoftTexture = SoftTexture;
	Parms.bMatchSize = bMatchSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushFromTexture
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetBrushFromTexture(class UTexture2D* Texture, bool bMatchSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromTexture");

	Params::Image_SetBrushFromTexture Parms{};

	Parms.Texture = Texture;
	Parms.bMatchSize = bMatchSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushFromTextureDynamic
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2DDynamic*                Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetBrushFromTextureDynamic(class UTexture2DDynamic* Texture, bool bMatchSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushFromTextureDynamic");

	Params::Image_SetBrushFromTextureDynamic Parms{};

	Parms.Texture = Texture;
	Parms.bMatchSize = bMatchSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushResourceObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          ResourceObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetBrushResourceObject(class UObject* ResourceObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushResourceObject");

	Params::Image_SetBrushResourceObject Parms{};

	Parms.ResourceObject = ResourceObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetBrushTintColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateColor                      TintColor                                              (Parm, NativeAccessSpecifierPublic)

void UImage::SetBrushTintColor(const struct FSlateColor& TintColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrushTintColor");

	Params::Image_SetBrushTintColor Parms{};

	Parms.TintColor = std::move(TintColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColorAndOpacity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetColorAndOpacity(const struct FLinearColor& InColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColorAndOpacity");

	Params::Image_SetColorAndOpacity Parms{};

	Parms.InColorAndOpacity = std::move(InColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetDesiredSizeOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        DesiredSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetDesiredSizeOverride(const struct FVector2D& DesiredSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDesiredSizeOverride");

	Params::Image_SetDesiredSizeOverride Parms{};

	Parms.DesiredSize = std::move(DesiredSize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Image.SetOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImage::SetOpacity(float InOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOpacity");

	Params::Image_SetOpacity Parms{};

	Parms.InOpacity = InOpacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableTextBox.SetError
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InError                                                (Parm, NativeAccessSpecifierPublic)

void UMultiLineEditableTextBox::SetError(const class FText& InError)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetError");

	Params::MultiLineEditableTextBox_SetError Parms{};

	Parms.InError = std::move(InError);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableTextBox.SetForegroundColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiLineEditableTextBox::SetForegroundColor(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForegroundColor");

	Params::MultiLineEditableTextBox_SetForegroundColor Parms{};

	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableTextBox.SetHintText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InHintText                                             (Parm, NativeAccessSpecifierPublic)

void UMultiLineEditableTextBox::SetHintText(const class FText& InHintText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHintText");

	Params::MultiLineEditableTextBox_SetHintText Parms{};

	Parms.InHintText = std::move(InHintText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableTextBox.SetIsReadOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bReadOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiLineEditableTextBox::SetIsReadOnly(bool bReadOnly)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsReadOnly");

	Params::MultiLineEditableTextBox_SetIsReadOnly Parms{};

	Parms.bReadOnly = bReadOnly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableTextBox.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UMultiLineEditableTextBox::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetText");

	Params::MultiLineEditableTextBox_SetText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableTextBox.SetTextStyle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTextBlockStyle                  InTextStyle                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMultiLineEditableTextBox::SetTextStyle(const struct FTextBlockStyle& InTextStyle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextStyle");

	Params::MultiLineEditableTextBox_SetTextStyle Parms{};

	Parms.InTextStyle = std::move(InTextStyle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableTextBox.GetHintText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMultiLineEditableTextBox::GetHintText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHintText");

	Params::MultiLineEditableTextBox_GetHintText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.MultiLineEditableTextBox.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMultiLineEditableTextBox::GetText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetText");

	Params::MultiLineEditableTextBox_GetText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListViewBase.RegenerateAllEntries
// (Final, Native, Public, BlueprintCallable)

void UListViewBase::RegenerateAllEntries()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegenerateAllEntries");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ListViewBase.RequestRefresh
// (Final, Native, Public, BlueprintCallable)

void UListViewBase::RequestRefresh()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RequestRefresh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ListViewBase.ScrollToBottom
// (Final, Native, Public, BlueprintCallable)

void UListViewBase::ScrollToBottom()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScrollToBottom");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ListViewBase.ScrollToTop
// (Final, Native, Public, BlueprintCallable)

void UListViewBase::ScrollToTop()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScrollToTop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ListViewBase.SetScrollBarVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListViewBase::SetScrollBarVisibility(ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScrollBarVisibility");

	Params::ListViewBase_SetScrollBarVisibility Parms{};

	Parms.InVisibility = InVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListViewBase.SetScrollOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InScrollOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListViewBase::SetScrollOffset(const float InScrollOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScrollOffset");

	Params::ListViewBase_SetScrollOffset Parms{};

	Parms.InScrollOffset = InScrollOffset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListViewBase.SetWheelScrollMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewWheelScrollMultiplier                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListViewBase::SetWheelScrollMultiplier(float NewWheelScrollMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWheelScrollMultiplier");

	Params::ListViewBase_SetWheelScrollMultiplier Parms{};

	Parms.NewWheelScrollMultiplier = NewWheelScrollMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListViewBase.GetDisplayedEntryWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UUserWidget*>        ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UUserWidget*> UListViewBase::GetDisplayedEntryWidgets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDisplayedEntryWidgets");

	Params::ListViewBase_GetDisplayedEntryWidgets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListViewBase.GetScrollOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UListViewBase::GetScrollOffset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScrollOffset");

	Params::ListViewBase_GetScrollOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListView.AddItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::AddItem(class UObject* Item)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddItem");

	Params::ListView_AddItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.BP_CancelScrollIntoView
// (Final, Native, Private, BlueprintCallable)

void UListView::BP_CancelScrollIntoView()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_CancelScrollIntoView");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ListView.BP_ClearSelection
// (Final, Native, Private, BlueprintCallable)

void UListView::BP_ClearSelection()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_ClearSelection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ListView.BP_NavigateToItem
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::BP_NavigateToItem(class UObject* Item)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_NavigateToItem");

	Params::ListView_BP_NavigateToItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.BP_ScrollItemIntoView
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::BP_ScrollItemIntoView(class UObject* Item)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_ScrollItemIntoView");

	Params::ListView_BP_ScrollItemIntoView Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.BP_SetItemSelection
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSelected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::BP_SetItemSelection(class UObject* Item, bool bSelected)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_SetItemSelection");

	Params::ListView_BP_SetItemSelection Parms{};

	Parms.Item = Item;
	Parms.bSelected = bSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.BP_SetListItems
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  InListItems                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UListView::BP_SetListItems(const TArray<class UObject*>& InListItems)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_SetListItems");

	Params::ListView_BP_SetListItems Parms{};

	Parms.InListItems = std::move(InListItems);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.BP_SetSelectedItem
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::BP_SetSelectedItem(class UObject* Item)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_SetSelectedItem");

	Params::ListView_BP_SetSelectedItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.ClearListItems
// (Final, Native, Public, BlueprintCallable)

void UListView::ClearListItems()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearListItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ListView.NavigateToIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::NavigateToIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NavigateToIndex");

	Params::ListView_NavigateToIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.RemoveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::RemoveItem(class UObject* Item)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveItem");

	Params::ListView_RemoveItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.ScrollIndexIntoView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::ScrollIndexIntoView(int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScrollIndexIntoView");

	Params::ListView_ScrollIndexIntoView Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.SetSelectedIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::SetSelectedIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSelectedIndex");

	Params::ListView_SetSelectedIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.SetSelectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESelectionMode                          SelectionMode_0                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListView::SetSelectionMode(ESelectionMode SelectionMode_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSelectionMode");

	Params::ListView_SetSelectionMode Parms{};

	Parms.SelectionMode_0 = SelectionMode_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ListView.BP_GetNumItemsSelected
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UListView::BP_GetNumItemsSelected() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_GetNumItemsSelected");

	Params::ListView_BP_GetNumItemsSelected Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListView.BP_GetSelectedItem
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UListView::BP_GetSelectedItem() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_GetSelectedItem");

	Params::ListView_BP_GetSelectedItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListView.BP_GetSelectedItems
// (Final, Native, Private, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<class UObject*>                  Items                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UListView::BP_GetSelectedItems(TArray<class UObject*>* Items) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_GetSelectedItems");

	Params::ListView_BP_GetSelectedItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Items != nullptr)
		*Items = std::move(Parms.Items);

	return Parms.ReturnValue;
}


// Function UMG.ListView.BP_IsItemVisible
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UListView::BP_IsItemVisible(class UObject* Item) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_IsItemVisible");

	Params::ListView_BP_IsItemVisible Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListView.GetIndexForItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UListView::GetIndexForItem(const class UObject* Item) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIndexForItem");

	Params::ListView_GetIndexForItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListView.GetItemAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UListView::GetItemAt(int32 Index_0) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetItemAt");

	Params::ListView_GetItemAt Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListView.GetListItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UObject*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class UObject*> UListView::GetListItems() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetListItems");

	Params::ListView_GetListItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListView.GetNumItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UListView::GetNumItems() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumItems");

	Params::ListView_GetNumItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ListView.IsRefreshPending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UListView::IsRefreshPending() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsRefreshPending");

	Params::ListView_IsRefreshPending Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.AsyncTaskDownloadImage.DownloadImage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskDownloadImage*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskDownloadImage* UAsyncTaskDownloadImage::DownloadImage(const class FString& URL)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DownloadImage");

	Params::AsyncTaskDownloadImage_DownloadImage Parms{};

	Parms.URL = std::move(URL);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.RichTextBlock.ClearAllDefaultStyleOverrides
// (Final, Native, Public)

void URichTextBlock::ClearAllDefaultStyleOverrides()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearAllDefaultStyleOverrides");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.RichTextBlock.GetDecoratorByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class URichTextBlockDecorator>DecoratorClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URichTextBlockDecorator*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URichTextBlockDecorator* URichTextBlock::GetDecoratorByClass(TSubclassOf<class URichTextBlockDecorator> DecoratorClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDecoratorByClass");

	Params::RichTextBlock_GetDecoratorByClass Parms{};

	Parms.DecoratorClass = DecoratorClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.RichTextBlock.SetAutoWrapText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InAutoTextWrap                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URichTextBlock::SetAutoWrapText(bool InAutoTextWrap)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAutoWrapText");

	Params::RichTextBlock_SetAutoWrapText Parms{};

	Parms.InAutoTextWrap = InAutoTextWrap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetDefaultColorAndOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateColor                      InColorAndOpacity                                      (Parm, NativeAccessSpecifierPublic)

void URichTextBlock::SetDefaultColorAndOpacity(const struct FSlateColor& InColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultColorAndOpacity");

	Params::RichTextBlock_SetDefaultColorAndOpacity Parms{};

	Parms.InColorAndOpacity = std::move(InColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetDefaultFont
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateFontInfo                   InFontInfo                                             (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URichTextBlock::SetDefaultFont(const struct FSlateFontInfo& InFontInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultFont");

	Params::RichTextBlock_SetDefaultFont Parms{};

	Parms.InFontInfo = std::move(InFontInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetDefaultShadowColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InShadowColorAndOpacity                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URichTextBlock::SetDefaultShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultShadowColorAndOpacity");

	Params::RichTextBlock_SetDefaultShadowColorAndOpacity Parms{};

	Parms.InShadowColorAndOpacity = std::move(InShadowColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetDefaultShadowOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InShadowOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URichTextBlock::SetDefaultShadowOffset(const struct FVector2D& InShadowOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultShadowOffset");

	Params::RichTextBlock_SetDefaultShadowOffset Parms{};

	Parms.InShadowOffset = std::move(InShadowOffset);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetDefaultStrikeBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InStrikeBrush                                          (Parm, OutParm, NativeAccessSpecifierPublic)

void URichTextBlock::SetDefaultStrikeBrush(struct FSlateBrush* InStrikeBrush)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultStrikeBrush");

	Params::RichTextBlock_SetDefaultStrikeBrush Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InStrikeBrush != nullptr)
		*InStrikeBrush = std::move(Parms.InStrikeBrush);
}


// Function UMG.RichTextBlock.SetDefaultTextStyle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTextBlockStyle                  InDefaultTextStyle                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URichTextBlock::SetDefaultTextStyle(const struct FTextBlockStyle& InDefaultTextStyle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultTextStyle");

	Params::RichTextBlock_SetDefaultTextStyle Parms{};

	Parms.InDefaultTextStyle = std::move(InDefaultTextStyle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetMinDesiredWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinDesiredWidth                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URichTextBlock::SetMinDesiredWidth(float InMinDesiredWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinDesiredWidth");

	Params::RichTextBlock_SetMinDesiredWidth Parms{};

	Parms.InMinDesiredWidth = InMinDesiredWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetText
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URichTextBlock::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetText");

	Params::RichTextBlock_SetText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetTextStyleSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       NewTextStyleSet                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URichTextBlock::SetTextStyleSet(class UDataTable* NewTextStyleSet)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextStyleSet");

	Params::RichTextBlock_SetTextStyleSet Parms{};

	Parms.NewTextStyleSet = NewTextStyleSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.SetTextTransformPolicy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextTransformPolicy                    InTransformPolicy                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URichTextBlock::SetTextTransformPolicy(ETextTransformPolicy InTransformPolicy)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextTransformPolicy");

	Params::RichTextBlock_SetTextTransformPolicy Parms{};

	Parms.InTransformPolicy = InTransformPolicy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RichTextBlock.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText URichTextBlock::GetText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetText");

	Params::RichTextBlock_GetText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CheckedStateBinding.GetValue
// (Final, Native, Public, Const)
// Parameters:
// ECheckBoxState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECheckBoxState UCheckedStateBinding::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::CheckedStateBinding_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TileView.SetEntryHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTileView::SetEntryHeight(float NewHeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEntryHeight");

	Params::TileView_SetEntryHeight Parms{};

	Parms.NewHeight = NewHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TileView.SetEntryWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTileView::SetEntryWidth(float NewWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEntryWidth");

	Params::TileView_SetEntryWidth Parms{};

	Parms.NewWidth = NewWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.TileView.GetEntryHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTileView::GetEntryHeight() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEntryHeight");

	Params::TileView_GetEntryHeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TileView.GetEntryWidth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTileView::GetEntryWidth() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEntryWidth");

	Params::TileView_GetEntryWidth Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.InvalidationBox.InvalidateCache
// (Final, Native, Public, BlueprintCallable)

void UInvalidationBox::InvalidateCache()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InvalidateCache");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.InvalidationBox.SetCanCache
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CanCache                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvalidationBox::SetCanCache(bool CanCache)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCanCache");

	Params::InvalidationBox_SetCanCache Parms{};

	Parms.CanCache = CanCache;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.InvalidationBox.GetCanCache
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInvalidationBox::GetCanCache() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCanCache");

	Params::InvalidationBox_GetCanCache Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TreeView.CollapseAll
// (Final, Native, Public, BlueprintCallable)

void UTreeView::CollapseAll()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CollapseAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.TreeView.ExpandAll
// (Final, Native, Public, BlueprintCallable)

void UTreeView::ExpandAll()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ExpandAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.TreeView.SetItemExpansion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExpandItem                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTreeView::SetItemExpansion(class UObject* Item, bool bExpandItem)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetItemExpansion");

	Params::TreeView_SetItemExpansion Parms{};

	Parms.Item = Item;
	Parms.bExpandItem = bExpandItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Overlay.AddChildToOverlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOverlaySlot*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOverlaySlot* UOverlay::AddChildToOverlay(class UWidget* Content)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddChildToOverlay");

	Params::Overlay_AddChildToOverlay Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.GridSlot.SetColumn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InColumn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridSlot::SetColumn(int32 InColumn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColumn");

	Params::GridSlot_SetColumn Parms{};

	Parms.InColumn = InColumn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridSlot.SetColumnSpan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InColumnSpan                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridSlot::SetColumnSpan(int32 InColumnSpan)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColumnSpan");

	Params::GridSlot_SetColumnSpan Parms{};

	Parms.InColumnSpan = InColumnSpan;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::GridSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridSlot.SetLayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridSlot::SetLayer(int32 InLayer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLayer");

	Params::GridSlot_SetLayer Parms{};

	Parms.InLayer = InLayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridSlot.SetNudge
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InNudge                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridSlot::SetNudge(const struct FVector2D& InNudge)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNudge");

	Params::GridSlot_SetNudge Parms{};

	Parms.InNudge = std::move(InNudge);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGridSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::GridSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridSlot.SetRow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InRow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridSlot::SetRow(int32 InRow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRow");

	Params::GridSlot_SetRow Parms{};

	Parms.InRow = InRow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridSlot.SetRowSpan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InRowSpan                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridSlot::SetRowSpan(int32 InRowSpan)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRowSpan");

	Params::GridSlot_SetRowSpan Parms{};

	Parms.InRowSpan = InRowSpan;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::GridSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.RequestRedraw
// (Native, Public, BlueprintCallable)

void UWidgetComponent::RequestRedraw()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RequestRedraw");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.WidgetComponent.RequestRenderUpdate
// (Native, Public, BlueprintCallable)

void UWidgetComponent::RequestRenderUpdate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RequestRenderUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.WidgetComponent.SetBackgroundColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewBackgroundColor                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetBackgroundColor(const struct FLinearColor& NewBackgroundColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBackgroundColor");

	Params::WidgetComponent_SetBackgroundColor Parms{};

	Parms.NewBackgroundColor = std::move(NewBackgroundColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetCylinderArcAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InCylinderArcAngle                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetCylinderArcAngle(const float InCylinderArcAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCylinderArcAngle");

	Params::WidgetComponent_SetCylinderArcAngle Parms{};

	Parms.InCylinderArcAngle = InCylinderArcAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetDrawAtDesiredSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInDrawAtDesiredSize                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetDrawAtDesiredSize(bool bInDrawAtDesiredSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDrawAtDesiredSize");

	Params::WidgetComponent_SetDrawAtDesiredSize Parms{};

	Parms.bInDrawAtDesiredSize = bInDrawAtDesiredSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetDrawSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetDrawSize(const struct FVector2D& Size)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDrawSize");

	Params::WidgetComponent_SetDrawSize Parms{};

	Parms.Size = std::move(Size);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetGeometryMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWidgetGeometryMode                     InGeometryMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetGeometryMode(EWidgetGeometryMode InGeometryMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGeometryMode");

	Params::WidgetComponent_SetGeometryMode Parms{};

	Parms.InGeometryMode = InGeometryMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetManuallyRedraw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUseManualRedraw                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetManuallyRedraw(bool bUseManualRedraw)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetManuallyRedraw");

	Params::WidgetComponent_SetManuallyRedraw Parms{};

	Parms.bUseManualRedraw = bUseManualRedraw;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetOwnerPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULocalPlayer*                     LocalPlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetOwnerPlayer(class ULocalPlayer* LocalPlayer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOwnerPlayer");

	Params::WidgetComponent_SetOwnerPlayer Parms{};

	Parms.LocalPlayer = LocalPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetPivot
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InPivot                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetPivot(const struct FVector2D& InPivot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPivot");

	Params::WidgetComponent_SetPivot Parms{};

	Parms.InPivot = std::move(InPivot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetRedrawTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRedrawTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetRedrawTime(float InRedrawTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRedrawTime");

	Params::WidgetComponent_SetRedrawTime Parms{};

	Parms.InRedrawTime = InRedrawTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetTickMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickMode                               InTickMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetTickMode(ETickMode InTickMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTickMode");

	Params::WidgetComponent_SetTickMode Parms{};

	Parms.InTickMode = InTickMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetTickWhenOffscreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bWantTickWhenOffscreen                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetTickWhenOffscreen(const bool bWantTickWhenOffscreen)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTickWhenOffscreen");

	Params::WidgetComponent_SetTickWhenOffscreen Parms{};

	Parms.bWantTickWhenOffscreen = bWantTickWhenOffscreen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetTintColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewTintColorAndOpacity                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetTintColorAndOpacity(const struct FLinearColor& NewTintColorAndOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTintColorAndOpacity");

	Params::WidgetComponent_SetTintColorAndOpacity Parms{};

	Parms.NewTintColorAndOpacity = std::move(NewTintColorAndOpacity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetTwoSided
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bWantTwoSided                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetTwoSided(const bool bWantTwoSided)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTwoSided");

	Params::WidgetComponent_SetTwoSided Parms{};

	Parms.bWantTwoSided = bWantTwoSided;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetWidget
// (Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget_0                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetWidget(class UUserWidget* Widget_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWidget");

	Params::WidgetComponent_SetWidget Parms{};

	Parms.Widget_0 = Widget_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetWidgetSpace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWidgetSpace                            NewSpace                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetWidgetSpace(EWidgetSpace NewSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWidgetSpace");

	Params::WidgetComponent_SetWidgetSpace Parms{};

	Parms.NewSpace = NewSpace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetWindowFocusable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInWindowFocusable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetWindowFocusable(bool bInWindowFocusable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWindowFocusable");

	Params::WidgetComponent_SetWindowFocusable Parms{};

	Parms.bInWindowFocusable = bInWindowFocusable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.SetWindowVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWindowVisibility                       InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetComponent::SetWindowVisibility(EWindowVisibility InVisibility)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWindowVisibility");

	Params::WidgetComponent_SetWindowVisibility Parms{};

	Parms.InVisibility = InVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetComponent.GetCurrentDrawSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidgetComponent::GetCurrentDrawSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentDrawSize");

	Params::WidgetComponent_GetCurrentDrawSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetCylinderArcAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWidgetComponent::GetCylinderArcAngle() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCylinderArcAngle");

	Params::WidgetComponent_GetCylinderArcAngle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetDrawAtDesiredSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetComponent::GetDrawAtDesiredSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDrawAtDesiredSize");

	Params::WidgetComponent_GetDrawAtDesiredSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetDrawSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidgetComponent::GetDrawSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDrawSize");

	Params::WidgetComponent_GetDrawSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetGeometryMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWidgetGeometryMode                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWidgetGeometryMode UWidgetComponent::GetGeometryMode() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGeometryMode");

	Params::WidgetComponent_GetGeometryMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetManuallyRedraw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetComponent::GetManuallyRedraw() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetManuallyRedraw");

	Params::WidgetComponent_GetManuallyRedraw Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetMaterialInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UWidgetComponent::GetMaterialInstance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterialInstance");

	Params::WidgetComponent_GetMaterialInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetOwnerPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULocalPlayer*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayer* UWidgetComponent::GetOwnerPlayer() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwnerPlayer");

	Params::WidgetComponent_GetOwnerPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetPivot
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidgetComponent::GetPivot() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPivot");

	Params::WidgetComponent_GetPivot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetRedrawTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWidgetComponent::GetRedrawTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRedrawTime");

	Params::WidgetComponent_GetRedrawTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetRenderTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTextureRenderTarget2D*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* UWidgetComponent::GetRenderTarget() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRenderTarget");

	Params::WidgetComponent_GetRenderTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetTickWhenOffscreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetComponent::GetTickWhenOffscreen() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTickWhenOffscreen");

	Params::WidgetComponent_GetTickWhenOffscreen Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetTwoSided
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetComponent::GetTwoSided() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTwoSided");

	Params::WidgetComponent_GetTwoSided Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetUserWidgetObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UWidgetComponent::GetUserWidgetObject() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUserWidgetObject");

	Params::WidgetComponent_GetUserWidgetObject Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetWidget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UWidgetComponent::GetWidget() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWidget");

	Params::WidgetComponent_GetWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetWidgetSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWidgetSpace                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWidgetSpace UWidgetComponent::GetWidgetSpace() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWidgetSpace");

	Params::WidgetComponent_GetWidgetSpace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetWindowFocusable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetComponent::GetWindowFocusable() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWindowFocusable");

	Params::WidgetComponent_GetWindowFocusable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.GetWindowVisiblility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWindowVisibility                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWindowVisibility UWidgetComponent::GetWindowVisiblility() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWindowVisiblility");

	Params::WidgetComponent_GetWindowVisiblility Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetComponent.IsWidgetVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetComponent::IsWidgetVisible() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsWidgetVisible");

	Params::WidgetComponent_IsWidgetVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.BackgroundBlur.SetApplyAlphaToBlur
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInApplyAlphaToBlur                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundBlur::SetApplyAlphaToBlur(bool bInApplyAlphaToBlur)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetApplyAlphaToBlur");

	Params::BackgroundBlur_SetApplyAlphaToBlur Parms{};

	Parms.bInApplyAlphaToBlur = bInApplyAlphaToBlur;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlur.SetBlurRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InBlurRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundBlur::SetBlurRadius(int32 InBlurRadius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBlurRadius");

	Params::BackgroundBlur_SetBlurRadius Parms{};

	Parms.InBlurRadius = InBlurRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlur.SetBlurStrength
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InStrength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundBlur::SetBlurStrength(float InStrength)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBlurStrength");

	Params::BackgroundBlur_SetBlurStrength Parms{};

	Parms.InStrength = InStrength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlur.SetCornerRadius
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                         InCornerRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundBlur::SetCornerRadius(const struct FVector4& InCornerRadius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCornerRadius");

	Params::BackgroundBlur_SetCornerRadius Parms{};

	Parms.InCornerRadius = std::move(InCornerRadius);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlur.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundBlur::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::BackgroundBlur_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlur.SetLowQualityFallbackBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBackgroundBlur::SetLowQualityFallbackBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLowQualityFallbackBrush");

	Params::BackgroundBlur_SetLowQualityFallbackBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlur.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBackgroundBlur::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::BackgroundBlur_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlur.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundBlur::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::BackgroundBlur_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlurSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundBlurSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::BackgroundBlurSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlurSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBackgroundBlurSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::BackgroundBlurSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BackgroundBlurSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackgroundBlurSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::BackgroundBlurSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BoolBinding.GetValue
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBoolBinding::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::BoolBinding_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.BorderSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorderSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::BorderSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BorderSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBorderSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::BorderSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BorderSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBorderSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::BorderSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.BrushBinding.GetValue
// (Final, Native, Public, Const)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UBrushBinding::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::BrushBinding_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ButtonSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::ButtonSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ButtonSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UButtonSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::ButtonSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ButtonSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UButtonSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::ButtonSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetAlignment
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InAlignment                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetAlignment(const struct FVector2D& InAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAlignment");

	Params::CanvasPanelSlot_SetAlignment Parms{};

	Parms.InAlignment = std::move(InAlignment);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetAnchors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FAnchors                         InAnchors                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetAnchors(const struct FAnchors& InAnchors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnchors");

	Params::CanvasPanelSlot_SetAnchors Parms{};

	Parms.InAnchors = std::move(InAnchors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetAutoSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbAutoSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetAutoSize(bool InbAutoSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAutoSize");

	Params::CanvasPanelSlot_SetAutoSize Parms{};

	Parms.InbAutoSize = InbAutoSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetLayout
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnchorData                      InLayoutData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetLayout(const struct FAnchorData& InLayoutData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLayout");

	Params::CanvasPanelSlot_SetLayout Parms{};

	Parms.InLayoutData = std::move(InLayoutData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetMaximum
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector2D                        InMaximumAnchors                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetMaximum(const struct FVector2D& InMaximumAnchors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaximum");

	Params::CanvasPanelSlot_SetMaximum Parms{};

	Parms.InMaximumAnchors = std::move(InMaximumAnchors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetMinimum
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector2D                        InMinimumAnchors                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetMinimum(const struct FVector2D& InMinimumAnchors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinimum");

	Params::CanvasPanelSlot_SetMinimum Parms{};

	Parms.InMinimumAnchors = std::move(InMinimumAnchors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetOffsets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetOffsets(const struct FMargin& InOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOffsets");

	Params::CanvasPanelSlot_SetOffsets Parms{};

	Parms.InOffset = std::move(InOffset);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetPosition(const struct FVector2D& InPosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPosition");

	Params::CanvasPanelSlot_SetPosition Parms{};

	Parms.InPosition = std::move(InPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetSize(const struct FVector2D& InSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSize");

	Params::CanvasPanelSlot_SetSize Parms{};

	Parms.InSize = std::move(InSize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.SetZOrder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InZOrder                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasPanelSlot::SetZOrder(int32 InZOrder)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetZOrder");

	Params::CanvasPanelSlot_SetZOrder Parms{};

	Parms.InZOrder = InZOrder;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CanvasPanelSlot.GetAlignment
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCanvasPanelSlot::GetAlignment() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAlignment");

	Params::CanvasPanelSlot_GetAlignment Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CanvasPanelSlot.GetAnchors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAnchors                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAnchors UCanvasPanelSlot::GetAnchors() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnchors");

	Params::CanvasPanelSlot_GetAnchors Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CanvasPanelSlot.GetAutoSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCanvasPanelSlot::GetAutoSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAutoSize");

	Params::CanvasPanelSlot_GetAutoSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CanvasPanelSlot.GetLayout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAnchorData                      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAnchorData UCanvasPanelSlot::GetLayout() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLayout");

	Params::CanvasPanelSlot_GetLayout Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CanvasPanelSlot.GetOffsets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FMargin                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMargin UCanvasPanelSlot::GetOffsets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOffsets");

	Params::CanvasPanelSlot_GetOffsets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CanvasPanelSlot.GetPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCanvasPanelSlot::GetPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPosition");

	Params::CanvasPanelSlot_GetPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CanvasPanelSlot.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCanvasPanelSlot::GetSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSize");

	Params::CanvasPanelSlot_GetSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CanvasPanelSlot.GetZOrder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCanvasPanelSlot::GetZOrder() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetZOrder");

	Params::CanvasPanelSlot_GetZOrder Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CheckBox.SetCheckedState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECheckBoxState                          InCheckedState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckBox::SetCheckedState(ECheckBoxState InCheckedState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCheckedState");

	Params::CheckBox_SetCheckedState Parms{};

	Parms.InCheckedState = InCheckedState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CheckBox.SetClickMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EButtonClickMethod                      InClickMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckBox::SetClickMethod(EButtonClickMethod InClickMethod)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetClickMethod");

	Params::CheckBox_SetClickMethod Parms{};

	Parms.InClickMethod = InClickMethod;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CheckBox.SetIsChecked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsChecked                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckBox::SetIsChecked(bool InIsChecked)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsChecked");

	Params::CheckBox_SetIsChecked Parms{};

	Parms.InIsChecked = InIsChecked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CheckBox.SetPressMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EButtonPressMethod                      InPressMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckBox::SetPressMethod(EButtonPressMethod InPressMethod)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPressMethod");

	Params::CheckBox_SetPressMethod Parms{};

	Parms.InPressMethod = InPressMethod;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CheckBox.SetTouchMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EButtonTouchMethod                      InTouchMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckBox::SetTouchMethod(EButtonTouchMethod InTouchMethod)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTouchMethod");

	Params::CheckBox_SetTouchMethod Parms{};

	Parms.InTouchMethod = InTouchMethod;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.CheckBox.GetCheckedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECheckBoxState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECheckBoxState UCheckBox::GetCheckedState() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCheckedState");

	Params::CheckBox_GetCheckedState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CheckBox.IsChecked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCheckBox::IsChecked() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsChecked");

	Params::CheckBox_IsChecked Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.CheckBox.IsPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCheckBox::IsPressed() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPressed");

	Params::CheckBox_IsPressed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxKey.AddOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxKey::AddOption(class FName Option)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddOption");

	Params::ComboBoxKey_AddOption Parms{};

	Parms.Option = Option;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ComboBoxKey.ClearOptions
// (Final, Native, Public, BlueprintCallable)

void UComboBoxKey::ClearOptions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ComboBoxKey.ClearSelection
// (Final, Native, Public, BlueprintCallable)

void UComboBoxKey::ClearSelection()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearSelection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ComboBoxKey.RemoveOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UComboBoxKey::RemoveOption(class FName Option)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveOption");

	Params::ComboBoxKey_RemoveOption Parms{};

	Parms.Option = Option;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxKey.SetSelectedOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxKey::SetSelectedOption(class FName Option)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSelectedOption");

	Params::ComboBoxKey_SetSelectedOption Parms{};

	Parms.Option = Option;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ComboBoxKey.GetSelectedOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UComboBoxKey::GetSelectedOption() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSelectedOption");

	Params::ComboBoxKey_GetSelectedOption Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxKey.IsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UComboBoxKey::IsOpen() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOpen");

	Params::ComboBoxKey_IsOpen Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxString.AddOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxString::AddOption(const class FString& Option)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddOption");

	Params::ComboBoxString_AddOption Parms{};

	Parms.Option = std::move(Option);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ComboBoxString.ClearOptions
// (Final, Native, Public, BlueprintCallable)

void UComboBoxString::ClearOptions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ComboBoxString.ClearSelection
// (Final, Native, Public, BlueprintCallable)

void UComboBoxString::ClearSelection()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearSelection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ComboBoxString.RefreshOptions
// (Final, Native, Public, BlueprintCallable)

void UComboBoxString::RefreshOptions()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RefreshOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.ComboBoxString.RemoveOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UComboBoxString::RemoveOption(const class FString& Option)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveOption");

	Params::ComboBoxString_RemoveOption Parms{};

	Parms.Option = std::move(Option);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxString.SetSelectedIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxString::SetSelectedIndex(const int32 Index_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSelectedIndex");

	Params::ComboBoxString_SetSelectedIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ComboBoxString.SetSelectedOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComboBoxString::SetSelectedOption(const class FString& Option)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSelectedOption");

	Params::ComboBoxString_SetSelectedOption Parms{};

	Parms.Option = std::move(Option);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ComboBoxString.FindOptionIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Option                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UComboBoxString::FindOptionIndex(const class FString& Option) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindOptionIndex");

	Params::ComboBoxString_FindOptionIndex Parms{};

	Parms.Option = std::move(Option);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxString.GetOptionAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UComboBoxString::GetOptionAtIndex(int32 Index_0) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOptionAtIndex");

	Params::ComboBoxString_GetOptionAtIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxString.GetOptionCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UComboBoxString::GetOptionCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOptionCount");

	Params::ComboBoxString_GetOptionCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxString.GetSelectedIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UComboBoxString::GetSelectedIndex() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSelectedIndex");

	Params::ComboBoxString_GetSelectedIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxString.GetSelectedOption
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UComboBoxString::GetSelectedOption() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSelectedOption");

	Params::ComboBoxString_GetSelectedOption Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ComboBoxString.IsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UComboBoxString::IsOpen() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOpen");

	Params::ComboBoxString_IsOpen Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.DynamicEntryBox.BP_CreateEntry
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDynamicEntryBox::BP_CreateEntry()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_CreateEntry");

	Params::DynamicEntryBox_BP_CreateEntry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.DynamicEntryBox.BP_CreateEntryOfClass
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSubclassOf<class UUserWidget>          EntryClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UDynamicEntryBox::BP_CreateEntryOfClass(TSubclassOf<class UUserWidget> EntryClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_CreateEntryOfClass");

	Params::DynamicEntryBox_BP_CreateEntryOfClass Parms{};

	Parms.EntryClass = EntryClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.DynamicEntryBox.RemoveEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEntryBox::RemoveEntry(class UUserWidget* EntryWidget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveEntry");

	Params::DynamicEntryBox_RemoveEntry Parms{};

	Parms.EntryWidget = EntryWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.DynamicEntryBox.Reset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDeleteWidgets                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEntryBox::Reset(bool bDeleteWidgets)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Reset");

	Params::DynamicEntryBox_Reset Parms{};

	Parms.bDeleteWidgets = bDeleteWidgets;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableText.SetHintText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InHintText                                             (Parm, NativeAccessSpecifierPublic)

void UEditableText::SetHintText(const class FText& InHintText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHintText");

	Params::EditableText_SetHintText Parms{};

	Parms.InHintText = std::move(InHintText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableText.SetIsPassword
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbIsPassword                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableText::SetIsPassword(bool InbIsPassword)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsPassword");

	Params::EditableText_SetIsPassword Parms{};

	Parms.InbIsPassword = InbIsPassword;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableText.SetIsReadOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbIsReadyOnly                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableText::SetIsReadOnly(bool InbIsReadyOnly)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsReadOnly");

	Params::EditableText_SetIsReadOnly Parms{};

	Parms.InbIsReadyOnly = InbIsReadyOnly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableText.SetJustification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextJustify                            InJustification                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableText::SetJustification(ETextJustify InJustification)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetJustification");

	Params::EditableText_SetJustification Parms{};

	Parms.InJustification = InJustification;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableText.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UEditableText::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetText");

	Params::EditableText_SetText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableText.SetTextOverflowPolicy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextOverflowPolicy                     InOverflowPolicy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableText::SetTextOverflowPolicy(ETextOverflowPolicy InOverflowPolicy)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextOverflowPolicy");

	Params::EditableText_SetTextOverflowPolicy Parms{};

	Parms.InOverflowPolicy = InOverflowPolicy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableText.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UEditableText::GetText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetText");

	Params::EditableText_GetText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.EditableTextBox.ClearError
// (Final, Native, Public, BlueprintCallable)

void UEditableTextBox::ClearError()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearError");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.EditableTextBox.SetError
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InError                                                (Parm, NativeAccessSpecifierPublic)

void UEditableTextBox::SetError(const class FText& InError)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetError");

	Params::EditableTextBox_SetError Parms{};

	Parms.InError = std::move(InError);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableTextBox.SetForegroundColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableTextBox::SetForegroundColor(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForegroundColor");

	Params::EditableTextBox_SetForegroundColor Parms{};

	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableTextBox.SetHintText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UEditableTextBox::SetHintText(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHintText");

	Params::EditableTextBox_SetHintText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableTextBox.SetIsPassword
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsPassword                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableTextBox::SetIsPassword(bool bIsPassword)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsPassword");

	Params::EditableTextBox_SetIsPassword Parms{};

	Parms.bIsPassword = bIsPassword;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableTextBox.SetIsReadOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bReadOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableTextBox::SetIsReadOnly(bool bReadOnly)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsReadOnly");

	Params::EditableTextBox_SetIsReadOnly Parms{};

	Parms.bReadOnly = bReadOnly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableTextBox.SetJustification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextJustify                            InJustification                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableTextBox::SetJustification(ETextJustify InJustification)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetJustification");

	Params::EditableTextBox_SetJustification Parms{};

	Parms.InJustification = InJustification;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableTextBox.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UEditableTextBox::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetText");

	Params::EditableTextBox_SetText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableTextBox.SetTextOverflowPolicy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETextOverflowPolicy                     InOverflowPolicy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEditableTextBox::SetTextOverflowPolicy(ETextOverflowPolicy InOverflowPolicy)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextOverflowPolicy");

	Params::EditableTextBox_SetTextOverflowPolicy Parms{};

	Parms.InOverflowPolicy = InOverflowPolicy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.EditableTextBox.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UEditableTextBox::GetText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetText");

	Params::EditableTextBox_GetText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.EditableTextBox.HasError
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEditableTextBox::HasError() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasError");

	Params::EditableTextBox_HasError Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.FloatBinding.GetValue
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFloatBinding::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::FloatBinding_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.GridPanel.AddChildToGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InRow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InColumn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridSlot*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGridSlot* UGridPanel::AddChildToGrid(class UWidget* Content, int32 InRow, int32 InColumn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddChildToGrid");

	Params::GridPanel_AddChildToGrid Parms{};

	Parms.Content = Content;
	Parms.InRow = InRow;
	Parms.InColumn = InColumn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.GridPanel.SetColumnFill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ColumnIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Coefficient                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridPanel::SetColumnFill(int32 ColumnIndex, float Coefficient)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColumnFill");

	Params::GridPanel_SetColumnFill Parms{};

	Parms.ColumnIndex = ColumnIndex;
	Parms.Coefficient = Coefficient;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.GridPanel.SetRowFill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ColumnIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Coefficient                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridPanel::SetRowFill(int32 ColumnIndex, float Coefficient)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRowFill");

	Params::GridPanel_SetRowFill Parms{};

	Parms.ColumnIndex = ColumnIndex;
	Parms.Coefficient = Coefficient;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.HorizontalBox.AddChildToHorizontalBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHorizontalBoxSlot*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHorizontalBoxSlot* UHorizontalBox::AddChildToHorizontalBox(class UWidget* Content)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddChildToHorizontalBox");

	Params::HorizontalBox_AddChildToHorizontalBox Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserListEntryLibrary.GetOwningListView
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class IUserListEntry>  UserListEntry                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UListViewBase*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UListViewBase* UUserListEntryLibrary::GetOwningListView(TScriptInterface<class IUserListEntry> UserListEntry)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetOwningListView");

	Params::UserListEntryLibrary_GetOwningListView Parms{};

	Parms.UserListEntry = UserListEntry;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserListEntryLibrary.IsListItemExpanded
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class IUserListEntry>  UserListEntry                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserListEntryLibrary::IsListItemExpanded(TScriptInterface<class IUserListEntry> UserListEntry)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsListItemExpanded");

	Params::UserListEntryLibrary_IsListItemExpanded Parms{};

	Parms.UserListEntry = UserListEntry;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserListEntryLibrary.IsListItemSelected
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class IUserListEntry>  UserListEntry                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserListEntryLibrary::IsListItemSelected(TScriptInterface<class IUserListEntry> UserListEntry)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsListItemSelected");

	Params::UserListEntryLibrary_IsListItemSelected Parms{};

	Parms.UserListEntry = UserListEntry;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UserObjectListEntryLibrary.GetListItemObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class IUserObjectListEntry>UserObjectListEntry                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UUserObjectListEntryLibrary::GetListItemObject(TScriptInterface<class IUserObjectListEntry> UserObjectListEntry)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetListItemObject");

	Params::UserObjectListEntryLibrary_GetListItemObject Parms{};

	Parms.UserObjectListEntry = UserObjectListEntry;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.MenuAnchor.Close
// (Final, Native, Public, BlueprintCallable)

void UMenuAnchor::Close()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Close");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.MenuAnchor.FitInWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFit                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuAnchor::FitInWindow(bool bFit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FitInWindow");

	Params::MenuAnchor_FitInWindow Parms{};

	Parms.bFit = bFit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MenuAnchor.Open
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFocusMenu                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuAnchor::Open(bool bFocusMenu)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Open");

	Params::MenuAnchor_Open Parms{};

	Parms.bFocusMenu = bFocusMenu;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MenuAnchor.SetPlacement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMenuPlacement                          InPlacement                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuAnchor::SetPlacement(EMenuPlacement InPlacement)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlacement");

	Params::MenuAnchor_SetPlacement Parms{};

	Parms.InPlacement = InPlacement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MenuAnchor.ToggleOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFocusOnOpen                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuAnchor::ToggleOpen(bool bFocusOnOpen)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleOpen");

	Params::MenuAnchor_ToggleOpen Parms{};

	Parms.bFocusOnOpen = bFocusOnOpen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MenuAnchor.GetMenuPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UMenuAnchor::GetMenuPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMenuPosition");

	Params::MenuAnchor_GetMenuPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.MenuAnchor.HasOpenSubMenus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuAnchor::HasOpenSubMenus() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasOpenSubMenus");

	Params::MenuAnchor_HasOpenSubMenus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.MenuAnchor.IsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuAnchor::IsOpen() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOpen");

	Params::MenuAnchor_IsOpen Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.MenuAnchor.ShouldOpenDueToClick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuAnchor::ShouldOpenDueToClick() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShouldOpenDueToClick");

	Params::MenuAnchor_ShouldOpenDueToClick Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.MouseCursorBinding.GetValue
// (Final, Native, Public, Const)
// Parameters:
// EMouseCursor                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMouseCursor UMouseCursorBinding::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::MouseCursorBinding_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.MultiLineEditableText.SetHintText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InHintText                                             (Parm, NativeAccessSpecifierPublic)

void UMultiLineEditableText::SetHintText(const class FText& InHintText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHintText");

	Params::MultiLineEditableText_SetHintText Parms{};

	Parms.InHintText = std::move(InHintText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableText.SetIsReadOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bReadOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMultiLineEditableText::SetIsReadOnly(bool bReadOnly)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsReadOnly");

	Params::MultiLineEditableText_SetIsReadOnly Parms{};

	Parms.bReadOnly = bReadOnly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableText.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UMultiLineEditableText::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetText");

	Params::MultiLineEditableText_SetText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableText.SetWidgetStyle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTextBlockStyle                  InWidgetStyle                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMultiLineEditableText::SetWidgetStyle(const struct FTextBlockStyle& InWidgetStyle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWidgetStyle");

	Params::MultiLineEditableText_SetWidgetStyle Parms{};

	Parms.InWidgetStyle = std::move(InWidgetStyle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.MultiLineEditableText.GetHintText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMultiLineEditableText::GetHintText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHintText");

	Params::MultiLineEditableText_GetHintText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.MultiLineEditableText.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UMultiLineEditableText::GetText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetText");

	Params::MultiLineEditableText_GetText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.ProgressBar.SetFillColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressBar::SetFillColorAndOpacity(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFillColorAndOpacity");

	Params::ProgressBar_SetFillColorAndOpacity Parms{};

	Parms.InColor = std::move(InColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ProgressBar.SetIsMarquee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbIsMarquee                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressBar::SetIsMarquee(bool InbIsMarquee)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsMarquee");

	Params::ProgressBar_SetIsMarquee Parms{};

	Parms.InbIsMarquee = InbIsMarquee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ProgressBar.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressBar::SetPercent(float InPercent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPercent");

	Params::ProgressBar_SetPercent Parms{};

	Parms.InPercent = InPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RetainerBox.RequestRender
// (Final, Native, Public, BlueprintCallable)

void URetainerBox::RequestRender()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RequestRender");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.RetainerBox.SetEffectMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               EffectMaterial_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URetainerBox::SetEffectMaterial(class UMaterialInterface* EffectMaterial_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEffectMaterial");

	Params::RetainerBox_SetEffectMaterial Parms{};

	Parms.EffectMaterial_0 = EffectMaterial_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RetainerBox.SetRenderingPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RenderPhase                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalPhases                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URetainerBox::SetRenderingPhase(int32 RenderPhase, int32 TotalPhases)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderingPhase");

	Params::RetainerBox_SetRenderingPhase Parms{};

	Parms.RenderPhase = RenderPhase;
	Parms.TotalPhases = TotalPhases;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RetainerBox.SetRetainRendering
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInRetainRendering                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URetainerBox::SetRetainRendering(bool bInRetainRendering)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRetainRendering");

	Params::RetainerBox_SetRetainRendering Parms{};

	Parms.bInRetainRendering = bInRetainRendering;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RetainerBox.SetTextureParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TextureParameter_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URetainerBox::SetTextureParameter(class FName TextureParameter_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextureParameter");

	Params::RetainerBox_SetTextureParameter Parms{};

	Parms.TextureParameter_0 = TextureParameter_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.RetainerBox.GetEffectMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* URetainerBox::GetEffectMaterial() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEffectMaterial");

	Params::RetainerBox_GetEffectMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SafeZone.SetSidesToPad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPadLeft                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPadRight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPadTop                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPadBottom                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USafeZone::SetSidesToPad(bool InPadLeft, bool InPadRight, bool InPadTop, bool InPadBottom)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSidesToPad");

	Params::SafeZone_SetSidesToPad Parms{};

	Parms.InPadLeft = InPadLeft;
	Parms.InPadRight = InPadRight;
	Parms.InPadTop = InPadTop;
	Parms.InPadBottom = InPadBottom;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScaleBox.SetIgnoreInheritedScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIgnoreInheritedScale                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScaleBox::SetIgnoreInheritedScale(bool bInIgnoreInheritedScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIgnoreInheritedScale");

	Params::ScaleBox_SetIgnoreInheritedScale Parms{};

	Parms.bInIgnoreInheritedScale = bInIgnoreInheritedScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScaleBox.SetStretch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStretch                                InStretch                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScaleBox::SetStretch(EStretch InStretch)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStretch");

	Params::ScaleBox_SetStretch Parms{};

	Parms.InStretch = InStretch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScaleBox.SetStretchDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EStretchDirection                       InStretchDirection                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScaleBox::SetStretchDirection(EStretchDirection InStretchDirection)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStretchDirection");

	Params::ScaleBox_SetStretchDirection Parms{};

	Parms.InStretchDirection = InStretchDirection;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScaleBox.SetUserSpecifiedScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InUserSpecifiedScale                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScaleBox::SetUserSpecifiedScale(float InUserSpecifiedScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUserSpecifiedScale");

	Params::ScaleBox_SetUserSpecifiedScale Parms{};

	Parms.InUserSpecifiedScale = InUserSpecifiedScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScaleBoxSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScaleBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::ScaleBoxSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScaleBoxSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UScaleBoxSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::ScaleBoxSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScaleBoxSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScaleBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::ScaleBoxSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBar.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOffsetFraction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InThumbSizeFraction                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBar::SetState(float InOffsetFraction, float InThumbSizeFraction)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetState");

	Params::ScrollBar_SetState Parms{};

	Parms.InOffsetFraction = InOffsetFraction;
	Parms.InThumbSizeFraction = InThumbSizeFraction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBoxSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::ScrollBoxSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBoxSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UScrollBoxSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::ScrollBoxSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.ScrollBoxSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScrollBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::ScrollBoxSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBoxSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::SizeBoxSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBoxSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USizeBoxSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::SizeBoxSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SizeBoxSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USizeBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::SizeBoxSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SlateBlueprintLibrary.AbsoluteToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        AbsoluteCoordinate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USlateBlueprintLibrary::AbsoluteToLocal(const struct FGeometry& Geometry, const struct FVector2D& AbsoluteCoordinate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AbsoluteToLocal");

	Params::SlateBlueprintLibrary_AbsoluteToLocal Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.AbsoluteCoordinate = std::move(AbsoluteCoordinate);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.AbsoluteToViewport
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        AbsoluteDesktopCoordinate                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        PixelPosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ViewportPosition                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlateBlueprintLibrary::AbsoluteToViewport(class UObject* WorldContextObject, const struct FVector2D& AbsoluteDesktopCoordinate, struct FVector2D* PixelPosition, struct FVector2D* ViewportPosition)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AbsoluteToViewport");

	Params::SlateBlueprintLibrary_AbsoluteToViewport Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AbsoluteDesktopCoordinate = std::move(AbsoluteDesktopCoordinate);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PixelPosition != nullptr)
		*PixelPosition = std::move(Parms.PixelPosition);

	if (ViewportPosition != nullptr)
		*ViewportPosition = std::move(Parms.ViewportPosition);
}


// Function UMG.SlateBlueprintLibrary.EqualEqual_SlateBrush
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateBrush                      A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSlateBrush                      B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USlateBlueprintLibrary::EqualEqual_SlateBrush(const struct FSlateBrush& A, const struct FSlateBrush& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_SlateBrush");

	Params::SlateBlueprintLibrary_EqualEqual_SlateBrush Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.GetAbsoluteSize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USlateBlueprintLibrary::GetAbsoluteSize(const struct FGeometry& Geometry)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAbsoluteSize");

	Params::SlateBlueprintLibrary_GetAbsoluteSize Parms{};

	Parms.Geometry = std::move(Geometry);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.GetLocalSize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USlateBlueprintLibrary::GetLocalSize(const struct FGeometry& Geometry)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLocalSize");

	Params::SlateBlueprintLibrary_GetLocalSize Parms{};

	Parms.Geometry = std::move(Geometry);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.GetLocalTopLeft
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USlateBlueprintLibrary::GetLocalTopLeft(const struct FGeometry& Geometry)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLocalTopLeft");

	Params::SlateBlueprintLibrary_GetLocalTopLeft Parms{};

	Parms.Geometry = std::move(Geometry);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.IsUnderLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        AbsoluteCoordinate                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USlateBlueprintLibrary::IsUnderLocation(const struct FGeometry& Geometry, const struct FVector2D& AbsoluteCoordinate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsUnderLocation");

	Params::SlateBlueprintLibrary_IsUnderLocation Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.AbsoluteCoordinate = std::move(AbsoluteCoordinate);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.LocalToAbsolute
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        LocalCoordinate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USlateBlueprintLibrary::LocalToAbsolute(const struct FGeometry& Geometry, const struct FVector2D& LocalCoordinate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LocalToAbsolute");

	Params::SlateBlueprintLibrary_LocalToAbsolute Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.LocalCoordinate = std::move(LocalCoordinate);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.LocalToViewport
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        LocalCoordinate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        PixelPosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ViewportPosition                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlateBlueprintLibrary::LocalToViewport(class UObject* WorldContextObject, const struct FGeometry& Geometry, const struct FVector2D& LocalCoordinate, struct FVector2D* PixelPosition, struct FVector2D* ViewportPosition)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LocalToViewport");

	Params::SlateBlueprintLibrary_LocalToViewport Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Geometry = std::move(Geometry);
	Parms.LocalCoordinate = std::move(LocalCoordinate);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PixelPosition != nullptr)
		*PixelPosition = std::move(Parms.PixelPosition);

	if (ViewportPosition != nullptr)
		*ViewportPosition = std::move(Parms.ViewportPosition);
}


// Function UMG.SlateBlueprintLibrary.ScreenToViewport
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ViewportPosition                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlateBlueprintLibrary::ScreenToViewport(class UObject* WorldContextObject, const struct FVector2D& ScreenPosition, struct FVector2D* ViewportPosition)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScreenToViewport");

	Params::SlateBlueprintLibrary_ScreenToViewport Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ScreenPosition = std::move(ScreenPosition);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (ViewportPosition != nullptr)
		*ViewportPosition = std::move(Parms.ViewportPosition);
}


// Function UMG.SlateBlueprintLibrary.ScreenToWidgetAbsolute
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        AbsoluteCoordinate                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeWindowPosition                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlateBlueprintLibrary::ScreenToWidgetAbsolute(class UObject* WorldContextObject, const struct FVector2D& ScreenPosition, struct FVector2D* AbsoluteCoordinate, bool bIncludeWindowPosition)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScreenToWidgetAbsolute");

	Params::SlateBlueprintLibrary_ScreenToWidgetAbsolute Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.bIncludeWindowPosition = bIncludeWindowPosition;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (AbsoluteCoordinate != nullptr)
		*AbsoluteCoordinate = std::move(Parms.AbsoluteCoordinate);
}


// Function UMG.SlateBlueprintLibrary.ScreenToWidgetLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LocalCoordinate                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeWindowPosition                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlateBlueprintLibrary::ScreenToWidgetLocal(class UObject* WorldContextObject, const struct FGeometry& Geometry, const struct FVector2D& ScreenPosition, struct FVector2D* LocalCoordinate, bool bIncludeWindowPosition)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScreenToWidgetLocal");

	Params::SlateBlueprintLibrary_ScreenToWidgetLocal Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Geometry = std::move(Geometry);
	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.bIncludeWindowPosition = bIncludeWindowPosition;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LocalCoordinate != nullptr)
		*LocalCoordinate = std::move(Parms.LocalCoordinate);
}


// Function UMG.SlateBlueprintLibrary.TransformScalarAbsoluteToLocal
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   AbsoluteScalar                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USlateBlueprintLibrary::TransformScalarAbsoluteToLocal(const struct FGeometry& Geometry, float AbsoluteScalar)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformScalarAbsoluteToLocal");

	Params::SlateBlueprintLibrary_TransformScalarAbsoluteToLocal Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.AbsoluteScalar = AbsoluteScalar;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.TransformScalarLocalToAbsolute
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   LocalScalar                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USlateBlueprintLibrary::TransformScalarLocalToAbsolute(const struct FGeometry& Geometry, float LocalScalar)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformScalarLocalToAbsolute");

	Params::SlateBlueprintLibrary_TransformScalarLocalToAbsolute Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.LocalScalar = LocalScalar;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.TransformVectorAbsoluteToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        AbsoluteVector                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USlateBlueprintLibrary::TransformVectorAbsoluteToLocal(const struct FGeometry& Geometry, const struct FVector2D& AbsoluteVector)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformVectorAbsoluteToLocal");

	Params::SlateBlueprintLibrary_TransformVectorAbsoluteToLocal Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.AbsoluteVector = std::move(AbsoluteVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SlateBlueprintLibrary.TransformVectorLocalToAbsolute
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        LocalVector                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USlateBlueprintLibrary::TransformVectorLocalToAbsolute(const struct FGeometry& Geometry, const struct FVector2D& LocalVector)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformVectorLocalToAbsolute");

	Params::SlateBlueprintLibrary_TransformVectorLocalToAbsolute Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.LocalVector = std::move(LocalVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Spacer.SetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpacer::SetSize(const struct FVector2D& InSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSize");

	Params::Spacer_SetSize Parms{};

	Parms.InSize = std::move(InSize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.ClearMaxSliderValue
// (Final, Native, Public, BlueprintCallable)

void USpinBox::ClearMaxSliderValue()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMaxSliderValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SpinBox.ClearMaxValue
// (Final, Native, Public, BlueprintCallable)

void USpinBox::ClearMaxValue()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMaxValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SpinBox.ClearMinSliderValue
// (Final, Native, Public, BlueprintCallable)

void USpinBox::ClearMinSliderValue()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMinSliderValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SpinBox.ClearMinValue
// (Final, Native, Public, BlueprintCallable)

void USpinBox::ClearMinValue()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMinValue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UMG.SpinBox.SetAlwaysUsesDeltaSnap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetAlwaysUsesDeltaSnap(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAlwaysUsesDeltaSnap");

	Params::SpinBox_SetAlwaysUsesDeltaSnap Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetDelta
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetDelta(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDelta");

	Params::SpinBox_SetDelta Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetForegroundColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateColor                      InForegroundColor                                      (Parm, NativeAccessSpecifierPublic)

void USpinBox::SetForegroundColor(const struct FSlateColor& InForegroundColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForegroundColor");

	Params::SpinBox_SetForegroundColor Parms{};

	Parms.InForegroundColor = std::move(InForegroundColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetMaxFractionalDigits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetMaxFractionalDigits(int32 NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaxFractionalDigits");

	Params::SpinBox_SetMaxFractionalDigits Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetMaxSliderValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetMaxSliderValue(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaxSliderValue");

	Params::SpinBox_SetMaxSliderValue Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetMaxValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetMaxValue(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaxValue");

	Params::SpinBox_SetMaxValue Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetMinFractionalDigits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetMinFractionalDigits(int32 NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinFractionalDigits");

	Params::SpinBox_SetMinFractionalDigits Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetMinSliderValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetMinSliderValue(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinSliderValue");

	Params::SpinBox_SetMinSliderValue Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetMinValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetMinValue(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinValue");

	Params::SpinBox_SetMinValue Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.SetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpinBox::SetValue(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetValue");

	Params::SpinBox_SetValue Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.SpinBox.GetAlwaysUsesDeltaSnap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpinBox::GetAlwaysUsesDeltaSnap() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAlwaysUsesDeltaSnap");

	Params::SpinBox_GetAlwaysUsesDeltaSnap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SpinBox.GetDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USpinBox::GetDelta() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDelta");

	Params::SpinBox_GetDelta Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SpinBox.GetMaxFractionalDigits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpinBox::GetMaxFractionalDigits() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxFractionalDigits");

	Params::SpinBox_GetMaxFractionalDigits Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SpinBox.GetMaxSliderValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USpinBox::GetMaxSliderValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxSliderValue");

	Params::SpinBox_GetMaxSliderValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SpinBox.GetMaxValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USpinBox::GetMaxValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxValue");

	Params::SpinBox_GetMaxValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SpinBox.GetMinFractionalDigits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USpinBox::GetMinFractionalDigits() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinFractionalDigits");

	Params::SpinBox_GetMinFractionalDigits Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SpinBox.GetMinSliderValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USpinBox::GetMinSliderValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinSliderValue");

	Params::SpinBox_GetMinSliderValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SpinBox.GetMinValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USpinBox::GetMinValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinValue");

	Params::SpinBox_GetMinValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.SpinBox.GetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USpinBox::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::SpinBox_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TextBinding.GetStringValue
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTextBinding::GetStringValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStringValue");

	Params::TextBinding_GetStringValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.TextBinding.GetTextValue
// (Final, Native, Public, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTextBinding::GetTextValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTextValue");

	Params::TextBinding_GetTextValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Throbber.SetAnimateHorizontally
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAnimateHorizontally                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThrobber::SetAnimateHorizontally(bool bInAnimateHorizontally)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimateHorizontally");

	Params::Throbber_SetAnimateHorizontally Parms{};

	Parms.bInAnimateHorizontally = bInAnimateHorizontally;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Throbber.SetAnimateOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAnimateOpacity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThrobber::SetAnimateOpacity(bool bInAnimateOpacity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimateOpacity");

	Params::Throbber_SetAnimateOpacity Parms{};

	Parms.bInAnimateOpacity = bInAnimateOpacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Throbber.SetAnimateVertically
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAnimateVertically                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThrobber::SetAnimateVertically(bool bInAnimateVertically)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimateVertically");

	Params::Throbber_SetAnimateVertically Parms{};

	Parms.bInAnimateVertically = bInAnimateVertically;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Throbber.SetNumberOfPieces
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNumberOfPieces                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThrobber::SetNumberOfPieces(int32 InNumberOfPieces)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNumberOfPieces");

	Params::Throbber_SetNumberOfPieces Parms{};

	Parms.InNumberOfPieces = InNumberOfPieces;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UMGSequencePlayer.SetUserTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InUserTag                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSequencePlayer::SetUserTag(class FName InUserTag)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUserTag");

	Params::UMGSequencePlayer_SetUserTag Parms{};

	Parms.InUserTag = InUserTag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UMGSequencePlayer.GetUserTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UUMGSequencePlayer::GetUserTag() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUserTag");

	Params::UMGSequencePlayer_GetUserTag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UniformGridPanel.AddChildToUniformGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InRow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InColumn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUniformGridSlot*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUniformGridSlot* UUniformGridPanel::AddChildToUniformGrid(class UWidget* Content, int32 InRow, int32 InColumn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddChildToUniformGrid");

	Params::UniformGridPanel_AddChildToUniformGrid Parms{};

	Parms.Content = Content;
	Parms.InRow = InRow;
	Parms.InColumn = InColumn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.UniformGridPanel.SetMinDesiredSlotHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinDesiredSlotHeight                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUniformGridPanel::SetMinDesiredSlotHeight(float InMinDesiredSlotHeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinDesiredSlotHeight");

	Params::UniformGridPanel_SetMinDesiredSlotHeight Parms{};

	Parms.InMinDesiredSlotHeight = InMinDesiredSlotHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UniformGridPanel.SetMinDesiredSlotWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinDesiredSlotWidth                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUniformGridPanel::SetMinDesiredSlotWidth(float InMinDesiredSlotWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinDesiredSlotWidth");

	Params::UniformGridPanel_SetMinDesiredSlotWidth Parms{};

	Parms.InMinDesiredSlotWidth = InMinDesiredSlotWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UniformGridPanel.SetSlotPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InSlotPadding                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UUniformGridPanel::SetSlotPadding(const struct FMargin& InSlotPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSlotPadding");

	Params::UniformGridPanel_SetSlotPadding Parms{};

	Parms.InSlotPadding = std::move(InSlotPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UniformGridSlot.SetColumn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InColumn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUniformGridSlot::SetColumn(int32 InColumn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColumn");

	Params::UniformGridSlot_SetColumn Parms{};

	Parms.InColumn = InColumn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UniformGridSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUniformGridSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::UniformGridSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UniformGridSlot.SetRow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InRow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUniformGridSlot::SetRow(int32 InRow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRow");

	Params::UniformGridSlot_SetRow Parms{};

	Parms.InRow = InRow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.UniformGridSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUniformGridSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::UniformGridSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.VerticalBox.AddChildToVerticalBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVerticalBoxSlot*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVerticalBoxSlot* UVerticalBox::AddChildToVerticalBox(class UWidget* Content)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddChildToVerticalBox");

	Params::VerticalBox_AddChildToVerticalBox Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.VerticalBoxSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerticalBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::VerticalBoxSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.VerticalBoxSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UVerticalBoxSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::VerticalBoxSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.VerticalBoxSlot.SetSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSlateChildSize                  InSize                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UVerticalBoxSlot::SetSize(const struct FSlateChildSize& InSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSize");

	Params::VerticalBoxSlot_SetSize Parms{};

	Parms.InSize = std::move(InSize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.VerticalBoxSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVerticalBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::VerticalBoxSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Viewport.SetViewLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UViewport::SetViewLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetViewLocation");

	Params::Viewport_SetViewLocation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Viewport.SetViewRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UViewport::SetViewRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetViewRotation");

	Params::Viewport_SetViewRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.Viewport.Spawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UViewport::Spawn(TSubclassOf<class AActor> ActorClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Spawn");

	Params::Viewport_Spawn Parms{};

	Parms.ActorClass = ActorClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Viewport.GetViewLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UViewport::GetViewLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetViewLocation");

	Params::Viewport_GetViewLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Viewport.GetViewportWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* UViewport::GetViewportWorld() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetViewportWorld");

	Params::Viewport_GetViewportWorld Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.Viewport.GetViewRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UViewport::GetViewRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetViewRotation");

	Params::Viewport_GetViewRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.VisibilityBinding.GetValue
// (Final, Native, Public, Const)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UVisibilityBinding::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::VisibilityBinding_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetAnimationPlayCallbackProxy.CreatePlayAnimationProxyObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UUMGSequencePlayer*               Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGSequencePlayMode                    PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimationPlayCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimationPlayCallbackProxy* UWidgetAnimationPlayCallbackProxy::CreatePlayAnimationProxyObject(class UUMGSequencePlayer** Result, class UUserWidget* Widget, class UWidgetAnimation* InAnimation, float StartAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreatePlayAnimationProxyObject");

	Params::WidgetAnimationPlayCallbackProxy_CreatePlayAnimationProxyObject Parms{};

	Parms.Widget = Widget;
	Parms.InAnimation = InAnimation;
	Parms.StartAtTime = StartAtTime;
	Parms.NumLoopsToPlay = NumLoopsToPlay;
	Parms.PlayMode = PlayMode;
	Parms.PlaybackSpeed = PlaybackSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function UMG.WidgetAnimationPlayCallbackProxy.CreatePlayAnimationTimeRangeProxyObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UUMGSequencePlayer*               Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 InAnimation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndAtTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLoopsToPlay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMGSequencePlayMode                    PlayMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimationPlayCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetAnimationPlayCallbackProxy* UWidgetAnimationPlayCallbackProxy::CreatePlayAnimationTimeRangeProxyObject(class UUMGSequencePlayer** Result, class UUserWidget* Widget, class UWidgetAnimation* InAnimation, float StartAtTime, float EndAtTime, int32 NumLoopsToPlay, EUMGSequencePlayMode PlayMode, float PlaybackSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreatePlayAnimationTimeRangeProxyObject");

	Params::WidgetAnimationPlayCallbackProxy_CreatePlayAnimationTimeRangeProxyObject Parms{};

	Parms.Widget = Widget;
	Parms.InAnimation = InAnimation;
	Parms.StartAtTime = StartAtTime;
	Parms.EndAtTime = EndAtTime;
	Parms.NumLoopsToPlay = NumLoopsToPlay;
	Parms.PlayMode = PlayMode;
	Parms.PlaybackSpeed = PlaybackSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function UMG.WidgetBinding.GetValue
// (Final, Native, Public, Const)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UWidgetBinding::GetValue() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValue");

	Params::WidgetBinding_GetValue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.CancelDragDrop
// (Final, Native, Static, Public, BlueprintCallable)

void UWidgetBlueprintLibrary::CancelDragDrop()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CancelDragDrop");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function UMG.WidgetBlueprintLibrary.CaptureJoystick
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UWidget*                          CapturingWidget                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInAllJoysticks                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::CaptureJoystick(struct FEventReply& Reply, class UWidget* CapturingWidget, bool bInAllJoysticks)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CaptureJoystick");

	Params::WidgetBlueprintLibrary_CaptureJoystick Parms{};

	Parms.Reply = std::move(Reply);
	Parms.CapturingWidget = CapturingWidget;
	Parms.bInAllJoysticks = bInAllJoysticks;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.CaptureMouse
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UWidget*                          CapturingWidget                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::CaptureMouse(struct FEventReply& Reply, class UWidget* CapturingWidget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CaptureMouse");

	Params::WidgetBlueprintLibrary_CaptureMouse Parms{};

	Parms.Reply = std::move(Reply);
	Parms.CapturingWidget = CapturingWidget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.ClearUserFocus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInAllUsers                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::ClearUserFocus(struct FEventReply& Reply, bool bInAllUsers)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClearUserFocus");

	Params::WidgetBlueprintLibrary_ClearUserFocus Parms{};

	Parms.Reply = std::move(Reply);
	Parms.bInAllUsers = bInAllUsers;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.Create
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          WidgetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                OwningPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UWidgetBlueprintLibrary::Create(class UObject* WorldContextObject, TSubclassOf<class UUserWidget> WidgetType, class APlayerController* OwningPlayer)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Create");

	Params::WidgetBlueprintLibrary_Create Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetType = WidgetType;
	Parms.OwningPlayer = OwningPlayer;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.CreateDragDropOperation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UDragDropOperation>   OperationClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDragDropOperation*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDragDropOperation* UWidgetBlueprintLibrary::CreateDragDropOperation(TSubclassOf<class UDragDropOperation> OperationClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateDragDropOperation");

	Params::WidgetBlueprintLibrary_CreateDragDropOperation Parms{};

	Parms.OperationClass = OperationClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.DetectDrag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UWidget*                          WidgetDetectingDrag                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             DragKey                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::DetectDrag(struct FEventReply& Reply, class UWidget* WidgetDetectingDrag, const struct FKey& DragKey)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DetectDrag");

	Params::WidgetBlueprintLibrary_DetectDrag Parms{};

	Parms.Reply = std::move(Reply);
	Parms.WidgetDetectingDrag = WidgetDetectingDrag;
	Parms.DragKey = std::move(DragKey);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.DetectDragIfPressed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UWidget*                          WidgetDetectingDrag                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             DragKey                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::DetectDragIfPressed(const struct FPointerEvent& PointerEvent, class UWidget* WidgetDetectingDrag, const struct FKey& DragKey)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DetectDragIfPressed");

	Params::WidgetBlueprintLibrary_DetectDragIfPressed Parms{};

	Parms.PointerEvent = std::move(PointerEvent);
	Parms.WidgetDetectingDrag = WidgetDetectingDrag;
	Parms.DragKey = std::move(DragKey);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.DismissAllMenus
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)

void UWidgetBlueprintLibrary::DismissAllMenus()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DismissAllMenus");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function UMG.WidgetBlueprintLibrary.DrawBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPaintContext                    Context                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USlateBrushAsset*                 Brush                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Tint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::DrawBox(struct FPaintContext& Context, const struct FVector2D& Position, const struct FVector2D& Size, class USlateBrushAsset* Brush, const struct FLinearColor& Tint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawBox");

	Params::WidgetBlueprintLibrary_DrawBox Parms{};

	Parms.Context = std::move(Context);
	Parms.Position = std::move(Position);
	Parms.Size = std::move(Size);
	Parms.Brush = Brush;
	Parms.Tint = std::move(Tint);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Context = std::move(Parms.Context);
}


// Function UMG.WidgetBlueprintLibrary.DrawLine
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPaintContext                    Context                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        PositionA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        PositionB                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Tint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAntiAlias                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::DrawLine(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawLine");

	Params::WidgetBlueprintLibrary_DrawLine Parms{};

	Parms.Context = std::move(Context);
	Parms.PositionA = std::move(PositionA);
	Parms.PositionB = std::move(PositionB);
	Parms.Tint = std::move(Tint);
	Parms.bAntiAlias = bAntiAlias;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Context = std::move(Parms.Context);
}


// Function UMG.WidgetBlueprintLibrary.DrawLines
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPaintContext                    Context                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLinearColor                     Tint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAntiAlias                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::DrawLines(struct FPaintContext& Context, const TArray<struct FVector2D>& Points, const struct FLinearColor& Tint, bool bAntiAlias, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawLines");

	Params::WidgetBlueprintLibrary_DrawLines Parms{};

	Parms.Context = std::move(Context);
	Parms.Points = std::move(Points);
	Parms.Tint = std::move(Tint);
	Parms.bAntiAlias = bAntiAlias;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Context = std::move(Parms.Context);
}


// Function UMG.WidgetBlueprintLibrary.DrawText
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPaintContext                    Context                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Tint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::DrawText(struct FPaintContext& Context, const class FString& InString, const struct FVector2D& Position, const struct FLinearColor& Tint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawText");

	Params::WidgetBlueprintLibrary_DrawText Parms{};

	Parms.Context = std::move(Context);
	Parms.InString = std::move(InString);
	Parms.Position = std::move(Position);
	Parms.Tint = std::move(Tint);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Context = std::move(Parms.Context);
}


// Function UMG.WidgetBlueprintLibrary.DrawTextFormatted
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPaintContext                    Context                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFont*                            Font                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FontSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FontTypeFace                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Tint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::DrawTextFormatted(struct FPaintContext& Context, const class FText& Text, const struct FVector2D& Position, class UFont* Font, int32 FontSize, class FName FontTypeFace, const struct FLinearColor& Tint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawTextFormatted");

	Params::WidgetBlueprintLibrary_DrawTextFormatted Parms{};

	Parms.Context = std::move(Context);
	Parms.Text = std::move(Text);
	Parms.Position = std::move(Position);
	Parms.Font = Font;
	Parms.FontSize = FontSize;
	Parms.FontTypeFace = FontTypeFace;
	Parms.Tint = std::move(Tint);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Context = std::move(Parms.Context);
}


// Function UMG.WidgetBlueprintLibrary.EndDragDrop
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::EndDragDrop(struct FEventReply& Reply)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EndDragDrop");

	Params::WidgetBlueprintLibrary_EndDragDrop Parms{};

	Parms.Reply = std::move(Reply);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetAllWidgetsOfClass
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UUserWidget*>              FoundWidgets                                           (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          WidgetClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TopLevelOnly                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::GetAllWidgetsOfClass(class UObject* WorldContextObject, TArray<class UUserWidget*>* FoundWidgets, TSubclassOf<class UUserWidget> WidgetClass, bool TopLevelOnly)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllWidgetsOfClass");

	Params::WidgetBlueprintLibrary_GetAllWidgetsOfClass Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WidgetClass = WidgetClass;
	Parms.TopLevelOnly = TopLevelOnly;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (FoundWidgets != nullptr)
		*FoundWidgets = std::move(Parms.FoundWidgets);
}


// Function UMG.WidgetBlueprintLibrary.GetAllWidgetsWithInterface
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UUserWidget*>              FoundWidgets                                           (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           Interface                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TopLevelOnly                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::GetAllWidgetsWithInterface(class UObject* WorldContextObject, TArray<class UUserWidget*>* FoundWidgets, TSubclassOf<class IInterface> Interface, bool TopLevelOnly)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllWidgetsWithInterface");

	Params::WidgetBlueprintLibrary_GetAllWidgetsWithInterface Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Interface = Interface;
	Parms.TopLevelOnly = TopLevelOnly;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (FoundWidgets != nullptr)
		*FoundWidgets = std::move(Parms.FoundWidgets);
}


// Function UMG.WidgetBlueprintLibrary.GetBrushResource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateBrush                      Brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UWidgetBlueprintLibrary::GetBrushResource(const struct FSlateBrush& Brush)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetBrushResource");

	Params::WidgetBlueprintLibrary_GetBrushResource Parms{};

	Parms.Brush = std::move(Brush);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetBrushResourceAsMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateBrush                      Brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UWidgetBlueprintLibrary::GetBrushResourceAsMaterial(const struct FSlateBrush& Brush)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetBrushResourceAsMaterial");

	Params::WidgetBlueprintLibrary_GetBrushResourceAsMaterial Parms{};

	Parms.Brush = std::move(Brush);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetBrushResourceAsTexture2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateBrush                      Brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UWidgetBlueprintLibrary::GetBrushResourceAsTexture2D(const struct FSlateBrush& Brush)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetBrushResourceAsTexture2D");

	Params::WidgetBlueprintLibrary_GetBrushResourceAsTexture2D Parms{};

	Parms.Brush = std::move(Brush);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetDragDroppingContent
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDragDropOperation*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDragDropOperation* UWidgetBlueprintLibrary::GetDragDroppingContent()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDragDroppingContent");

	Params::WidgetBlueprintLibrary_GetDragDroppingContent Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetDynamicMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UWidgetBlueprintLibrary::GetDynamicMaterial(struct FSlateBrush& Brush)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDynamicMaterial");

	Params::WidgetBlueprintLibrary_GetDynamicMaterial Parms{};

	Parms.Brush = std::move(Brush);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Brush = std::move(Parms.Brush);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetInputEventFromCharacterEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCharacterEvent                  Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FInputEvent                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputEvent UWidgetBlueprintLibrary::GetInputEventFromCharacterEvent(const struct FCharacterEvent& Event)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetInputEventFromCharacterEvent");

	Params::WidgetBlueprintLibrary_GetInputEventFromCharacterEvent Parms{};

	Parms.Event = std::move(Event);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetInputEventFromKeyEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyEvent                        Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FInputEvent                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputEvent UWidgetBlueprintLibrary::GetInputEventFromKeyEvent(const struct FKeyEvent& Event)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetInputEventFromKeyEvent");

	Params::WidgetBlueprintLibrary_GetInputEventFromKeyEvent Parms{};

	Parms.Event = std::move(Event);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetInputEventFromNavigationEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FNavigationEvent                 Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FInputEvent                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputEvent UWidgetBlueprintLibrary::GetInputEventFromNavigationEvent(const struct FNavigationEvent& Event)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetInputEventFromNavigationEvent");

	Params::WidgetBlueprintLibrary_GetInputEventFromNavigationEvent Parms{};

	Parms.Event = std::move(Event);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetInputEventFromPointerEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FInputEvent                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputEvent UWidgetBlueprintLibrary::GetInputEventFromPointerEvent(const struct FPointerEvent& Event)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetInputEventFromPointerEvent");

	Params::WidgetBlueprintLibrary_GetInputEventFromPointerEvent Parms{};

	Parms.Event = std::move(Event);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetKeyEventFromAnalogInputEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnalogInputEvent                Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKeyEvent                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKeyEvent UWidgetBlueprintLibrary::GetKeyEventFromAnalogInputEvent(const struct FAnalogInputEvent& Event)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetKeyEventFromAnalogInputEvent");

	Params::WidgetBlueprintLibrary_GetKeyEventFromAnalogInputEvent Parms{};

	Parms.Event = std::move(Event);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.GetSafeZonePadding
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         SafePadding                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        SafePaddingScale                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         SpillOverPadding                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::GetSafeZonePadding(class UObject* WorldContextObject, struct FVector4* SafePadding, struct FVector2D* SafePaddingScale, struct FVector4* SpillOverPadding)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSafeZonePadding");

	Params::WidgetBlueprintLibrary_GetSafeZonePadding Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (SafePadding != nullptr)
		*SafePadding = std::move(Parms.SafePadding);

	if (SafePaddingScale != nullptr)
		*SafePaddingScale = std::move(Parms.SafePaddingScale);

	if (SpillOverPadding != nullptr)
		*SpillOverPadding = std::move(Parms.SpillOverPadding);
}


// Function UMG.WidgetBlueprintLibrary.Handled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::Handled()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Handled");

	Params::WidgetBlueprintLibrary_Handled Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.IsDragDropping
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetBlueprintLibrary::IsDragDropping()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsDragDropping");

	Params::WidgetBlueprintLibrary_IsDragDropping Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.LockMouse
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UWidget*                          CapturingWidget                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::LockMouse(struct FEventReply& Reply, class UWidget* CapturingWidget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LockMouse");

	Params::WidgetBlueprintLibrary_LockMouse Parms{};

	Parms.Reply = std::move(Reply);
	Parms.CapturingWidget = CapturingWidget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.MakeBrushFromAsset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USlateBrushAsset*                 BrushAsset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UWidgetBlueprintLibrary::MakeBrushFromAsset(class USlateBrushAsset* BrushAsset)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeBrushFromAsset");

	Params::WidgetBlueprintLibrary_MakeBrushFromAsset Parms{};

	Parms.BrushAsset = BrushAsset;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.MakeBrushFromMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UWidgetBlueprintLibrary::MakeBrushFromMaterial(class UMaterialInterface* Material, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeBrushFromMaterial");

	Params::WidgetBlueprintLibrary_MakeBrushFromMaterial Parms{};

	Parms.Material = Material;
	Parms.Width = Width;
	Parms.Height = Height;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.MakeBrushFromTexture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UWidgetBlueprintLibrary::MakeBrushFromTexture(class UTexture2D* Texture, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeBrushFromTexture");

	Params::WidgetBlueprintLibrary_MakeBrushFromTexture Parms{};

	Parms.Texture = Texture;
	Parms.Width = Width;
	Parms.Height = Height;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.NoResourceBrush
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UWidgetBlueprintLibrary::NoResourceBrush()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NoResourceBrush");

	Params::WidgetBlueprintLibrary_NoResourceBrush Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.ReleaseJoystickCapture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInAllJoysticks                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::ReleaseJoystickCapture(struct FEventReply& Reply, bool bInAllJoysticks)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReleaseJoystickCapture");

	Params::WidgetBlueprintLibrary_ReleaseJoystickCapture Parms{};

	Parms.Reply = std::move(Reply);
	Parms.bInAllJoysticks = bInAllJoysticks;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.ReleaseMouseCapture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::ReleaseMouseCapture(struct FEventReply& Reply)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReleaseMouseCapture");

	Params::WidgetBlueprintLibrary_ReleaseMouseCapture Parms{};

	Parms.Reply = std::move(Reply);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.RestorePreviousWindowTitleBarState
// (Final, Native, Static, Public, BlueprintCallable)

void UWidgetBlueprintLibrary::RestorePreviousWindowTitleBarState()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RestorePreviousWindowTitleBarState");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function UMG.WidgetBlueprintLibrary.SetBrushResourceToMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetBrushResourceToMaterial(struct FSlateBrush& Brush, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetBrushResourceToMaterial");

	Params::WidgetBlueprintLibrary_SetBrushResourceToMaterial Parms{};

	Parms.Brush = std::move(Brush);
	Parms.Material = Material;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Brush = std::move(Parms.Brush);
}


// Function UMG.WidgetBlueprintLibrary.SetBrushResourceToTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSlateBrush                      Brush                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetBrushResourceToTexture(struct FSlateBrush& Brush, class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetBrushResourceToTexture");

	Params::WidgetBlueprintLibrary_SetBrushResourceToTexture Parms{};

	Parms.Brush = std::move(Brush);
	Parms.Texture = Texture;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Brush = std::move(Parms.Brush);
}


// Function UMG.WidgetBlueprintLibrary.SetColorVisionDeficiencyType
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// EColorVisionDeficiency                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Severity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CorrectDeficiency                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShowCorrectionWithDeficiency                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetColorVisionDeficiencyType(EColorVisionDeficiency Type, float Severity, bool CorrectDeficiency, bool ShowCorrectionWithDeficiency)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetColorVisionDeficiencyType");

	Params::WidgetBlueprintLibrary_SetColorVisionDeficiencyType Parms{};

	Parms.Type = Type;
	Parms.Severity = Severity;
	Parms.CorrectDeficiency = CorrectDeficiency;
	Parms.ShowCorrectionWithDeficiency = ShowCorrectionWithDeficiency;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.SetFocusToGameViewport
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)

void UWidgetBlueprintLibrary::SetFocusToGameViewport()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetFocusToGameViewport");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function UMG.WidgetBlueprintLibrary.SetHardwareCursor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMouseCursor                            CursorShape                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CursorName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        HotSpot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetBlueprintLibrary::SetHardwareCursor(class UObject* WorldContextObject, EMouseCursor CursorShape, class FName CursorName, const struct FVector2D& HotSpot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetHardwareCursor");

	Params::WidgetBlueprintLibrary_SetHardwareCursor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CursorShape = CursorShape;
	Parms.CursorName = CursorName;
	Parms.HotSpot = std::move(HotSpot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.SetInputMode_GameAndUI
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          InWidgetToFocus                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockMouseToViewport                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideCursorDuringCapture                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetInputMode_GameAndUI(class APlayerController* Target, class UWidget* InWidgetToFocus, bool bLockMouseToViewport, bool bHideCursorDuringCapture)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetInputMode_GameAndUI");

	Params::WidgetBlueprintLibrary_SetInputMode_GameAndUI Parms{};

	Parms.Target = Target;
	Parms.InWidgetToFocus = InWidgetToFocus;
	Parms.bLockMouseToViewport = bLockMouseToViewport;
	Parms.bHideCursorDuringCapture = bHideCursorDuringCapture;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.SetInputMode_GameAndUIEx
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          InWidgetToFocus                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMouseLockMode                          InMouseLockMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideCursorDuringCapture                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetInputMode_GameAndUIEx(class APlayerController* PlayerController, class UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode, bool bHideCursorDuringCapture)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetInputMode_GameAndUIEx");

	Params::WidgetBlueprintLibrary_SetInputMode_GameAndUIEx Parms{};

	Parms.PlayerController = PlayerController;
	Parms.InWidgetToFocus = InWidgetToFocus;
	Parms.InMouseLockMode = InMouseLockMode;
	Parms.bHideCursorDuringCapture = bHideCursorDuringCapture;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.SetInputMode_GameOnly
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetInputMode_GameOnly(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetInputMode_GameOnly");

	Params::WidgetBlueprintLibrary_SetInputMode_GameOnly Parms{};

	Parms.PlayerController = PlayerController;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.SetInputMode_UIOnly
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          InWidgetToFocus                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockMouseToViewport                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetInputMode_UIOnly(class APlayerController* Target, class UWidget* InWidgetToFocus, bool bLockMouseToViewport)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetInputMode_UIOnly");

	Params::WidgetBlueprintLibrary_SetInputMode_UIOnly Parms{};

	Parms.Target = Target;
	Parms.InWidgetToFocus = InWidgetToFocus;
	Parms.bLockMouseToViewport = bLockMouseToViewport;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.SetInputMode_UIOnlyEx
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          InWidgetToFocus                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMouseLockMode                          InMouseLockMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetInputMode_UIOnlyEx(class APlayerController* PlayerController, class UWidget* InWidgetToFocus, EMouseLockMode InMouseLockMode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetInputMode_UIOnlyEx");

	Params::WidgetBlueprintLibrary_SetInputMode_UIOnlyEx Parms{};

	Parms.PlayerController = PlayerController;
	Parms.InWidgetToFocus = InWidgetToFocus;
	Parms.InMouseLockMode = InMouseLockMode;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.SetMousePosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        NewMousePosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::SetMousePosition(struct FEventReply& Reply, const struct FVector2D& NewMousePosition)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetMousePosition");

	Params::WidgetBlueprintLibrary_SetMousePosition Parms{};

	Parms.Reply = std::move(Reply);
	Parms.NewMousePosition = std::move(NewMousePosition);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.SetUserFocus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UWidget*                          FocusWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInAllUsers                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::SetUserFocus(struct FEventReply& Reply, class UWidget* FocusWidget, bool bInAllUsers)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetUserFocus");

	Params::WidgetBlueprintLibrary_SetUserFocus Parms{};

	Parms.Reply = std::move(Reply);
	Parms.FocusWidget = FocusWidget;
	Parms.bInAllUsers = bInAllUsers;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.SetWindowTitleBarCloseButtonActive
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetWindowTitleBarCloseButtonActive(bool bActive)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetWindowTitleBarCloseButtonActive");

	Params::WidgetBlueprintLibrary_SetWindowTitleBarCloseButtonActive Parms{};

	Parms.bActive = bActive;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.SetWindowTitleBarOnCloseClickedDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetWindowTitleBarOnCloseClickedDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetWindowTitleBarOnCloseClickedDelegate");

	Params::WidgetBlueprintLibrary_SetWindowTitleBarOnCloseClickedDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.SetWindowTitleBarState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          TitleBarContent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWindowTitleBarMode                     Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTitleBarDragEnabled                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWindowButtonsVisible                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTitleBarVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetBlueprintLibrary::SetWindowTitleBarState(class UWidget* TitleBarContent, EWindowTitleBarMode Mode, bool bTitleBarDragEnabled, bool bWindowButtonsVisible, bool bTitleBarVisible)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetWindowTitleBarState");

	Params::WidgetBlueprintLibrary_SetWindowTitleBarState Parms{};

	Parms.TitleBarContent = TitleBarContent;
	Parms.Mode = Mode;
	Parms.bTitleBarDragEnabled = bTitleBarDragEnabled;
	Parms.bWindowButtonsVisible = bWindowButtonsVisible;
	Parms.bTitleBarVisible = bTitleBarVisible;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetBlueprintLibrary.Unhandled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::Unhandled()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Unhandled");

	Params::WidgetBlueprintLibrary_Unhandled Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetBlueprintLibrary.UnlockMouse
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEventReply                      Reply                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UWidgetBlueprintLibrary::UnlockMouse(struct FEventReply& Reply)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnlockMouse");

	Params::WidgetBlueprintLibrary_UnlockMouse Parms{};

	Parms.Reply = std::move(Reply);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Reply = std::move(Parms.Reply);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.GetMousePositionOnPlatform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidgetLayoutLibrary::GetMousePositionOnPlatform()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMousePositionOnPlatform");

	Params::WidgetLayoutLibrary_GetMousePositionOnPlatform Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.GetMousePositionOnViewport
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidgetLayoutLibrary::GetMousePositionOnViewport(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMousePositionOnViewport");

	Params::WidgetLayoutLibrary_GetMousePositionOnViewport Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.GetMousePositionScaledByDPI
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocationX                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocationY                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetLayoutLibrary::GetMousePositionScaledByDPI(class APlayerController* Player, float* LocationX, float* LocationY)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMousePositionScaledByDPI");

	Params::WidgetLayoutLibrary_GetMousePositionScaledByDPI Parms{};

	Parms.Player = Player;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LocationX != nullptr)
		*LocationX = Parms.LocationX;

	if (LocationY != nullptr)
		*LocationY = Parms.LocationY;

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.GetPlayerScreenWidgetGeometry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGeometry                        ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FGeometry UWidgetLayoutLibrary::GetPlayerScreenWidgetGeometry(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerScreenWidgetGeometry");

	Params::WidgetLayoutLibrary_GetPlayerScreenWidgetGeometry Parms{};

	Parms.PlayerController = PlayerController;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.GetViewportScale
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWidgetLayoutLibrary::GetViewportScale(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetViewportScale");

	Params::WidgetLayoutLibrary_GetViewportScale Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.GetViewportSize
// (Final, BlueprintCosmetic, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWidgetLayoutLibrary::GetViewportSize(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetViewportSize");

	Params::WidgetLayoutLibrary_GetViewportSize Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.GetViewportWidgetGeometry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGeometry                        ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FGeometry UWidgetLayoutLibrary::GetViewportWidgetGeometry(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetViewportWidgetGeometry");

	Params::WidgetLayoutLibrary_GetViewportWidgetGeometry Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.ProjectWorldLocationToWidgetPosition
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerViewportRelative                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetLayoutLibrary::ProjectWorldLocationToWidgetPosition(class APlayerController* PlayerController, const struct FVector& WorldLocation, struct FVector2D* ScreenPosition, bool bPlayerViewportRelative)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectWorldLocationToWidgetPosition");

	Params::WidgetLayoutLibrary_ProjectWorldLocationToWidgetPosition Parms{};

	Parms.PlayerController = PlayerController;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.bPlayerViewportRelative = bPlayerViewportRelative;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (ScreenPosition != nullptr)
		*ScreenPosition = std::move(Parms.ScreenPosition);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.RemoveAllWidgets
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetLayoutLibrary::RemoveAllWidgets(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RemoveAllWidgets");

	Params::WidgetLayoutLibrary_RemoveAllWidgets Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetLayoutLibrary.SlotAsBorderSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBorderSlot*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBorderSlot* UWidgetLayoutLibrary::SlotAsBorderSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsBorderSlot");

	Params::WidgetLayoutLibrary_SlotAsBorderSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsCanvasSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCanvasPanelSlot*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCanvasPanelSlot* UWidgetLayoutLibrary::SlotAsCanvasSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsCanvasSlot");

	Params::WidgetLayoutLibrary_SlotAsCanvasSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsGridSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGridSlot*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGridSlot* UWidgetLayoutLibrary::SlotAsGridSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsGridSlot");

	Params::WidgetLayoutLibrary_SlotAsGridSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsHorizontalBoxSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHorizontalBoxSlot*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHorizontalBoxSlot* UWidgetLayoutLibrary::SlotAsHorizontalBoxSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsHorizontalBoxSlot");

	Params::WidgetLayoutLibrary_SlotAsHorizontalBoxSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsOverlaySlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOverlaySlot*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOverlaySlot* UWidgetLayoutLibrary::SlotAsOverlaySlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsOverlaySlot");

	Params::WidgetLayoutLibrary_SlotAsOverlaySlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsSafeBoxSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USafeZoneSlot*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USafeZoneSlot* UWidgetLayoutLibrary::SlotAsSafeBoxSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsSafeBoxSlot");

	Params::WidgetLayoutLibrary_SlotAsSafeBoxSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsScaleBoxSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScaleBoxSlot*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScaleBoxSlot* UWidgetLayoutLibrary::SlotAsScaleBoxSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsScaleBoxSlot");

	Params::WidgetLayoutLibrary_SlotAsScaleBoxSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsScrollBoxSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UScrollBoxSlot*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UScrollBoxSlot* UWidgetLayoutLibrary::SlotAsScrollBoxSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsScrollBoxSlot");

	Params::WidgetLayoutLibrary_SlotAsScrollBoxSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsSizeBoxSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USizeBoxSlot*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USizeBoxSlot* UWidgetLayoutLibrary::SlotAsSizeBoxSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsSizeBoxSlot");

	Params::WidgetLayoutLibrary_SlotAsSizeBoxSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsUniformGridSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUniformGridSlot*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUniformGridSlot* UWidgetLayoutLibrary::SlotAsUniformGridSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsUniformGridSlot");

	Params::WidgetLayoutLibrary_SlotAsUniformGridSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsVerticalBoxSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVerticalBoxSlot*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVerticalBoxSlot* UWidgetLayoutLibrary::SlotAsVerticalBoxSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsVerticalBoxSlot");

	Params::WidgetLayoutLibrary_SlotAsVerticalBoxSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsWidgetSwitcherSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetSwitcherSlot*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetSwitcherSlot* UWidgetLayoutLibrary::SlotAsWidgetSwitcherSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsWidgetSwitcherSlot");

	Params::WidgetLayoutLibrary_SlotAsWidgetSwitcherSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetLayoutLibrary.SlotAsWrapBoxSlot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWrapBoxSlot*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWrapBoxSlot* UWidgetLayoutLibrary::SlotAsWrapBoxSlot(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SlotAsWrapBoxSlot");

	Params::WidgetLayoutLibrary_SlotAsWrapBoxSlot Parms{};

	Parms.Widget = Widget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WidgetSwitcherSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetSwitcherSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::WidgetSwitcherSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetSwitcherSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UWidgetSwitcherSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::WidgetSwitcherSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WidgetSwitcherSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetSwitcherSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::WidgetSwitcherSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WindowTitleBarArea.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindowTitleBarArea::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::WindowTitleBarArea_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WindowTitleBarArea.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UWindowTitleBarArea::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::WindowTitleBarArea_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WindowTitleBarArea.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindowTitleBarArea::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::WindowTitleBarArea_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WindowTitleBarAreaSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindowTitleBarAreaSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::WindowTitleBarAreaSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WindowTitleBarAreaSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UWindowTitleBarAreaSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::WindowTitleBarAreaSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WindowTitleBarAreaSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindowTitleBarAreaSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::WindowTitleBarAreaSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WrapBox.AddChildToWrapBox
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Content                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWrapBoxSlot*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWrapBoxSlot* UWrapBox::AddChildToWrapBox(class UWidget* Content)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddChildToWrapBox");

	Params::WrapBox_AddChildToWrapBox Parms{};

	Parms.Content = Content;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UMG.WrapBox.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWrapBox::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::WrapBox_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WrapBox.SetInnerSlotPadding
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWrapBox::SetInnerSlotPadding(const struct FVector2D& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInnerSlotPadding");

	Params::WrapBox_SetInnerSlotPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WrapBoxSlot.SetFillEmptySpace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbFillEmptySpace                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWrapBoxSlot::SetFillEmptySpace(bool InbFillEmptySpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFillEmptySpace");

	Params::WrapBoxSlot_SetFillEmptySpace Parms{};

	Parms.InbFillEmptySpace = InbFillEmptySpace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WrapBoxSlot.SetFillSpanWhenLessThan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InFillSpanWhenLessThan                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWrapBoxSlot::SetFillSpanWhenLessThan(float InFillSpanWhenLessThan)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFillSpanWhenLessThan");

	Params::WrapBoxSlot_SetFillSpanWhenLessThan Parms{};

	Parms.InFillSpanWhenLessThan = InFillSpanWhenLessThan;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WrapBoxSlot.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHorizontalAlignment                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWrapBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::WrapBoxSlot_SetHorizontalAlignment Parms{};

	Parms.InHorizontalAlignment = InHorizontalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WrapBoxSlot.SetNewLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InForceNewLine                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWrapBoxSlot::SetNewLine(bool InForceNewLine)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNewLine");

	Params::WrapBoxSlot_SetNewLine Parms{};

	Parms.InForceNewLine = InForceNewLine;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WrapBoxSlot.SetPadding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMargin                          InPadding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UWrapBoxSlot::SetPadding(const struct FMargin& InPadding)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPadding");

	Params::WrapBoxSlot_SetPadding Parms{};

	Parms.InPadding = std::move(InPadding);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UMG.WrapBoxSlot.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVerticalAlignment                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWrapBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::WrapBoxSlot_SetVerticalAlignment Parms{};

	Parms.InVerticalAlignment = InVerticalAlignment;

	UObject::ProcessEvent(Func, &Parms);
}

}

