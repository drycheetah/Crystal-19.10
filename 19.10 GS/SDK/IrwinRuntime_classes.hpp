#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: IrwinRuntime

#include "Basic.hpp"

#include "FortniteGame_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class IrwinRuntime.FortAIFaunaAnimInstance
// 0x0040 (0x04F0 - 0x04B0)
class UFortAIFaunaAnimInstance : public UFortAIAnimInstance
{
public:
	float                                         AverageSpeed;                                      // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AverageSpeedTimeFrame;                             // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasValidAimTarget;                                // 0x04B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B9[0x3];                                      // 0x04B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AimTargetLocation;                                 // 0x04BC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSurfaceSwimming;                                // 0x04C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGround;                                 // 0x04C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTornado;                                      // 0x04CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CB[0x1];                                      // 0x04CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtAlpha;                                       // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceToPlayerForLookAt;                      // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtTooFarFromPlayerTimeOut;                     // 0x04D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableLookAtDuringMontage;                       // 0x04D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D9[0x3];                                      // 0x04D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableHeadTrackingCurveName;                      // 0x04DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E4[0xC];                                      // 0x04E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateLookAtAlpha(bool bForceDisableLookAt, float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance">();
	}
	static class UFortAIFaunaAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance");
static_assert(sizeof(UFortAIFaunaAnimInstance) == 0x0004F0, "Wrong size on UFortAIFaunaAnimInstance");
static_assert(offsetof(UFortAIFaunaAnimInstance, AverageSpeed) == 0x0004B0, "Member 'UFortAIFaunaAnimInstance::AverageSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AverageSpeedTimeFrame) == 0x0004B4, "Member 'UFortAIFaunaAnimInstance::AverageSpeedTimeFrame' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bHasValidAimTarget) == 0x0004B8, "Member 'UFortAIFaunaAnimInstance::bHasValidAimTarget' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, AimTargetLocation) == 0x0004BC, "Member 'UFortAIFaunaAnimInstance::AimTargetLocation' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsSurfaceSwimming) == 0x0004C8, "Member 'UFortAIFaunaAnimInstance::bIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsMovingOnGround) == 0x0004C9, "Member 'UFortAIFaunaAnimInstance::bIsMovingOnGround' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bIsInTornado) == 0x0004CA, "Member 'UFortAIFaunaAnimInstance::bIsInTornado' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, LookAtAlpha) == 0x0004CC, "Member 'UFortAIFaunaAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, MaxDistanceToPlayerForLookAt) == 0x0004D0, "Member 'UFortAIFaunaAnimInstance::MaxDistanceToPlayerForLookAt' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, LookAtTooFarFromPlayerTimeOut) == 0x0004D4, "Member 'UFortAIFaunaAnimInstance::LookAtTooFarFromPlayerTimeOut' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, bDisableLookAtDuringMontage) == 0x0004D8, "Member 'UFortAIFaunaAnimInstance::bDisableLookAtDuringMontage' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance, DisableHeadTrackingCurveName) == 0x0004DC, "Member 'UFortAIFaunaAnimInstance::DisableHeadTrackingCurveName' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Burt
// 0x0090 (0x0580 - 0x04F0)
class UFortAIFaunaAnimInstance_Burt : public UFortAIFaunaAnimInstance
{
public:
	float                                         MovingPlayRate;                                    // 0x04F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x04F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadTiltUpAdditive;                         // 0x04F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAngleIsNegative;                              // 0x04F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FA[0x2];                                      // 0x04FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisableLocomotionAdditiveCurveName;                // 0x04FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InterruptibleCurveName;                            // 0x0504(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x050C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50D[0x3];                                      // 0x050D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x0510(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0514(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x0518(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0519(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToApex;                          // 0x051A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToMoving;                        // 0x051B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionMovingToIdle;                        // 0x051C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLandToIdle;                          // 0x051D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLandToJumpStart;                     // 0x051E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpStartToApex;                     // 0x051F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionApexToFall;                          // 0x0520(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToLand;                          // 0x0521(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToIdle;                      // 0x0522(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToIdle;                // 0x0523(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToMoving;              // 0x0524(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToMoving;                    // 0x0525(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToMoving;                        // 0x0526(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToIdle;                          // 0x0527(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SpeedThreshold;                     // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SlowSpeedDivisor;                   // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_FastSpeedDivisor;                   // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MinClamp;                           // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MaxClamp;                           // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_InterpSpeed;                        // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha_InterpSpeed;           // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier;   // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableHeadTiltUpAdditive_ModOperand;               // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_LargeThreshold;            // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_TurnAngleThreshold;        // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_MovingThreshold;                             // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_IdleThreshold;                               // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngle_LargeThreshold;                          // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Burt">();
	}
	static class UFortAIFaunaAnimInstance_Burt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Burt>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Burt) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Burt");
static_assert(sizeof(UFortAIFaunaAnimInstance_Burt) == 0x000580, "Wrong size on UFortAIFaunaAnimInstance_Burt");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate) == 0x0004F0, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, LocomotionPoseAdditiveAlpha) == 0x0004F4, "Member 'UFortAIFaunaAnimInstance_Burt::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bEnableHeadTiltUpAdditive) == 0x0004F8, "Member 'UFortAIFaunaAnimInstance_Burt::bEnableHeadTiltUpAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bTurnAngleIsNegative) == 0x0004F9, "Member 'UFortAIFaunaAnimInstance_Burt::bTurnAngleIsNegative' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, DisableLocomotionAdditiveCurveName) == 0x0004FC, "Member 'UFortAIFaunaAnimInstance_Burt::DisableLocomotionAdditiveCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveName) == 0x000504, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIsIdleShuffleTurn) == 0x00050C, "Member 'UFortAIFaunaAnimInstance_Burt::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleBodyBend) == 0x000510, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRate) == 0x000514, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIdleShuffleTurnDirection) == 0x000518, "Member 'UFortAIFaunaAnimInstance_Burt::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bIsMoving) == 0x000519, "Member 'UFortAIFaunaAnimInstance_Burt::bIsMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleToApex) == 0x00051A, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleToApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleToMoving) == 0x00051B, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionMovingToIdle) == 0x00051C, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionMovingToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLandToIdle) == 0x00051D, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLandToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLandToJumpStart) == 0x00051E, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLandToJumpStart' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionJumpStartToApex) == 0x00051F, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionJumpStartToApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionApexToFall) == 0x000520, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionApexToFall' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToLand) == 0x000521, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleTurnToIdle) == 0x000522, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLocomotionTurnToIdle) == 0x000523, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLocomotionTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionLocomotionTurnToMoving) == 0x000524, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionLocomotionTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionIdleTurnToMoving) == 0x000525, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionIdleTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToMoving) == 0x000526, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, bCanTransitionFallToIdle) == 0x000527, "Member 'UFortAIFaunaAnimInstance_Burt::bCanTransitionFallToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_SpeedThreshold) == 0x000528, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_SlowSpeedDivisor) == 0x00052C, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_SlowSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_FastSpeedDivisor) == 0x000530, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_FastSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_MinClamp) == 0x000534, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_MinClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_MaxClamp) == 0x000538, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_MaxClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, MovingPlayRate_InterpSpeed) == 0x00053C, "Member 'UFortAIFaunaAnimInstance_Burt::MovingPlayRate_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, LocomotionPoseAdditiveAlpha_InterpSpeed) == 0x000540, "Member 'UFortAIFaunaAnimInstance_Burt::LocomotionPoseAdditiveAlpha_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier) == 0x000544, "Member 'UFortAIFaunaAnimInstance_Burt::EnableHeadTiltUpAdditive_PawnUniqueIDMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, EnableHeadTiltUpAdditive_ModOperand) == 0x000548, "Member 'UFortAIFaunaAnimInstance_Burt::EnableHeadTiltUpAdditive_ModOperand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveValue_LargeThreshold) == 0x00054C, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveValue_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, InterruptibleCurveValue_TurnAngleThreshold) == 0x000550, "Member 'UFortAIFaunaAnimInstance_Burt::InterruptibleCurveValue_TurnAngleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_MovingThreshold) == 0x000554, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_MovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, Speed_IdleThreshold) == 0x000558, "Member 'UFortAIFaunaAnimInstance_Burt::Speed_IdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, TurnAngle_LargeThreshold) == 0x00055C, "Member 'UFortAIFaunaAnimInstance_Burt::TurnAngle_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleBodyBendMultiplier) == 0x000560, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleTurnThreshold) == 0x000564, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShuffleTurnDirectionThreshold) == 0x000568, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateInRangeA) == 0x00056C, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateInRangeB) == 0x000570, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateOutRangeA) == 0x000574, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt, IdleShufflePlayRateOutRangeB) == 0x000578, "Member 'UFortAIFaunaAnimInstance_Burt::IdleShufflePlayRateOutRangeB' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Burt_Hitchhiker
// 0x0010 (0x0590 - 0x0580)
class UFortAIFaunaAnimInstance_Burt_Hitchhiker final : public UFortAIFaunaAnimInstance_Burt
{
public:
	bool                                          IsFloating;                                        // 0x0580(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInTractorBeam;                                   // 0x0581(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHitchhiked;                                      // 0x0582(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_583[0xD];                                      // 0x0583(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Burt_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Burt_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Burt_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Burt_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Burt_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Burt_Hitchhiker) == 0x000590, "Wrong size on UFortAIFaunaAnimInstance_Burt_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsFloating) == 0x000580, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsInTractorBeam) == 0x000581, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Burt_Hitchhiker, IsHitchhiked) == 0x000582, "Member 'UFortAIFaunaAnimInstance_Burt_Hitchhiker::IsHitchhiked' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Crow
// 0x0030 (0x0520 - 0x04F0)
class UFortAIFaunaAnimInstance_Crow final : public UFortAIFaunaAnimInstance
{
public:
	float                                         WingFlapPlayRate;                                  // 0x04F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDescending;                                     // 0x04F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGliding;                                        // 0x04F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlying;                                         // 0x04F6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlyingSlow;                                     // 0x04F7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLanding;                                        // 0x04F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F9[0x3];                                      // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WingFlapPlayRateInRangeA;                          // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateInRangeB;                          // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateOutRangeA;                         // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WingFlapPlayRateOutRangeB;                         // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZVelocityDescendingThreshold;                      // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlidingSpeedThreshold;                             // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingSpeedThreshold;                              // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingSlowSpeedThreshold;                          // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingSpeedThreshold;                             // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Crow">();
	}
	static class UFortAIFaunaAnimInstance_Crow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Crow>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Crow) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Crow");
static_assert(sizeof(UFortAIFaunaAnimInstance_Crow) == 0x000520, "Wrong size on UFortAIFaunaAnimInstance_Crow");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRate) == 0x0004F0, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsDescending) == 0x0004F4, "Member 'UFortAIFaunaAnimInstance_Crow::bIsDescending' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsGliding) == 0x0004F5, "Member 'UFortAIFaunaAnimInstance_Crow::bIsGliding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsFlying) == 0x0004F6, "Member 'UFortAIFaunaAnimInstance_Crow::bIsFlying' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsFlyingSlow) == 0x0004F7, "Member 'UFortAIFaunaAnimInstance_Crow::bIsFlyingSlow' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, bIsLanding) == 0x0004F8, "Member 'UFortAIFaunaAnimInstance_Crow::bIsLanding' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateInRangeA) == 0x0004FC, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateInRangeB) == 0x000500, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateOutRangeA) == 0x000504, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, WingFlapPlayRateOutRangeB) == 0x000508, "Member 'UFortAIFaunaAnimInstance_Crow::WingFlapPlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, ZVelocityDescendingThreshold) == 0x00050C, "Member 'UFortAIFaunaAnimInstance_Crow::ZVelocityDescendingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, GlidingSpeedThreshold) == 0x000510, "Member 'UFortAIFaunaAnimInstance_Crow::GlidingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, FlyingSpeedThreshold) == 0x000514, "Member 'UFortAIFaunaAnimInstance_Crow::FlyingSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, FlyingSlowSpeedThreshold) == 0x000518, "Member 'UFortAIFaunaAnimInstance_Crow::FlyingSlowSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Crow, LandingSpeedThreshold) == 0x00051C, "Member 'UFortAIFaunaAnimInstance_Crow::LandingSpeedThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Grandma
// 0x00C0 (0x05B0 - 0x04F0)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAIFaunaAnimInstance_Grandma : public UFortAIFaunaAnimInstance
{
public:
	class AFortAIPawn*                            AIPawn;                                            // 0x04F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshScale;                                         // 0x04F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayFullBodyInPlace;                        // 0x04FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FD[0x3];                                      // 0x04FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkAlpha;                                        // 0x0500(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkRunPlayRate;                                   // 0x0504(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x0508(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSniffAdditive;                              // 0x050C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAlertAdditive;                              // 0x050D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleStartTurn;                                    // 0x050E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtAdditiveTurnAlpha;                          // 0x050F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0510(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_511[0x3];                                      // 0x0511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x0514(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0518(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x051C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51D[0x3];                                      // 0x051D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeedFullBodyInPlace;                           // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCurveValueFullBodyInPlace;                      // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlphaInterpRate;             // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SniffAdditiveFrequenceySeconds;                    // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlertAdditiveFrequenceySeconds;                    // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PawnIDScale;                                       // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShouldPlayFullBodyInPlaceCurveName;                // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BlinkAlphaCurveName;                               // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleStartTurnInterruptibleThreshold;               // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAdditiveTurnAlphaThreshold;                  // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOnGroundORIsSurfaceSwimming;              // 0x056C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_DefaultJump_ToJumpApex;                 // 0x056D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Idle;                          // 0x056E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Moving;                        // 0x056F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnIdle;                        // 0x0570(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_Moving;                      // 0x0571(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnMoving;                      // 0x0572(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x0573(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_Idle;                            // 0x0574(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpLand_Idle;                          // 0x0575(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpLand_Moving;                        // 0x0576(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpStart_JumpApex;                     // 0x0577(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Moving;                            // 0x0578(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Idle;                              // 0x0579(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimIdle_SwimLoco;                      // 0x057A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimLoco_SwimIdle;                      // 0x057B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimIdle;                      // 0x057C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimLoco;                      // 0x057D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRule_NegativeTurnAngle;                       // 0x057E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57F[0x1];                                      // 0x057F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterruptibleMaxCheck;                             // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedStopTransition;                               // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleMoveTransition;                           // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMovingTurnIdleTransition;                     // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMin;                                    // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeFromEndThreshold;                         // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleStartTurnThreshold;                       // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedFallMovingThreshold;                          // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A0[0x8];                                      // 0x05A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateBlinkAlpha();
	float CalculateLocomotionPoseAlpha();
	float CalculateMeshScale();
	float CalculateWalkRunPlayRate();
	bool DetermineEnableAlertAdditive();
	bool DetermineEnableSniffAdditive();
	bool DetermineIdleStartTurn();
	bool DetermineShouldPlayFullBodyInPlace();
	void UpdateBlinkAlpha();
	void UpdateEnableAlertAdditive();
	void UpdateEnableSniffAdditive();
	void UpdateIdleStartTurn();
	void UpdateLocomotionPoseAlpha();
	void UpdateMeshScale();
	void UpdateMovingRates();
	void UpdateShouldPlayFullBodyInPlace();
	void UpdateStateVariables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Grandma">();
	}
	static class UFortAIFaunaAnimInstance_Grandma* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Grandma>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAIFaunaAnimInstance_Grandma) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Grandma");
static_assert(sizeof(UFortAIFaunaAnimInstance_Grandma) == 0x0005B0, "Wrong size on UFortAIFaunaAnimInstance_Grandma");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, AIPawn) == 0x0004F0, "Member 'UFortAIFaunaAnimInstance_Grandma::AIPawn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MeshScale) == 0x0004F8, "Member 'UFortAIFaunaAnimInstance_Grandma::MeshScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bShouldPlayFullBodyInPlace) == 0x0004FC, "Member 'UFortAIFaunaAnimInstance_Grandma::bShouldPlayFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, BlinkAlpha) == 0x000500, "Member 'UFortAIFaunaAnimInstance_Grandma::BlinkAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, WalkRunPlayRate) == 0x000504, "Member 'UFortAIFaunaAnimInstance_Grandma::WalkRunPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LocomotionPoseAdditiveAlpha) == 0x000508, "Member 'UFortAIFaunaAnimInstance_Grandma::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bEnableSniffAdditive) == 0x00050C, "Member 'UFortAIFaunaAnimInstance_Grandma::bEnableSniffAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bEnableAlertAdditive) == 0x00050D, "Member 'UFortAIFaunaAnimInstance_Grandma::bEnableAlertAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIdleStartTurn) == 0x00050E, "Member 'UFortAIFaunaAnimInstance_Grandma::bIdleStartTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bLookAtAdditiveTurnAlpha) == 0x00050F, "Member 'UFortAIFaunaAnimInstance_Grandma::bLookAtAdditiveTurnAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIsIdleShuffleTurn) == 0x000510, "Member 'UFortAIFaunaAnimInstance_Grandma::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleBodyBend) == 0x000514, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRate) == 0x000518, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIdleShuffleTurnDirection) == 0x00051C, "Member 'UFortAIFaunaAnimInstance_Grandma::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MaxSpeedFullBodyInPlace) == 0x000520, "Member 'UFortAIFaunaAnimInstance_Grandma::MaxSpeedFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, MinCurveValueFullBodyInPlace) == 0x000524, "Member 'UFortAIFaunaAnimInstance_Grandma::MinCurveValueFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LocomotionPoseAdditiveAlphaInterpRate) == 0x000528, "Member 'UFortAIFaunaAnimInstance_Grandma::LocomotionPoseAdditiveAlphaInterpRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SniffAdditiveFrequenceySeconds) == 0x00052C, "Member 'UFortAIFaunaAnimInstance_Grandma::SniffAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, AlertAdditiveFrequenceySeconds) == 0x000530, "Member 'UFortAIFaunaAnimInstance_Grandma::AlertAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, PawnIDScale) == 0x000534, "Member 'UFortAIFaunaAnimInstance_Grandma::PawnIDScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, ShouldPlayFullBodyInPlaceCurveName) == 0x000538, "Member 'UFortAIFaunaAnimInstance_Grandma::ShouldPlayFullBodyInPlaceCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, BlinkAlphaCurveName) == 0x000540, "Member 'UFortAIFaunaAnimInstance_Grandma::BlinkAlphaCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleStartTurnInterruptibleThreshold) == 0x000548, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleStartTurnInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleBodyBendMultiplier) == 0x00054C, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleTurnThreshold) == 0x000550, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShuffleTurnDirectionThreshold) == 0x000554, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, LookAtAdditiveTurnAlphaThreshold) == 0x000558, "Member 'UFortAIFaunaAnimInstance_Grandma::LookAtAdditiveTurnAlphaThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateInRangeA) == 0x00055C, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateInRangeB) == 0x000560, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateOutRangeA) == 0x000564, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, IdleShufflePlayRateOutRangeB) == 0x000568, "Member 'UFortAIFaunaAnimInstance_Grandma::IdleShufflePlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bIsMovingOnGroundORIsSurfaceSwimming) == 0x00056C, "Member 'UFortAIFaunaAnimInstance_Grandma::bIsMovingOnGroundORIsSurfaceSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_DefaultJump_ToJumpApex) == 0x00056D, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_DefaultJump_ToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnIdle_Idle) == 0x00056E, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnIdle_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnIdle_Moving) == 0x00056F, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnIdle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_TurnIdle) == 0x000570, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_TurnMoving_Moving) == 0x000571, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_TurnMoving_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_TurnMoving) == 0x000572, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_TurnMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Idle_Moving) == 0x000573, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Moving_Idle) == 0x000574, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Moving_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpLand_Idle) == 0x000575, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpLand_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpLand_Moving) == 0x000576, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpLand_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_JumpStart_JumpApex) == 0x000577, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_JumpStart_JumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Fall_Moving) == 0x000578, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Fall_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_Fall_Idle) == 0x000579, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_Fall_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimIdle_SwimLoco) == 0x00057A, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimIdle_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimLoco_SwimIdle) == 0x00057B, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimLoco_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimTurn_SwimIdle) == 0x00057C, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimTurn_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bStateRule_SwimTurn_SwimLoco) == 0x00057D, "Member 'UFortAIFaunaAnimInstance_Grandma::bStateRule_SwimTurn_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, bAnimRule_NegativeTurnAngle) == 0x00057E, "Member 'UFortAIFaunaAnimInstance_Grandma::bAnimRule_NegativeTurnAngle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, InterruptibleMaxCheck) == 0x000580, "Member 'UFortAIFaunaAnimInstance_Grandma::InterruptibleMaxCheck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedStopTransition) == 0x000584, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedStopTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedIdleMoveTransition) == 0x000588, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedIdleMoveTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedMovingTurnIdleTransition) == 0x00058C, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedMovingTurnIdleTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedToMoveMin) == 0x000590, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedToMoveMin' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, StateTimeFromEndThreshold) == 0x000594, "Member 'UFortAIFaunaAnimInstance_Grandma::StateTimeFromEndThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedIdleStartTurnThreshold) == 0x000598, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedIdleStartTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma, SpeedFallMovingThreshold) == 0x00059C, "Member 'UFortAIFaunaAnimInstance_Grandma::SpeedFallMovingThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Grandma_Hitchhiker
// 0x0000 (0x05B0 - 0x05B0)
class UFortAIFaunaAnimInstance_Grandma_Hitchhiker final : public UFortAIFaunaAnimInstance_Grandma
{
public:
	bool                                          bIsHitchhiked;                                     // 0x05A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGrandmaSprinting;                               // 0x05A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x05AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x05AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintCheckSpeed;                                  // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Grandma_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Grandma_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Grandma_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Grandma_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker) == 0x0005B0, "Wrong size on UFortAIFaunaAnimInstance_Grandma_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsHitchhiked) == 0x0005A8, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsHitchhiked' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsGrandmaSprinting) == 0x0005A9, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsGrandmaSprinting' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsFloating) == 0x0005AA, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, bIsInTractorBeam) == 0x0005AB, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Grandma_Hitchhiker, SprintCheckSpeed) == 0x0005AC, "Member 'UFortAIFaunaAnimInstance_Grandma_Hitchhiker::SprintCheckSpeed' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Nug
// 0x00A0 (0x0590 - 0x04F0)
#pragma pack(push, 0x1)
class alignas(0x10) UFortAIFaunaAnimInstance_Nug : public UFortAIFaunaAnimInstance
{
public:
	bool                                          bIsBeingHeld;                                      // 0x04F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBeingThrown;                                    // 0x04F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F2[0x2];                                      // 0x04F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LowerBodyMaskAlpha;                                // 0x04F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldExitJump;                                   // 0x04F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F9[0x3];                                      // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingPlayRate;                                    // 0x04FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLean;                                       // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanDirection;                                     // 0x0504(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnAngleIsNegative;                              // 0x0508(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_509[0x3];                                      // 0x0509(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InterruptibleCurveName;                            // 0x050C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0514(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_515[0x3];                                      // 0x0515(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x0518(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x051C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x0520(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToIdleTurn;                      // 0x0521(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToLocomotionTurn;                // 0x0522(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToMoving;                        // 0x0523(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToJumpApex;                      // 0x0524(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionMovingToIdle;                        // 0x0525(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpStartToJumpApex;                 // 0x0526(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpApexToJumpLoop;                  // 0x0527(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToIdle;                // 0x0528(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionLocomotionTurnToMoving;              // 0x0529(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToMoving;                    // 0x052A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleTurnToIdle;                      // 0x052B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionJumpLoopToJumpLand;                  // 0x052C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIsBeingHeldToChickenChuck;           // 0x052D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52E[0x2];                                      // 0x052E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShouldExitJump_SpeedThreshold;                     // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SpeedThreshold;                     // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_SlowSpeedDivisor;                   // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_FastSpeedDivisor;                   // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_InterpSpeed;                        // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MinClamp;                           // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingPlayRate_MaxClamp;                           // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanDirection_SpeedThreshold;                      // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShouldLean_SpeedThreshold;                         // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterruptibleCurveValue_LargeThreshold;            // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_MovingThreshold;                             // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed_IdleThreshold;                               // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTurnTransition_SpeedThreshold;                 // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionTurnTransition_SpeedThreshold;           // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Nug">();
	}
	static class UFortAIFaunaAnimInstance_Nug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Nug>();
	}
};
#pragma pack(pop)
static_assert(alignof(UFortAIFaunaAnimInstance_Nug) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Nug");
static_assert(sizeof(UFortAIFaunaAnimInstance_Nug) == 0x000590, "Wrong size on UFortAIFaunaAnimInstance_Nug");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsBeingHeld) == 0x0004F0, "Member 'UFortAIFaunaAnimInstance_Nug::bIsBeingHeld' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsBeingThrown) == 0x0004F1, "Member 'UFortAIFaunaAnimInstance_Nug::bIsBeingThrown' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LowerBodyMaskAlpha) == 0x0004F4, "Member 'UFortAIFaunaAnimInstance_Nug::LowerBodyMaskAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bShouldExitJump) == 0x0004F8, "Member 'UFortAIFaunaAnimInstance_Nug::bShouldExitJump' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate) == 0x0004FC, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bShouldLean) == 0x000500, "Member 'UFortAIFaunaAnimInstance_Nug::bShouldLean' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LeanDirection) == 0x000504, "Member 'UFortAIFaunaAnimInstance_Nug::LeanDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bTurnAngleIsNegative) == 0x000508, "Member 'UFortAIFaunaAnimInstance_Nug::bTurnAngleIsNegative' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, InterruptibleCurveName) == 0x00050C, "Member 'UFortAIFaunaAnimInstance_Nug::InterruptibleCurveName' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIsIdleShuffleTurn) == 0x000514, "Member 'UFortAIFaunaAnimInstance_Nug::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleBodyBend) == 0x000518, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRate) == 0x00051C, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bIdleShuffleTurnDirection) == 0x000520, "Member 'UFortAIFaunaAnimInstance_Nug::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToIdleTurn) == 0x000521, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToIdleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToLocomotionTurn) == 0x000522, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToLocomotionTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToMoving) == 0x000523, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleToJumpApex) == 0x000524, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionMovingToIdle) == 0x000525, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionMovingToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpStartToJumpApex) == 0x000526, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpStartToJumpApex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpApexToJumpLoop) == 0x000527, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpApexToJumpLoop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionLocomotionTurnToIdle) == 0x000528, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionLocomotionTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionLocomotionTurnToMoving) == 0x000529, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionLocomotionTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleTurnToMoving) == 0x00052A, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleTurnToMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIdleTurnToIdle) == 0x00052B, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIdleTurnToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionJumpLoopToJumpLand) == 0x00052C, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionJumpLoopToJumpLand' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, bCanTransitionIsBeingHeldToChickenChuck) == 0x00052D, "Member 'UFortAIFaunaAnimInstance_Nug::bCanTransitionIsBeingHeldToChickenChuck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, ShouldExitJump_SpeedThreshold) == 0x000530, "Member 'UFortAIFaunaAnimInstance_Nug::ShouldExitJump_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_SpeedThreshold) == 0x000534, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_SlowSpeedDivisor) == 0x000538, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_SlowSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_FastSpeedDivisor) == 0x00053C, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_FastSpeedDivisor' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_InterpSpeed) == 0x000540, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_MinClamp) == 0x000544, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_MinClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, MovingPlayRate_MaxClamp) == 0x000548, "Member 'UFortAIFaunaAnimInstance_Nug::MovingPlayRate_MaxClamp' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LeanDirection_SpeedThreshold) == 0x00054C, "Member 'UFortAIFaunaAnimInstance_Nug::LeanDirection_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, ShouldLean_SpeedThreshold) == 0x000550, "Member 'UFortAIFaunaAnimInstance_Nug::ShouldLean_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, InterruptibleCurveValue_LargeThreshold) == 0x000554, "Member 'UFortAIFaunaAnimInstance_Nug::InterruptibleCurveValue_LargeThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, Speed_MovingThreshold) == 0x000558, "Member 'UFortAIFaunaAnimInstance_Nug::Speed_MovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, Speed_IdleThreshold) == 0x00055C, "Member 'UFortAIFaunaAnimInstance_Nug::Speed_IdleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleTurnTransition_SpeedThreshold) == 0x000560, "Member 'UFortAIFaunaAnimInstance_Nug::IdleTurnTransition_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, LocomotionTurnTransition_SpeedThreshold) == 0x000564, "Member 'UFortAIFaunaAnimInstance_Nug::LocomotionTurnTransition_SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleBodyBendMultiplier) == 0x000568, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleTurnThreshold) == 0x00056C, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShuffleTurnDirectionThreshold) == 0x000570, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateInRangeA) == 0x000574, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateInRangeB) == 0x000578, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateOutRangeA) == 0x00057C, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug, IdleShufflePlayRateOutRangeB) == 0x000580, "Member 'UFortAIFaunaAnimInstance_Nug::IdleShufflePlayRateOutRangeB' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Nug_Hitchhiker
// 0x0000 (0x0590 - 0x0590)
class UFortAIFaunaAnimInstance_Nug_Hitchhiker final : public UFortAIFaunaAnimInstance_Nug
{
public:
	bool                                          bIsSwimming;                                       // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x0589(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x058A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHitchhiked;                                     // 0x058B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Nug_Hitchhiker">();
	}
	static class UFortAIFaunaAnimInstance_Nug_Hitchhiker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Nug_Hitchhiker>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Nug_Hitchhiker) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Nug_Hitchhiker");
static_assert(sizeof(UFortAIFaunaAnimInstance_Nug_Hitchhiker) == 0x000590, "Wrong size on UFortAIFaunaAnimInstance_Nug_Hitchhiker");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsSwimming) == 0x000588, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsSwimming' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsInTractorBeam) == 0x000589, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsFloating) == 0x00058A, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Nug_Hitchhiker, bIsHitchhiked) == 0x00058B, "Member 'UFortAIFaunaAnimInstance_Nug_Hitchhiker::bIsHitchhiked' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Robert
// 0x0090 (0x0580 - 0x04F0)
class UFortAIFaunaAnimInstance_Robert final : public UFortAIFaunaAnimInstance
{
public:
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAIPawn*                            AIPawn;                                            // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleStartTurn;                                    // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHeadTiltDownAdditive;                       // 0x0501(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFullBodyInPlace;                                // 0x0502(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_503[0x1];                                      // 0x0503(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionPoseAdditiveAlpha;                       // 0x0504(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIdleShuffleTurn;                                // 0x0508(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_509[0x3];                                      // 0x0509(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x050C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x0510(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x0514(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFloating;                                       // 0x0515(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTractorBeam;                                  // 0x0516(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookAtAdditiveTurnAlpha;                          // 0x0517(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnDirection;                                    // 0x0518(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_519[0x3];                                      // 0x0519(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PawnIDScale;                                       // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeadTiltDownAdditiveFrequenceySeconds;             // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceFullBodyTransition;                           // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionPoseAdditiveAlphaInterpRate;             // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleStartTurnInterruptibleThreshold;               // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtAlphaThreshold;                              // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMovingThreshold;                              // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnDirectionThreshold;                            // 0x0538(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x0540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Idle;                          // 0x0558(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_TurnIdle;                          // 0x0559(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnIdle_Moving;                        // 0x055A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_TurnIdle;                    // 0x055B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Idle_Moving;                            // 0x055C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_Idle;                            // 0x055D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_TurnMoving_Moving;                      // 0x055E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Moving_TurnMoving;                      // 0x055F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Swimming_Fall;                          // 0x0560(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Land_Idle;                              // 0x0561(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_JumpStart_Apex;                         // 0x0562(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Idle;                              // 0x0563(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_Fall_Moving;                            // 0x0564(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimIdle_SwimLoco;                      // 0x0565(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimLoco_SwimIdle;                      // 0x0566(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimIdle;                      // 0x0567(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStateRule_SwimTurn_SwimLoco;                      // 0x0568(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimRule_NegativeTurnAngle;                       // 0x0569(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56A[0x2];                                      // 0x056A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterruptibleMaxCheck;                             // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedStopTransition;                               // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedIdleMoveTransition;                           // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToMoveMin;                                    // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StateTimeFromEndThreshold;                         // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float CalculateLocomotionPoseAdditiveAlpha();
	bool DetermineEnableHeadTiltDownAdditive();
	bool DetermineIdleStartTurn();
	bool DetermineIsFullBodyInPlace();
	void UpdateEnableHeadTiltDownAdditive();
	void UpdateIdleStartTurn();
	void UpdateIsFullBodyInPlace();
	void UpdateLocomotionPoseAdditiveAlpha();
	void UpdateStateVariables();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Robert">();
	}
	static class UFortAIFaunaAnimInstance_Robert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Robert>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Robert) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Robert");
static_assert(sizeof(UFortAIFaunaAnimInstance_Robert) == 0x000580, "Wrong size on UFortAIFaunaAnimInstance_Robert");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, AIPawn) == 0x0004F8, "Member 'UFortAIFaunaAnimInstance_Robert::AIPawn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIdleStartTurn) == 0x000500, "Member 'UFortAIFaunaAnimInstance_Robert::bIdleStartTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bEnableHeadTiltDownAdditive) == 0x000501, "Member 'UFortAIFaunaAnimInstance_Robert::bEnableHeadTiltDownAdditive' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsFullBodyInPlace) == 0x000502, "Member 'UFortAIFaunaAnimInstance_Robert::bIsFullBodyInPlace' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPoseAdditiveAlpha) == 0x000504, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPoseAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsIdleShuffleTurn) == 0x000508, "Member 'UFortAIFaunaAnimInstance_Robert::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleBodyBend) == 0x00050C, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRate) == 0x000510, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIdleShuffleTurnDirection) == 0x000514, "Member 'UFortAIFaunaAnimInstance_Robert::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsFloating) == 0x000515, "Member 'UFortAIFaunaAnimInstance_Robert::bIsFloating' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bIsInTractorBeam) == 0x000516, "Member 'UFortAIFaunaAnimInstance_Robert::bIsInTractorBeam' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bLookAtAdditiveTurnAlpha) == 0x000517, "Member 'UFortAIFaunaAnimInstance_Robert::bLookAtAdditiveTurnAlpha' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bTurnDirection) == 0x000518, "Member 'UFortAIFaunaAnimInstance_Robert::bTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, PawnIDScale) == 0x00051C, "Member 'UFortAIFaunaAnimInstance_Robert::PawnIDScale' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, HeadTiltDownAdditiveFrequenceySeconds) == 0x000520, "Member 'UFortAIFaunaAnimInstance_Robert::HeadTiltDownAdditiveFrequenceySeconds' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, ForceFullBodyTransition) == 0x000524, "Member 'UFortAIFaunaAnimInstance_Robert::ForceFullBodyTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LocomotionPoseAdditiveAlphaInterpRate) == 0x000528, "Member 'UFortAIFaunaAnimInstance_Robert::LocomotionPoseAdditiveAlphaInterpRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleStartTurnInterruptibleThreshold) == 0x00052C, "Member 'UFortAIFaunaAnimInstance_Robert::IdleStartTurnInterruptibleThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, LookAtAlphaThreshold) == 0x000530, "Member 'UFortAIFaunaAnimInstance_Robert::LookAtAlphaThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedMovingThreshold) == 0x000534, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedMovingThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, TurnDirectionThreshold) == 0x000538, "Member 'UFortAIFaunaAnimInstance_Robert::TurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleBodyBendMultiplier) == 0x00053C, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleTurnThreshold) == 0x000540, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShuffleTurnDirectionThreshold) == 0x000544, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateInRangeA) == 0x000548, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateInRangeB) == 0x00054C, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateOutRangeA) == 0x000550, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, IdleShufflePlayRateOutRangeB) == 0x000554, "Member 'UFortAIFaunaAnimInstance_Robert::IdleShufflePlayRateOutRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnIdle_Idle) == 0x000558, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnIdle_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Idle_TurnIdle) == 0x000559, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Idle_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnIdle_Moving) == 0x00055A, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnIdle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnMoving_TurnIdle) == 0x00055B, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnMoving_TurnIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Idle_Moving) == 0x00055C, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Idle_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Moving_Idle) == 0x00055D, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Moving_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_TurnMoving_Moving) == 0x00055E, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_TurnMoving_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Moving_TurnMoving) == 0x00055F, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Moving_TurnMoving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Swimming_Fall) == 0x000560, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Swimming_Fall' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Land_Idle) == 0x000561, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Land_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_JumpStart_Apex) == 0x000562, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_JumpStart_Apex' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Fall_Idle) == 0x000563, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Fall_Idle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_Fall_Moving) == 0x000564, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_Fall_Moving' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimIdle_SwimLoco) == 0x000565, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimIdle_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimLoco_SwimIdle) == 0x000566, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimLoco_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimTurn_SwimIdle) == 0x000567, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimTurn_SwimIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bStateRule_SwimTurn_SwimLoco) == 0x000568, "Member 'UFortAIFaunaAnimInstance_Robert::bStateRule_SwimTurn_SwimLoco' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, bAnimRule_NegativeTurnAngle) == 0x000569, "Member 'UFortAIFaunaAnimInstance_Robert::bAnimRule_NegativeTurnAngle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, InterruptibleMaxCheck) == 0x00056C, "Member 'UFortAIFaunaAnimInstance_Robert::InterruptibleMaxCheck' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedStopTransition) == 0x000570, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedStopTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedIdleMoveTransition) == 0x000574, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedIdleMoveTransition' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, SpeedToMoveMin) == 0x000578, "Member 'UFortAIFaunaAnimInstance_Robert::SpeedToMoveMin' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Robert, StateTimeFromEndThreshold) == 0x00057C, "Member 'UFortAIFaunaAnimInstance_Robert::StateTimeFromEndThreshold' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaAnimInstance_Smackie
// 0x0040 (0x0530 - 0x04F0)
class UFortAIFaunaAnimInstance_Smackie final : public UFortAIFaunaAnimInstance
{
public:
	bool                                          bIsIdleShuffleTurn;                                // 0x04F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F1[0x3];                                      // 0x04F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleShuffleBodyBend;                               // 0x04F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRate;                               // 0x04F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleShuffleTurnDirection;                         // 0x04FC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionIdleToHop;                           // 0x04FD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionHopToIdle;                           // 0x04FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToIdle;                          // 0x04FF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTransitionFallToHop;                           // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedThreshold;                                    // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleBodyBendMultiplier;                     // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnThreshold;                          // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShuffleTurnDirectionThreshold;                 // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeA;                       // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateInRangeB;                       // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeA;                      // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleShufflePlayRateOutRangeB;                      // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_524[0xC];                                      // 0x0524(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaAnimInstance_Smackie">();
	}
	static class UFortAIFaunaAnimInstance_Smackie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaAnimInstance_Smackie>();
	}
};
static_assert(alignof(UFortAIFaunaAnimInstance_Smackie) == 0x000010, "Wrong alignment on UFortAIFaunaAnimInstance_Smackie");
static_assert(sizeof(UFortAIFaunaAnimInstance_Smackie) == 0x000530, "Wrong size on UFortAIFaunaAnimInstance_Smackie");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bIsIdleShuffleTurn) == 0x0004F0, "Member 'UFortAIFaunaAnimInstance_Smackie::bIsIdleShuffleTurn' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleBodyBend) == 0x0004F4, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleBodyBend' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRate) == 0x0004F8, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRate' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bIdleShuffleTurnDirection) == 0x0004FC, "Member 'UFortAIFaunaAnimInstance_Smackie::bIdleShuffleTurnDirection' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionIdleToHop) == 0x0004FD, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionIdleToHop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionHopToIdle) == 0x0004FE, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionHopToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionFallToIdle) == 0x0004FF, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionFallToIdle' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, bCanTransitionFallToHop) == 0x000500, "Member 'UFortAIFaunaAnimInstance_Smackie::bCanTransitionFallToHop' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, SpeedThreshold) == 0x000504, "Member 'UFortAIFaunaAnimInstance_Smackie::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleBodyBendMultiplier) == 0x000508, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleBodyBendMultiplier' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleTurnThreshold) == 0x00050C, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleTurnThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShuffleTurnDirectionThreshold) == 0x000510, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShuffleTurnDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateInRangeA) == 0x000514, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateInRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateInRangeB) == 0x000518, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateInRangeB' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateOutRangeA) == 0x00051C, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateOutRangeA' has a wrong offset!");
static_assert(offsetof(UFortAIFaunaAnimInstance_Smackie, IdleShufflePlayRateOutRangeB) == 0x000520, "Member 'UFortAIFaunaAnimInstance_Smackie::IdleShufflePlayRateOutRangeB' has a wrong offset!");

// Class IrwinRuntime.FortAIFaunaLayerAnimInstance
// 0x0000 (0x03C0 - 0x03C0)
class UFortAIFaunaLayerAnimInstance final : public UFortBaseLayerAnimInstance
{
public:
	class UAnimInstance*                          MainAnimBP;                                        // 0x03B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAIFaunaLayerAnimInstance">();
	}
	static class UFortAIFaunaLayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAIFaunaLayerAnimInstance>();
	}
};
static_assert(alignof(UFortAIFaunaLayerAnimInstance) == 0x000010, "Wrong alignment on UFortAIFaunaLayerAnimInstance");
static_assert(sizeof(UFortAIFaunaLayerAnimInstance) == 0x0003C0, "Wrong size on UFortAIFaunaLayerAnimInstance");
static_assert(offsetof(UFortAIFaunaLayerAnimInstance, MainAnimBP) == 0x0003B8, "Member 'UFortAIFaunaLayerAnimInstance::MainAnimBP' has a wrong offset!");

}

