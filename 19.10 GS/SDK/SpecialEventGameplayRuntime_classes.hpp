#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SpecialEventGameplayRuntime

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "FortniteGame_structs.hpp"
#include "FortniteGame_classes.hpp"
#include "SpecialEventGameplayRuntime_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class SpecialEventGameplayRuntime.FortCharacterMovementMutatorComponent
// 0x0620 (0x06D0 - 0x00B0)
class UFortCharacterMovementMutatorComponent final : public UActorComponent
{
public:
	class ACharacter*                             CharacterOwner;                                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortMovementComp_CharacterAthena*      MovementComponent;                                 // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFortMovementComp_CharacterAthena*      CDOMovementComponent;                              // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BuffetBubblesMoveToBoxSpeed;                       // 0x00D8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesRelativeVelocityInterpSpeed;          // 0x0100(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesLocationInterpSpeed;                  // 0x0128(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesRotationInterpSpeed;                  // 0x0150(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesMinRelativeX;                         // 0x0178(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesMaxRelativeX;                         // 0x01A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesMinRelativeY;                         // 0x01C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesMaxRelativeY;                         // 0x01F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesMinRelativeZ;                         // 0x0218(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesMaxRelativeZ;                         // 0x0240(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               BuffetBubblesRotationRate;                         // 0x0268(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BuffetBubblesMaxAcceleration;                      // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesMaxRelativeSpeed;                     // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesRelativeDeceleration;                 // 0x02C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetBubblesSphereRadius;                         // 0x02F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 BuffetBubblesFollowActor;                          // 0x0318(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BuffetBubblesInitialFollowBoxOffsetPercent;        // 0x0320(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x74];                                     // 0x032C(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuffetBubblesReplicatedData           BuffetBubblesReplicatedData;                       // 0x03A0(0x0040)(Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x150];                                    // 0x03E0(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BuffetBubblesIntroSpeed;                           // 0x0530(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BuffetBubblesIntroTargetTransform;                 // 0x0560(0x0030)(Net, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetFlyingMaxPitchDegrees;                       // 0x0590(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetFlyingMaxSpeed;                              // 0x05B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetFlyingVelocityDirectionInterpSpeed;          // 0x05E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               BuffetFlyingRotationRate;                          // 0x0608(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BuffetFlyingMaxSpeedOverride;                      // 0x0614(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BuffetFlyingMaxSpeedInterpSpeed;                   // 0x0618(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuffetFlyingVelocityDirectionInterpSpeedOverride;  // 0x0620(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_624[0x4];                                      // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         BuffetFlyingRicochetSphereSize;                    // 0x0628(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetFlyingRicochetRotationDuration;              // 0x0650(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FScalableFloat                         BuffetFlyingRicochetControlRotationInterpSpeed;    // 0x0678(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A0[0x20];                                     // 0x06A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuffetFlyingRicochetReplicatedData    BuffetFlyingRicochetReplicatedData;                // 0x06C0(0x0010)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode);
	void OnRep_BuffetBubblesFollowActor();
	void OnRep_BuffetFlyingRicochetReplicatedData();
	void OverrideBuffetFlyingMaxSpeed(const float Value, const bool bAsMultiplier, const float InterpSpeed);
	void OverrideBuffetFlyingVelocityDirectionInterpSpeed(const float Value, const bool bAsMultiplier);
	void SetBuffetBubblesFollowActor(class AActor* Actor);
	void SetBuffetBubblesInitialFollowBoxOffsetPercent(const struct FVector& BoxOffsetPercent);
	void SetBuffetBubblesIntroTargetTransform(const struct FTransform& Transform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterMovementMutatorComponent">();
	}
	static class UFortCharacterMovementMutatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCharacterMovementMutatorComponent>();
	}
};
static_assert(alignof(UFortCharacterMovementMutatorComponent) == 0x000010, "Wrong alignment on UFortCharacterMovementMutatorComponent");
static_assert(sizeof(UFortCharacterMovementMutatorComponent) == 0x0006D0, "Wrong size on UFortCharacterMovementMutatorComponent");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, CharacterOwner) == 0x0000B0, "Member 'UFortCharacterMovementMutatorComponent::CharacterOwner' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, MovementComponent) == 0x0000B8, "Member 'UFortCharacterMovementMutatorComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, CDOMovementComponent) == 0x0000C0, "Member 'UFortCharacterMovementMutatorComponent::CDOMovementComponent' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMoveToBoxSpeed) == 0x0000D8, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMoveToBoxSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesRelativeVelocityInterpSpeed) == 0x000100, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesRelativeVelocityInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesLocationInterpSpeed) == 0x000128, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesLocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesRotationInterpSpeed) == 0x000150, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMinRelativeX) == 0x000178, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMinRelativeX' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMaxRelativeX) == 0x0001A0, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMaxRelativeX' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMinRelativeY) == 0x0001C8, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMinRelativeY' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMaxRelativeY) == 0x0001F0, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMaxRelativeY' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMinRelativeZ) == 0x000218, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMinRelativeZ' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMaxRelativeZ) == 0x000240, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMaxRelativeZ' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesRotationRate) == 0x000268, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesRotationRate' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMaxAcceleration) == 0x000278, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesMaxRelativeSpeed) == 0x0002A0, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesMaxRelativeSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesRelativeDeceleration) == 0x0002C8, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesRelativeDeceleration' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesSphereRadius) == 0x0002F0, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesSphereRadius' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesFollowActor) == 0x000318, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesFollowActor' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesInitialFollowBoxOffsetPercent) == 0x000320, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesInitialFollowBoxOffsetPercent' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesReplicatedData) == 0x0003A0, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesReplicatedData' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesIntroSpeed) == 0x000530, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesIntroSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetBubblesIntroTargetTransform) == 0x000560, "Member 'UFortCharacterMovementMutatorComponent::BuffetBubblesIntroTargetTransform' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingMaxPitchDegrees) == 0x000590, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingMaxPitchDegrees' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingMaxSpeed) == 0x0005B8, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingMaxSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingVelocityDirectionInterpSpeed) == 0x0005E0, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingVelocityDirectionInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingRotationRate) == 0x000608, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingRotationRate' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingMaxSpeedOverride) == 0x000614, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingMaxSpeedOverride' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingMaxSpeedInterpSpeed) == 0x000618, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingMaxSpeedInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingVelocityDirectionInterpSpeedOverride) == 0x000620, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingVelocityDirectionInterpSpeedOverride' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingRicochetSphereSize) == 0x000628, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingRicochetSphereSize' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingRicochetRotationDuration) == 0x000650, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingRicochetRotationDuration' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingRicochetControlRotationInterpSpeed) == 0x000678, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingRicochetControlRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UFortCharacterMovementMutatorComponent, BuffetFlyingRicochetReplicatedData) == 0x0006C0, "Member 'UFortCharacterMovementMutatorComponent::BuffetFlyingRicochetReplicatedData' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortCheatManager_FakeKillRelevancy
// 0x0000 (0x0038 - 0x0038)
class UFortCheatManager_FakeKillRelevancy final : public UFortCheatManager_Coupled
{
public:
	void FakeKillRelevancyDebug(const float TextScale);
	void FakeKillRelevancyReset();
	void FakeKillRelevancySetUpPhase(const int32 MaxPlayersRemaining, const class FString& ReasonGameplayTagString, const int32 NumWaves, const float RelevancyDelay);
	void FakeKillRelevancyStartNextWave();
	void FakeKillRelevancyTestAlgorithm(const int32 NumPlayers, const class FString& MaxPlayersRemainingAfterPhases, const int32 MinSquadSize, const int32 MaxSquadSize, const int32 Iterations, const int32 LogVerbosity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCheatManager_FakeKillRelevancy">();
	}
	static class UFortCheatManager_FakeKillRelevancy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCheatManager_FakeKillRelevancy>();
	}
};
static_assert(alignof(UFortCheatManager_FakeKillRelevancy) == 0x000008, "Wrong alignment on UFortCheatManager_FakeKillRelevancy");
static_assert(sizeof(UFortCheatManager_FakeKillRelevancy) == 0x000038, "Wrong size on UFortCheatManager_FakeKillRelevancy");

// Class SpecialEventGameplayRuntime.FortControllerComponent_FakeKillRelevancy
// 0x0188 (0x0238 - 0x00B0)
class UFortControllerComponent_FakeKillRelevancy final : public UFortControllerComponent
{
public:
	struct FFakeKillRelevancyPlayerDataArray      PlayerDataArray;                                   // 0x00B0(0x0120)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class AFortPlayerStateAthena*, EFakeKillRelevancyPlayerKillStep> ClientPlayerStateKillStepMap;                      // 0x01D0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         ResetCounter;                                      // 0x0220(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerStateAthena*>         DebugSupergroupPlayerStates;                       // 0x0228(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void CancelKillEffectsOnClient(const TArray<class AFortPlayerStateAthena*>& PlayerStates);
	void CancelKillEffectsOnServer();
	void OnKillEffectsPlayed(const class AFortPlayerStateAthena* PlayerState);
	void OnRep_ResetCounter();
	void PlayKillEffects(const struct FFakeKillRelevancyPlayerDataEntry& FakeKillData, const float RelevancyDelay);
	void ResetRelevancy();

	struct FVector GetDeathLocation(const class AFortPlayerStateAthena* PlayerState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortControllerComponent_FakeKillRelevancy">();
	}
	static class UFortControllerComponent_FakeKillRelevancy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortControllerComponent_FakeKillRelevancy>();
	}
};
static_assert(alignof(UFortControllerComponent_FakeKillRelevancy) == 0x000008, "Wrong alignment on UFortControllerComponent_FakeKillRelevancy");
static_assert(sizeof(UFortControllerComponent_FakeKillRelevancy) == 0x000238, "Wrong size on UFortControllerComponent_FakeKillRelevancy");
static_assert(offsetof(UFortControllerComponent_FakeKillRelevancy, PlayerDataArray) == 0x0000B0, "Member 'UFortControllerComponent_FakeKillRelevancy::PlayerDataArray' has a wrong offset!");
static_assert(offsetof(UFortControllerComponent_FakeKillRelevancy, ClientPlayerStateKillStepMap) == 0x0001D0, "Member 'UFortControllerComponent_FakeKillRelevancy::ClientPlayerStateKillStepMap' has a wrong offset!");
static_assert(offsetof(UFortControllerComponent_FakeKillRelevancy, ResetCounter) == 0x000220, "Member 'UFortControllerComponent_FakeKillRelevancy::ResetCounter' has a wrong offset!");
static_assert(offsetof(UFortControllerComponent_FakeKillRelevancy, DebugSupergroupPlayerStates) == 0x000228, "Member 'UFortControllerComponent_FakeKillRelevancy::DebugSupergroupPlayerStates' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortAthenaMutator_FakeKillRelevancy
// 0x0060 (0x0410 - 0x03B0)
class AFortAthenaMutator_FakeKillRelevancy final : public AFortAthenaMutator_SpecialRelevancy
{
public:
	TSubclassOf<class UFortControllerComponent_FakeKillRelevancy> FakeKillControllerComponentClass;                  // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFakeKillRelevancyPhaseData>    RelevancyPhaseDataArray;                           // 0x03B8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         PhaseNum;                                          // 0x03C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CC[0x44];                                     // 0x03CC(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndWave(const int32 EndPhaseNum, const int32 WaveNum);
	void ResetRelevancy();
	void SetUpKillPhase(const int32 MaxPlayersRemaining, const struct FGameplayTag& Reason, const int32 NumWaves, const float RelevancyDelay);
	void StartNextKillWave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaMutator_FakeKillRelevancy">();
	}
	static class AFortAthenaMutator_FakeKillRelevancy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaMutator_FakeKillRelevancy>();
	}
};
static_assert(alignof(AFortAthenaMutator_FakeKillRelevancy) == 0x000008, "Wrong alignment on AFortAthenaMutator_FakeKillRelevancy");
static_assert(sizeof(AFortAthenaMutator_FakeKillRelevancy) == 0x000410, "Wrong size on AFortAthenaMutator_FakeKillRelevancy");
static_assert(offsetof(AFortAthenaMutator_FakeKillRelevancy, FakeKillControllerComponentClass) == 0x0003B0, "Member 'AFortAthenaMutator_FakeKillRelevancy::FakeKillControllerComponentClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_FakeKillRelevancy, RelevancyPhaseDataArray) == 0x0003B8, "Member 'AFortAthenaMutator_FakeKillRelevancy::RelevancyPhaseDataArray' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_FakeKillRelevancy, PhaseNum) == 0x0003C8, "Member 'AFortAthenaMutator_FakeKillRelevancy::PhaseNum' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortAthenaMutator_LoadGameFeature
// 0x0010 (0x02D8 - 0x02C8)
class AFortAthenaMutator_LoadGameFeature final : public AFortAthenaMutator
{
public:
	class FString                                 GameFeatureToLoad;                                 // 0x02C8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlaylistDataReady(class AFortGameStateAthena* GameState, const class UFortPlaylist* Playlist, const struct FGameplayTagContainer& PlaylistContextTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaMutator_LoadGameFeature">();
	}
	static class AFortAthenaMutator_LoadGameFeature* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaMutator_LoadGameFeature>();
	}
};
static_assert(alignof(AFortAthenaMutator_LoadGameFeature) == 0x000008, "Wrong alignment on AFortAthenaMutator_LoadGameFeature");
static_assert(sizeof(AFortAthenaMutator_LoadGameFeature) == 0x0002D8, "Wrong size on AFortAthenaMutator_LoadGameFeature");
static_assert(offsetof(AFortAthenaMutator_LoadGameFeature, GameFeatureToLoad) == 0x0002C8, "Member 'AFortAthenaMutator_LoadGameFeature::GameFeatureToLoad' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortAthenaMutator_RemoveGameFeatures
// 0x0010 (0x02D8 - 0x02C8)
class AFortAthenaMutator_RemoveGameFeatures final : public AFortAthenaMutator
{
public:
	TArray<class FString>                         AllowedGameFeatures;                               // 0x02C8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnPlaylistDataReady(class AFortGameStateAthena* GameState, const class UFortPlaylist* Playlist, const struct FGameplayTagContainer& PlaylistContextTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaMutator_RemoveGameFeatures">();
	}
	static class AFortAthenaMutator_RemoveGameFeatures* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaMutator_RemoveGameFeatures>();
	}
};
static_assert(alignof(AFortAthenaMutator_RemoveGameFeatures) == 0x000008, "Wrong alignment on AFortAthenaMutator_RemoveGameFeatures");
static_assert(sizeof(AFortAthenaMutator_RemoveGameFeatures) == 0x0002D8, "Wrong size on AFortAthenaMutator_RemoveGameFeatures");
static_assert(offsetof(AFortAthenaMutator_RemoveGameFeatures, AllowedGameFeatures) == 0x0002C8, "Member 'AFortAthenaMutator_RemoveGameFeatures::AllowedGameFeatures' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortCheatManager_SpecialEvent
// 0x0000 (0x0038 - 0x0038)
class UFortCheatManager_SpecialEvent final : public UFortCheatManager_Coupled
{
public:
	void AddCSVEvent(const class FString& CSVEventName);
	void AutobalanceTargetScore();
	void ChangeWinCondition(float NewGoalScore);
	void CloseParachutes();
	void PauseWinCondition(bool bLockScores);
	void PlacePlayersInAircraft();
	void ResetMatchTimeToPrevious();
	void ResetSpecialEventAircraft();
	void ResetWinCondition();
	void ResetWinConditionProgressToZero();
	void ResumeWinCondition();
	void SendToNightNight();
	void SetDestroyVehiclesInStorm(bool bDestroyVehiclesInStorm);
	void SetIsSimulatingDamage(bool bIsSimulating);
	void SetLockingOnFocalPoint(bool bInLockingOnFocalPoint);
	void SetMatchTime(int32 NewMatchTime);
	void SetReturnToMainMenuDelay(float MinDelayReturnToMainMenu, float MaxDelayReturnToMainMenu);
	void ShrinkSafeZone();
	void SpecialEventClearAdditionalViewpoint();
	void SpecialEventSetAdditionalViewpoint(float X, float Y, float Z);
	void StartEventScript(int32 InStartingIndex);
	void TeleportAllPlayers(int32 SafeZoneIndex);
	void ToggleDisableParachutes(bool bIsDisabled);
	void UnloadTerrainMaps(class FName MapTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCheatManager_SpecialEvent">();
	}
	static class UFortCheatManager_SpecialEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortCheatManager_SpecialEvent>();
	}
};
static_assert(alignof(UFortCheatManager_SpecialEvent) == 0x000008, "Wrong alignment on UFortCheatManager_SpecialEvent");
static_assert(sizeof(UFortCheatManager_SpecialEvent) == 0x000038, "Wrong size on UFortCheatManager_SpecialEvent");

// Class SpecialEventGameplayRuntime.FortAthenaMutator_SpecialEvent
// 0x0368 (0x0630 - 0x02C8)
class AFortAthenaMutator_SpecialEvent final : public AFortAthenaMutator
{
public:
	TMulticastInlineDelegate<void()>              TeleportAllPlayersFinished;                        // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AFortPlayerPawnAthena* NewPawn)> OnPawnLoaded;                                      // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AFortPlayerControllerAthena* NewPlayer)> OnInitController;                                  // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnResumeGame;                                      // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FSpecialClientEvent& ClientEventData)> OnSpecialClientEvent;                              // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnClientInitialLoadingFinished;                    // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x58];                                     // 0x0328(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayersAreInvincible;                             // 0x0380(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x27];                                     // 0x0381(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumScoreBumpForAutomadeGoal;                   // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ScoreBrackets;                                     // 0x03B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnforceInfiniteSafeZonePhase;                     // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WarmupIslandPlayerStartTag;                        // 0x03C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowInventoryOpen;                               // 0x03CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CD[0x3];                                      // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         bAllowFullScreenMap;                               // 0x03D0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldClearFrontEndMapMarkers;                    // 0x03F8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBlockTeamIndicators;                              // 0x03F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FA[0x6];                                      // 0x03FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  UIToHideDuringSpecialEvent;                        // 0x0400(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  UIToHideWhenInInfiniteWarmup;                      // 0x0420(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ClientEventsThatUnhideHiddenWhileLoadingHUDElements; // 0x0440(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bForceGarbageCollectionAfterUnload;                // 0x0460(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullPurgeGC;                                      // 0x0461(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_462[0x6];                                      // 0x0462(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AFortAthenaAircraft*                    EventAircraft;                                     // 0x0468(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAircraftFlightInfo                    EventAircraftInfo;                                 // 0x0470(0x0028)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AFortAthenaAircraft>        EventAircraftClass;                                // 0x0498(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASpecialEventScript*                    ScriptActor;                                       // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableHUD;                                       // 0x04A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         GameResumed;                                       // 0x04A9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AA[0x2];                                      // 0x04AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AdditionalViewpoint;                               // 0x04AC(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bParachutesDisabled;                               // 0x04B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastCSVEventName;                                  // 0x04C0(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStreamBuildingFoundationsIn;                   // 0x04D0(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D1[0x3];                                      // 0x04D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AllPlayerTeleportedCount;                          // 0x04D4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFortDelayRTMMData                     DelayPlayersFromReturningToLobbyData;              // 0x04D8(0x0010)(Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   NamedWeightForContainerLootRoll;                   // 0x04E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeightForContainerLootRoll;                        // 0x04F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F4[0x24];                                     // 0x04F4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortSpecialEventEmoteData>     SpecialEventEmoteData;                             // 0x0518(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  BlockedNativeActions;                              // 0x0528(0x0020)(Edit, Net, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UInputComponent*                        SpecialEventsInputComponent;                       // 0x0548(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockingOnFocalPoint;                              // 0x0550(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFortSpecialEventOverrideParts> SpecialEventOverrideParts;                         // 0x0558(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FFortSpecialEventGEData                GameplayEffectToApplyOnSwapToDefault;              // 0x0568(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FUniqueNetIdRepl, int32>          OverridePartsArrayIndexMap;                        // 0x0578(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFortSpecialEventGEData>        GameplayEffectsToApplyOnLogin;                     // 0x05C8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSpecialEventMapData>           TerrainMapsToUnload;                               // 0x05D8(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnInstance, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x10];                                     // 0x05E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AFortPlayerControllerAthena*>    UnhandledPlayerControllers;                        // 0x05F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanToggleCursorModeInStasis;                      // 0x0608(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_609[0x7];                                      // 0x0609(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             ActorSpawnDelegateClasses;                         // 0x0610(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x10];                                     // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddClientCSVEvent(const class FString& CSVEventName);
	void AddCSVEvent(const class FString& CSVEventName, bool bShouldRepToClient);
	void AddToBlockedNativeActions(const struct FGameplayTagContainer& Actions, const bool bCancelAbilities);
	void AutobalanceTargetScore();
	void ChangeWinCondition(float NewGoalScore);
	void ClearAdditionalViewpoint();
	void ClearBlockedNativeActions();
	void CloseParachutes();
	void FlushUnhandledPlayerControllers();
	void ForceSafeZoneFinalLocation(const struct FVector& NewFinalLocation, float DefaultAircraftOffsetFromMidLine, float MinDefaultMidlineAngle, float MaxDefaultMidlineAngle);
	void JumpToSafeZonePhase(const struct FVector& PawnSpawnCenterLocation, float PawnSpawnMinDistance, float PawnSpawnMaxDistance);
	void NotifyClientsGameResumed();
	void OnActorPreSpawnInitialization(class AActor* Actor);
	void OnActorSpawned(class AActor* Actor);
	void OnAircraftEnteredDropZone(class AFortAthenaAircraft* FortAthenaAircraft);
	void OnAircraftExitedDropZone(class AFortAthenaAircraft* FortAthenaAircraft);
	void OnAircraftFlightEnded(class AFortAthenaAircraft* FortAthenaAircraft);
	void OnGamePhaseStepChanged(const TScriptInterface<class IFortSafeZoneInterface>& SafeZoneInterface, const EAthenaGamePhaseStep GamePhaseStep);
	void OnGameViewportActivationChanged(bool bHasFocus);
	void OnRep_AdditionalViewpoint();
	void OnRep_Aircraft();
	void OnRep_AllPlayerTeleportedCount();
	void OnRep_bCanStreamBuildingFoundationsIn();
	void OnRep_bDisableHUD();
	void OnRep_bLockingOnFocalPoint();
	void OnRep_bPlayersAreInvincible();
	void OnRep_DelayPlayersFromReturningToLobbyData();
	void OnRep_GameResumed();
	void OnRep_LastCSVEventName();
	void OnRep_TerrainMapsToUnload();
	void OnWarmUpTeleportComplete(class AFortPlayerPawn* PlayerPawn);
	void PauseStormDamage(bool bPause);
	void PauseStormProgression(bool bPause);
	void PauseSupplyDrops(bool bPause);
	void PauseWinCondition(bool bLockScores);
	void PlacePlayersInAircraft();
	void PopSpecialEventEmoteInputComponent();
	void PushSpecialEventEmoteInputComponent();
	void RemoveFromBlockedNativeActions(const struct FGameplayTagContainer& Actions);
	void ResetMatchTimeToPrevious();
	void ResetSafeZoneOverrideAfterEvent(int32 MinResetSafeZoneIndex, float MinDelayReturnToMainMenu, float MaxDelayReturnToMainMenu);
	void ResetSpecialEventAircraft();
	void ResetWinCondition();
	void ResetWinConditionProgressToZero();
	void ResumeWinCondition();
	void SendToNightNight();
	void SetAdditionalViewpoint(const struct FVector& WorldLocation);
	void SetCanStreamBuildingFoundationsIn(bool bEnable);
	void SetDestroyVehiclesInStorm(bool bDestroyVehiclesInStorm);
	void SetIsSimulatingDamage(bool bIsSimulating);
	void SetLockingOnFocalPoint(bool bInLockingOnFocalPoint);
	void SetMatchTime(int32 NewMatchTime);
	void SetNamedWeightForContainerLootRoll(const class FName WeightName);
	void SetReturnToMainMenuDelay(float MinDelayReturnToMainMenu, float MaxDelayReturnToMainMenu);
	void SetWeightForContainerLootRoll(const float Weight);
	void ShrinkSafeZone();
	void StartSafeZoneOverrideForEvent(int32 SafeZoneIndexForEvent);
	void SwapBodyParts(const int32 ArrayIndex, class AFortPlayerController* FortPC);
	void TeleportAllPlayers(const struct FGameplayTagContainer& EventTags, int32 TeleportsPerFrame, int32 SafeZoneIndex);
	void ToggleAllPlayersInvincibility(bool bInvincible);
	void ToggleDisableParachutes(bool bDisable);
	void ToggleDisableWeapons(bool bDisableWeapons);
	void ToggleHUDs(bool bHide);
	void UnloadTerrainMaps(const struct FGameplayTag& MapTag);
	void WarmUpIslandUpdated();

	bool GetHasInfiniteSafeZonePhase() const;
	class ASpecialEventScript* GetScript() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAthenaMutator_SpecialEvent">();
	}
	static class AFortAthenaMutator_SpecialEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortAthenaMutator_SpecialEvent>();
	}
};
static_assert(alignof(AFortAthenaMutator_SpecialEvent) == 0x000008, "Wrong alignment on AFortAthenaMutator_SpecialEvent");
static_assert(sizeof(AFortAthenaMutator_SpecialEvent) == 0x000630, "Wrong size on AFortAthenaMutator_SpecialEvent");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, TeleportAllPlayersFinished) == 0x0002C8, "Member 'AFortAthenaMutator_SpecialEvent::TeleportAllPlayersFinished' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, OnPawnLoaded) == 0x0002D8, "Member 'AFortAthenaMutator_SpecialEvent::OnPawnLoaded' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, OnInitController) == 0x0002E8, "Member 'AFortAthenaMutator_SpecialEvent::OnInitController' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, OnResumeGame) == 0x0002F8, "Member 'AFortAthenaMutator_SpecialEvent::OnResumeGame' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, OnSpecialClientEvent) == 0x000308, "Member 'AFortAthenaMutator_SpecialEvent::OnSpecialClientEvent' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, OnClientInitialLoadingFinished) == 0x000318, "Member 'AFortAthenaMutator_SpecialEvent::OnClientInitialLoadingFinished' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bPlayersAreInvincible) == 0x000380, "Member 'AFortAthenaMutator_SpecialEvent::bPlayersAreInvincible' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, MinimumScoreBumpForAutomadeGoal) == 0x0003A8, "Member 'AFortAthenaMutator_SpecialEvent::MinimumScoreBumpForAutomadeGoal' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, ScoreBrackets) == 0x0003B0, "Member 'AFortAthenaMutator_SpecialEvent::ScoreBrackets' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bEnforceInfiniteSafeZonePhase) == 0x0003C0, "Member 'AFortAthenaMutator_SpecialEvent::bEnforceInfiniteSafeZonePhase' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, WarmupIslandPlayerStartTag) == 0x0003C4, "Member 'AFortAthenaMutator_SpecialEvent::WarmupIslandPlayerStartTag' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bAllowInventoryOpen) == 0x0003CC, "Member 'AFortAthenaMutator_SpecialEvent::bAllowInventoryOpen' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bAllowFullScreenMap) == 0x0003D0, "Member 'AFortAthenaMutator_SpecialEvent::bAllowFullScreenMap' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bShouldClearFrontEndMapMarkers) == 0x0003F8, "Member 'AFortAthenaMutator_SpecialEvent::bShouldClearFrontEndMapMarkers' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bBlockTeamIndicators) == 0x0003F9, "Member 'AFortAthenaMutator_SpecialEvent::bBlockTeamIndicators' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, UIToHideDuringSpecialEvent) == 0x000400, "Member 'AFortAthenaMutator_SpecialEvent::UIToHideDuringSpecialEvent' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, UIToHideWhenInInfiniteWarmup) == 0x000420, "Member 'AFortAthenaMutator_SpecialEvent::UIToHideWhenInInfiniteWarmup' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, ClientEventsThatUnhideHiddenWhileLoadingHUDElements) == 0x000440, "Member 'AFortAthenaMutator_SpecialEvent::ClientEventsThatUnhideHiddenWhileLoadingHUDElements' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bForceGarbageCollectionAfterUnload) == 0x000460, "Member 'AFortAthenaMutator_SpecialEvent::bForceGarbageCollectionAfterUnload' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bFullPurgeGC) == 0x000461, "Member 'AFortAthenaMutator_SpecialEvent::bFullPurgeGC' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, EventAircraft) == 0x000468, "Member 'AFortAthenaMutator_SpecialEvent::EventAircraft' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, EventAircraftInfo) == 0x000470, "Member 'AFortAthenaMutator_SpecialEvent::EventAircraftInfo' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, EventAircraftClass) == 0x000498, "Member 'AFortAthenaMutator_SpecialEvent::EventAircraftClass' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, ScriptActor) == 0x0004A0, "Member 'AFortAthenaMutator_SpecialEvent::ScriptActor' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bDisableHUD) == 0x0004A8, "Member 'AFortAthenaMutator_SpecialEvent::bDisableHUD' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, GameResumed) == 0x0004A9, "Member 'AFortAthenaMutator_SpecialEvent::GameResumed' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, AdditionalViewpoint) == 0x0004AC, "Member 'AFortAthenaMutator_SpecialEvent::AdditionalViewpoint' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bParachutesDisabled) == 0x0004B8, "Member 'AFortAthenaMutator_SpecialEvent::bParachutesDisabled' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, LastCSVEventName) == 0x0004C0, "Member 'AFortAthenaMutator_SpecialEvent::LastCSVEventName' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bCanStreamBuildingFoundationsIn) == 0x0004D0, "Member 'AFortAthenaMutator_SpecialEvent::bCanStreamBuildingFoundationsIn' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, AllPlayerTeleportedCount) == 0x0004D4, "Member 'AFortAthenaMutator_SpecialEvent::AllPlayerTeleportedCount' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, DelayPlayersFromReturningToLobbyData) == 0x0004D8, "Member 'AFortAthenaMutator_SpecialEvent::DelayPlayersFromReturningToLobbyData' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, NamedWeightForContainerLootRoll) == 0x0004E8, "Member 'AFortAthenaMutator_SpecialEvent::NamedWeightForContainerLootRoll' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, WeightForContainerLootRoll) == 0x0004F0, "Member 'AFortAthenaMutator_SpecialEvent::WeightForContainerLootRoll' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, SpecialEventEmoteData) == 0x000518, "Member 'AFortAthenaMutator_SpecialEvent::SpecialEventEmoteData' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, BlockedNativeActions) == 0x000528, "Member 'AFortAthenaMutator_SpecialEvent::BlockedNativeActions' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, SpecialEventsInputComponent) == 0x000548, "Member 'AFortAthenaMutator_SpecialEvent::SpecialEventsInputComponent' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bLockingOnFocalPoint) == 0x000550, "Member 'AFortAthenaMutator_SpecialEvent::bLockingOnFocalPoint' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, SpecialEventOverrideParts) == 0x000558, "Member 'AFortAthenaMutator_SpecialEvent::SpecialEventOverrideParts' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, GameplayEffectToApplyOnSwapToDefault) == 0x000568, "Member 'AFortAthenaMutator_SpecialEvent::GameplayEffectToApplyOnSwapToDefault' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, OverridePartsArrayIndexMap) == 0x000578, "Member 'AFortAthenaMutator_SpecialEvent::OverridePartsArrayIndexMap' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, GameplayEffectsToApplyOnLogin) == 0x0005C8, "Member 'AFortAthenaMutator_SpecialEvent::GameplayEffectsToApplyOnLogin' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, TerrainMapsToUnload) == 0x0005D8, "Member 'AFortAthenaMutator_SpecialEvent::TerrainMapsToUnload' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, UnhandledPlayerControllers) == 0x0005F8, "Member 'AFortAthenaMutator_SpecialEvent::UnhandledPlayerControllers' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, bCanToggleCursorModeInStasis) == 0x000608, "Member 'AFortAthenaMutator_SpecialEvent::bCanToggleCursorModeInStasis' has a wrong offset!");
static_assert(offsetof(AFortAthenaMutator_SpecialEvent, ActorSpawnDelegateClasses) == 0x000610, "Member 'AFortAthenaMutator_SpecialEvent::ActorSpawnDelegateClasses' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortCharacterMovementMutator
// 0x0008 (0x02D0 - 0x02C8)
class AFortCharacterMovementMutator final : public AFortAthenaMutator
{
public:
	TSubclassOf<class UFortCharacterMovementMutatorComponent> MovementMutatorComponentClass;                     // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFortPawnChanged(class AFortPawn* NewPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortCharacterMovementMutator">();
	}
	static class AFortCharacterMovementMutator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortCharacterMovementMutator>();
	}
};
static_assert(alignof(AFortCharacterMovementMutator) == 0x000008, "Wrong alignment on AFortCharacterMovementMutator");
static_assert(sizeof(AFortCharacterMovementMutator) == 0x0002D0, "Wrong size on AFortCharacterMovementMutator");
static_assert(offsetof(AFortCharacterMovementMutator, MovementMutatorComponentClass) == 0x0002C8, "Member 'AFortCharacterMovementMutator::MovementMutatorComponentClass' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortControllerComponent_GameplayCinematic
// 0x0058 (0x0108 - 0x00B0)
class UFortControllerComponent_GameplayCinematic final : public UFortControllerComponent
{
public:
	uint8                                         Pad_B0[0x30];                                      // 0x00B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AFortPlayerControllerAthena* PlayerControllerAthena)> BP_OnStartGameplayOutro;                           // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AFortPlayerControllerAthena* PlayerControllerAthena)> BP_OnGameplayIntroFinished;                        // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsReadyForGameplay;                               // 0x0100(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideHUDElementsForLoadingScreen(const bool bHideElements);
	void OnRep_bIsReadyForGameplay();
	void ServerOnGameplayIntroFinished();
	void SetReadyForGameplay(bool bIsReady);
	void ShowCinematicWidget(class FName WidgetName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortControllerComponent_GameplayCinematic">();
	}
	static class UFortControllerComponent_GameplayCinematic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortControllerComponent_GameplayCinematic>();
	}
};
static_assert(alignof(UFortControllerComponent_GameplayCinematic) == 0x000008, "Wrong alignment on UFortControllerComponent_GameplayCinematic");
static_assert(sizeof(UFortControllerComponent_GameplayCinematic) == 0x000108, "Wrong size on UFortControllerComponent_GameplayCinematic");
static_assert(offsetof(UFortControllerComponent_GameplayCinematic, BP_OnStartGameplayOutro) == 0x0000E0, "Member 'UFortControllerComponent_GameplayCinematic::BP_OnStartGameplayOutro' has a wrong offset!");
static_assert(offsetof(UFortControllerComponent_GameplayCinematic, BP_OnGameplayIntroFinished) == 0x0000F0, "Member 'UFortControllerComponent_GameplayCinematic::BP_OnGameplayIntroFinished' has a wrong offset!");
static_assert(offsetof(UFortControllerComponent_GameplayCinematic, bIsReadyForGameplay) == 0x000100, "Member 'UFortControllerComponent_GameplayCinematic::bIsReadyForGameplay' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortControllerComponent_SpecialEvent
// 0x0008 (0x00B8 - 0x00B0)
class UFortControllerComponent_SpecialEvent final : public UFortControllerComponent
{
public:
	TWeakObjectPtr<class AFortAthenaMutator_SpecialEvent> SpecialEventMutator;                               // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SendSpecialClientEvent(const struct FGameplayTag& EventTag, const int32 Count);
	void ServerHandleSpecialClientEvent(const struct FGameplayTag& EventTag, const int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortControllerComponent_SpecialEvent">();
	}
	static class UFortControllerComponent_SpecialEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortControllerComponent_SpecialEvent>();
	}
};
static_assert(alignof(UFortControllerComponent_SpecialEvent) == 0x000008, "Wrong alignment on UFortControllerComponent_SpecialEvent");
static_assert(sizeof(UFortControllerComponent_SpecialEvent) == 0x0000B8, "Wrong size on UFortControllerComponent_SpecialEvent");
static_assert(offsetof(UFortControllerComponent_SpecialEvent, SpecialEventMutator) == 0x0000B0, "Member 'UFortControllerComponent_SpecialEvent::SpecialEventMutator' has a wrong offset!");

// Class SpecialEventGameplayRuntime.FortSpecialRelevancyActorSpawner
// 0x0008 (0x0258 - 0x0250)
class AFortSpecialRelevancyActorSpawner final : public AFortActorSpawner
{
public:
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnActorSpawnedPerRelevancyGroup(const TArray<class AActor*>& InSpawnedActors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortSpecialRelevancyActorSpawner">();
	}
	static class AFortSpecialRelevancyActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFortSpecialRelevancyActorSpawner>();
	}
};
static_assert(alignof(AFortSpecialRelevancyActorSpawner) == 0x000008, "Wrong alignment on AFortSpecialRelevancyActorSpawner");
static_assert(sizeof(AFortSpecialRelevancyActorSpawner) == 0x000258, "Wrong size on AFortSpecialRelevancyActorSpawner");

// Class SpecialEventGameplayRuntime.SpecialEventAudioAnalysisBaseComponent
// 0x0020 (0x00D0 - 0x00B0)
class USpecialEventAudioAnalysisBaseComponent : public UActorComponent
{
public:
	float                                         CurrentTime;                                       // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoudnessNRT*                           LoudnessNRT;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOnsetNRT*                              OnsetNRT;                                          // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConstantQNRT*                          ConstantQNRT;                                      // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateConstantQ(float Time);
	void UpdateLoudness(float Time);
	void UpdateOnset(float Time);
	void UpdateTime(const float NewTime);

	class UConstantQNRT* GetConstantQNRT() const;
	float GetCurrentNormalizedLoudness() const;
	class ULoudnessNRT* GetLoudnessNRT() const;
	class UOnsetNRT* GetOnsetNRT() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventAudioAnalysisBaseComponent">();
	}
	static class USpecialEventAudioAnalysisBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventAudioAnalysisBaseComponent>();
	}
};
static_assert(alignof(USpecialEventAudioAnalysisBaseComponent) == 0x000008, "Wrong alignment on USpecialEventAudioAnalysisBaseComponent");
static_assert(sizeof(USpecialEventAudioAnalysisBaseComponent) == 0x0000D0, "Wrong size on USpecialEventAudioAnalysisBaseComponent");
static_assert(offsetof(USpecialEventAudioAnalysisBaseComponent, CurrentTime) == 0x0000B0, "Member 'USpecialEventAudioAnalysisBaseComponent::CurrentTime' has a wrong offset!");
static_assert(offsetof(USpecialEventAudioAnalysisBaseComponent, LoudnessNRT) == 0x0000B8, "Member 'USpecialEventAudioAnalysisBaseComponent::LoudnessNRT' has a wrong offset!");
static_assert(offsetof(USpecialEventAudioAnalysisBaseComponent, OnsetNRT) == 0x0000C0, "Member 'USpecialEventAudioAnalysisBaseComponent::OnsetNRT' has a wrong offset!");
static_assert(offsetof(USpecialEventAudioAnalysisBaseComponent, ConstantQNRT) == 0x0000C8, "Member 'USpecialEventAudioAnalysisBaseComponent::ConstantQNRT' has a wrong offset!");

// Class SpecialEventGameplayRuntime.SpecialEventAudioHapticsComponent
// 0x0028 (0x00F8 - 0x00D0)
class USpecialEventAudioHapticsComponent final : public USpecialEventAudioAnalysisBaseComponent
{
public:
	TArray<struct FSpecialEventAudioHapticsAction> HapticsActions;                                    // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bStartHapticsOnBeginPlay;                          // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntensityMultiplier;                               // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartHaptics();
	void StopHaptics();

	bool AreHapticsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventAudioHapticsComponent">();
	}
	static class USpecialEventAudioHapticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventAudioHapticsComponent>();
	}
};
static_assert(alignof(USpecialEventAudioHapticsComponent) == 0x000008, "Wrong alignment on USpecialEventAudioHapticsComponent");
static_assert(sizeof(USpecialEventAudioHapticsComponent) == 0x0000F8, "Wrong size on USpecialEventAudioHapticsComponent");
static_assert(offsetof(USpecialEventAudioHapticsComponent, HapticsActions) == 0x0000D0, "Member 'USpecialEventAudioHapticsComponent::HapticsActions' has a wrong offset!");
static_assert(offsetof(USpecialEventAudioHapticsComponent, bStartHapticsOnBeginPlay) == 0x0000E0, "Member 'USpecialEventAudioHapticsComponent::bStartHapticsOnBeginPlay' has a wrong offset!");
static_assert(offsetof(USpecialEventAudioHapticsComponent, IntensityMultiplier) == 0x0000E4, "Member 'USpecialEventAudioHapticsComponent::IntensityMultiplier' has a wrong offset!");

// Class SpecialEventGameplayRuntime.SpecialEventGameplayGlobals
// 0x0000 (0x0028 - 0x0028)
class USpecialEventGameplayGlobals final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventGameplayGlobals">();
	}
	static class USpecialEventGameplayGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventGameplayGlobals>();
	}
};
static_assert(alignof(USpecialEventGameplayGlobals) == 0x000008, "Wrong alignment on USpecialEventGameplayGlobals");
static_assert(sizeof(USpecialEventGameplayGlobals) == 0x000028, "Wrong size on USpecialEventGameplayGlobals");

// Class SpecialEventGameplayRuntime.SpecialEventGameplayLibrary
// 0x0000 (0x0028 - 0x0028)
class USpecialEventGameplayLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddSpecialEventKillFeedEntry(const class UObject* WorldContextObject, const class AFortPlayerStateAthena* VictimPlayerState, const class AFortPlayerStateAthena* KillerPlayerState, const class FText& NonPlayerVictimName, const class FText& NonPlayerKillerName, const struct FGameplayTag& DeathCauseTag, const EDeathCauseReason DeathCauseReason, const float Distance);
	static void AddSpecialEventRecentElimination(const struct FVector& Location, const class AFortPlayerStateAthena* PlayerState);
	static void CreateSpecialEventPlayerEliminationWorldMarker(const class AFortPlayerControllerAthena* LocalController, const class AFortPlayerStateAthena* VictimPlayerState, const struct FVector& DeathLocation);
	static class UFortControllerComponent_GameplayCinematic* FindGameplayCinematicComponent(class AController* Controller);
	static class UFortControllerComponent_SpecialEvent* FindSpecialEventComponent(class AController* Controller);
	static void ForceDestroyComponents(const TArray<class UActorComponent*>& Components, const bool bPromoteChildren, const class FString& LogContext);
	static void ForceUpdateGrass(class UObject* WorldContextObject, const struct FVector& Location);
	static bool GetHasInfiniteSafeZonePhase(class UObject* WorldContextObject);
	static struct FFortAthenaLoadout GetLocalPlayerLoadout(class UObject* WorldContextObject);
	static class AFortAthenaMutator_SpecialEvent* GetSpecialEventMutator(class UObject* WorldContextObject);
	static class FString GetSpecialEventPlayerDisplayName(const class AFortPlayerControllerAthena* LocalController, const class AFortPlayerStateAthena* PlayerState);
	static class ASpecialEventScript* GetSpecialEventScript(class UObject* WorldContextObject);
	static void HideSkydivingShadowProxy(const class UObject* WorldContextObject);
	static void SetNextLoadingScreen(class UObject* WorldContextObject, const class UAthenaLoadingScreenItemDefinition* LoadingScreenDefinition, const bool bCanShowLoadingBar);
	static void StreamOutAllBuildingFoundations(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventGameplayLibrary">();
	}
	static class USpecialEventGameplayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventGameplayLibrary>();
	}
};
static_assert(alignof(USpecialEventGameplayLibrary) == 0x000008, "Wrong alignment on USpecialEventGameplayLibrary");
static_assert(sizeof(USpecialEventGameplayLibrary) == 0x000028, "Wrong size on USpecialEventGameplayLibrary");

// Class SpecialEventGameplayRuntime.FortAsyncAction_GameplayCinematicComponentReady
// 0x0018 (0x0048 - 0x0030)
class UFortAsyncAction_GameplayCinematicComponentReady final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(class UFortControllerComponent_GameplayCinematic* FoundComponent)> OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFortAsyncAction_GameplayCinematicComponentReady* FindGameplayCinematicComponentAsync(class AController* Conroller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FortAsyncAction_GameplayCinematicComponentReady">();
	}
	static class UFortAsyncAction_GameplayCinematicComponentReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFortAsyncAction_GameplayCinematicComponentReady>();
	}
};
static_assert(alignof(UFortAsyncAction_GameplayCinematicComponentReady) == 0x000008, "Wrong alignment on UFortAsyncAction_GameplayCinematicComponentReady");
static_assert(sizeof(UFortAsyncAction_GameplayCinematicComponentReady) == 0x000048, "Wrong size on UFortAsyncAction_GameplayCinematicComponentReady");
static_assert(offsetof(UFortAsyncAction_GameplayCinematicComponentReady, OnReady) == 0x000030, "Member 'UFortAsyncAction_GameplayCinematicComponentReady::OnReady' has a wrong offset!");

// Class SpecialEventGameplayRuntime.SpecialEventPhase
// 0x0068 (0x0288 - 0x0220)
class ASpecialEventPhase final : public AInfo
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PhaseTag;                                          // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyGameplayEffects;                             // 0x0240(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectsToApply;                            // 0x0248(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraModifier>            CameraModifierToApply;                             // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveModifierOnPhaseDeactivation;                // 0x0260(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveGameplayEffects;                            // 0x0261(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262[0x6];                                      // 0x0262(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectsToRemove;                           // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UCameraModifier*                        AppliedCameraModifier;                             // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpecialEventPhaseState                       PhaseState;                                        // 0x0280(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugActivatePhase();
	void OnPhaseActivation_Client();
	void OnPhaseActivation_Server();
	void OnPhaseDeactivation_Client();
	void OnPhaseDeactivation_Server();
	void OnPhaseFinished();
	void OnRep_PhaseState();
	void PrePhaseActivation_Server();
	void SetHUDElementVisibility(const struct FGameplayTagContainer& HUDElementTags, bool bHideElements);

	struct FGameplayTag GetPhaseTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventPhase">();
	}
	static class ASpecialEventPhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpecialEventPhase>();
	}
};
static_assert(alignof(ASpecialEventPhase) == 0x000008, "Wrong alignment on ASpecialEventPhase");
static_assert(sizeof(ASpecialEventPhase) == 0x000288, "Wrong size on ASpecialEventPhase");
static_assert(offsetof(ASpecialEventPhase, PhaseTag) == 0x000238, "Member 'ASpecialEventPhase::PhaseTag' has a wrong offset!");
static_assert(offsetof(ASpecialEventPhase, bApplyGameplayEffects) == 0x000240, "Member 'ASpecialEventPhase::bApplyGameplayEffects' has a wrong offset!");
static_assert(offsetof(ASpecialEventPhase, GameplayEffectsToApply) == 0x000248, "Member 'ASpecialEventPhase::GameplayEffectsToApply' has a wrong offset!");
static_assert(offsetof(ASpecialEventPhase, CameraModifierToApply) == 0x000258, "Member 'ASpecialEventPhase::CameraModifierToApply' has a wrong offset!");
static_assert(offsetof(ASpecialEventPhase, bRemoveModifierOnPhaseDeactivation) == 0x000260, "Member 'ASpecialEventPhase::bRemoveModifierOnPhaseDeactivation' has a wrong offset!");
static_assert(offsetof(ASpecialEventPhase, bRemoveGameplayEffects) == 0x000261, "Member 'ASpecialEventPhase::bRemoveGameplayEffects' has a wrong offset!");
static_assert(offsetof(ASpecialEventPhase, GameplayEffectsToRemove) == 0x000268, "Member 'ASpecialEventPhase::GameplayEffectsToRemove' has a wrong offset!");
static_assert(offsetof(ASpecialEventPhase, AppliedCameraModifier) == 0x000278, "Member 'ASpecialEventPhase::AppliedCameraModifier' has a wrong offset!");
static_assert(offsetof(ASpecialEventPhase, PhaseState) == 0x000280, "Member 'ASpecialEventPhase::PhaseState' has a wrong offset!");

// Class SpecialEventGameplayRuntime.SpecialEventScript
// 0x0060 (0x0280 - 0x0220)
class ASpecialEventScript final : public AInfo
{
public:
	TArray<struct FPhaseInfo>                     PhaseInfoArray;                                    // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    MasterSequence;                                    // 0x0230(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropDeadWindowSizeInSeconds;                       // 0x0238(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayAfterConentLoad;                              // 0x023C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayAfterWarmup;                                  // 0x0240(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceReturnToMainMenuTime;                         // 0x0244(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceReturnToMainMenuTimeRandomness;               // 0x0248(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinDelayReturnToMainMenu;                          // 0x024C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDelayReturnToMainMenu;                          // 0x0250(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPreloadAllLevelsOnServer;                         // 0x0254(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowGarbageCollectionAfterUnload;                // 0x0255(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFullPurgeGC;                                      // 0x0256(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_257[0x1];                                      // 0x0257(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReplicatedActivePhaseIndex;                        // 0x0258(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0xC];                                      // 0x025C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshNetworkComponent*                  MeshNetworkComponent;                              // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttemptFinishPhase(const struct FGameplayTag& PhaseTag);
	void AttemptStartNextPhase(const struct FGameplayTag& CurrentPhaseTag);
	void BP_OnScriptFinished();
	void BP_OnScriptReady();
	void OnRep_ReplicatedActivePhaseIndex();
	void StartEventAtIndex(int32 InStartingIndex);
	void UpdateMasterSequence(float Time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventScript">();
	}
	static class ASpecialEventScript* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpecialEventScript>();
	}
};
static_assert(alignof(ASpecialEventScript) == 0x000008, "Wrong alignment on ASpecialEventScript");
static_assert(sizeof(ASpecialEventScript) == 0x000280, "Wrong size on ASpecialEventScript");
static_assert(offsetof(ASpecialEventScript, PhaseInfoArray) == 0x000220, "Member 'ASpecialEventScript::PhaseInfoArray' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, MasterSequence) == 0x000230, "Member 'ASpecialEventScript::MasterSequence' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, DropDeadWindowSizeInSeconds) == 0x000238, "Member 'ASpecialEventScript::DropDeadWindowSizeInSeconds' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, DelayAfterConentLoad) == 0x00023C, "Member 'ASpecialEventScript::DelayAfterConentLoad' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, DelayAfterWarmup) == 0x000240, "Member 'ASpecialEventScript::DelayAfterWarmup' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, ForceReturnToMainMenuTime) == 0x000244, "Member 'ASpecialEventScript::ForceReturnToMainMenuTime' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, ForceReturnToMainMenuTimeRandomness) == 0x000248, "Member 'ASpecialEventScript::ForceReturnToMainMenuTimeRandomness' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, MinDelayReturnToMainMenu) == 0x00024C, "Member 'ASpecialEventScript::MinDelayReturnToMainMenu' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, MaxDelayReturnToMainMenu) == 0x000250, "Member 'ASpecialEventScript::MaxDelayReturnToMainMenu' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, bPreloadAllLevelsOnServer) == 0x000254, "Member 'ASpecialEventScript::bPreloadAllLevelsOnServer' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, bAllowGarbageCollectionAfterUnload) == 0x000255, "Member 'ASpecialEventScript::bAllowGarbageCollectionAfterUnload' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, bFullPurgeGC) == 0x000256, "Member 'ASpecialEventScript::bFullPurgeGC' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, ReplicatedActivePhaseIndex) == 0x000258, "Member 'ASpecialEventScript::ReplicatedActivePhaseIndex' has a wrong offset!");
static_assert(offsetof(ASpecialEventScript, MeshNetworkComponent) == 0x000268, "Member 'ASpecialEventScript::MeshNetworkComponent' has a wrong offset!");

// Class SpecialEventGameplayRuntime.SpecialEventScriptMeshActor
// 0x0010 (0x0230 - 0x0220)
class ASpecialEventScriptMeshActor final : public AInfo
{
public:
	struct FDateTime                              RootStartTime;                                     // 0x0220(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshNetworkComponent*                  MeshNetworkComponent;                              // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void MeshRootResetEvent();
	void MeshRootStartEvent();
	void OnRep_RootStartTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventScriptMeshActor">();
	}
	static class ASpecialEventScriptMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpecialEventScriptMeshActor>();
	}
};
static_assert(alignof(ASpecialEventScriptMeshActor) == 0x000008, "Wrong alignment on ASpecialEventScriptMeshActor");
static_assert(sizeof(ASpecialEventScriptMeshActor) == 0x000230, "Wrong size on ASpecialEventScriptMeshActor");
static_assert(offsetof(ASpecialEventScriptMeshActor, RootStartTime) == 0x000220, "Member 'ASpecialEventScriptMeshActor::RootStartTime' has a wrong offset!");
static_assert(offsetof(ASpecialEventScriptMeshActor, MeshNetworkComponent) == 0x000228, "Member 'ASpecialEventScriptMeshActor::MeshNetworkComponent' has a wrong offset!");

}

