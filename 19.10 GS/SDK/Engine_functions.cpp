#pragma once
#include "pch.h"

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Engine

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "Engine_parameters.hpp"


namespace SDK
{

// Function Engine.ActorComponent.Activate
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::Activate(bool bReset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Activate");

	Params::ActorComponent_Activate Parms{};

	Parms.bReset = bReset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.AddTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PrerequisiteActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::AddTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddTickPrerequisiteActor");

	Params::ActorComponent_AddTickPrerequisiteActor Parms{};

	Parms.PrerequisiteActor = PrerequisiteActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.AddTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  PrerequisiteComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddTickPrerequisiteComponent");

	Params::ActorComponent_AddTickPrerequisiteComponent Parms{};

	Parms.PrerequisiteComponent = PrerequisiteComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.Deactivate
// (Native, Public, BlueprintCallable)

void UActorComponent::Deactivate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Deactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ActorComponent.K2_DestroyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::K2_DestroyComponent(class UObject* Object)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DestroyComponent");

	Params::ActorComponent_K2_DestroyComponent Parms{};

	Parms.Object = Object;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.OnRep_IsActive
// (Native, Public)

void UActorComponent::OnRep_IsActive()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_IsActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ActorComponent.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UActorComponent::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ActorComponent.ReceiveEndPlay
// (Event, Public, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveEndPlay");

	Params::ActorComponent_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveTick");

	Params::ActorComponent_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.RemoveTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PrerequisiteActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveTickPrerequisiteActor");

	Params::ActorComponent_RemoveTickPrerequisiteActor Parms{};

	Parms.PrerequisiteActor = PrerequisiteActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.RemoveTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  PrerequisiteComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveTickPrerequisiteComponent");

	Params::ActorComponent_RemoveTickPrerequisiteComponent Parms{};

	Parms.PrerequisiteComponent = PrerequisiteComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.SetActive
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetActive(bool bNewActive, bool bReset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActive");

	Params::ActorComponent_SetActive Parms{};

	Parms.bNewActive = bNewActive;
	Parms.bReset = bReset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.SetAutoActivate
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewAutoActivate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetAutoActivate(bool bNewAutoActivate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAutoActivate");

	Params::ActorComponent_SetAutoActivate Parms{};

	Parms.bNewAutoActivate = bNewAutoActivate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.SetComponentTickEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetComponentTickEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetComponentTickEnabled");

	Params::ActorComponent_SetComponentTickEnabled Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.SetComponentTickInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TickInterval                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetComponentTickInterval(float TickInterval)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetComponentTickInterval");

	Params::ActorComponent_SetComponentTickInterval Parms{};

	Parms.TickInterval = TickInterval;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.SetComponentTickIntervalAndCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TickInterval                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetComponentTickIntervalAndCooldown(float TickInterval)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetComponentTickIntervalAndCooldown");

	Params::ActorComponent_SetComponentTickIntervalAndCooldown Parms{};

	Parms.TickInterval = TickInterval;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.SetIsReplicated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ShouldReplicate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetIsReplicated(bool ShouldReplicate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsReplicated");

	Params::ActorComponent_SetIsReplicated Parms{};

	Parms.ShouldReplicate = ShouldReplicate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.SetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bTickableWhenPaused                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetTickableWhenPaused(bool bTickableWhenPaused)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTickableWhenPaused");

	Params::ActorComponent_SetTickableWhenPaused Parms{};

	Parms.bTickableWhenPaused = bTickableWhenPaused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.SetTickGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           NewTickGroup                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorComponent::SetTickGroup(ETickingGroup NewTickGroup)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTickGroup");

	Params::ActorComponent_SetTickGroup Parms{};

	Parms.NewTickGroup = NewTickGroup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorComponent.ToggleActive
// (Native, Public, BlueprintCallable)

void UActorComponent::ToggleActive()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ActorComponent.ComponentHasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponent::ComponentHasTag(class FName Tag) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ComponentHasTag");

	Params::ActorComponent_ComponentHasTag Parms{};

	Parms.Tag = Tag;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ActorComponent.GetComponentTickInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActorComponent::GetComponentTickInterval() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetComponentTickInterval");

	Params::ActorComponent_GetComponentTickInterval Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ActorComponent.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UActorComponent::GetOwner() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwner");

	Params::ActorComponent_GetOwner Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ActorComponent.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponent::IsActive() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsActive");

	Params::ActorComponent_IsActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ActorComponent.IsBeingDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponent::IsBeingDestroyed() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsBeingDestroyed");

	Params::ActorComponent_IsBeingDestroyed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ActorComponent.IsComponentTickEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponent::IsComponentTickEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsComponentTickEnabled");

	Params::ActorComponent_IsComponentTickEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.AddComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             TemplateName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bManualAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       RelativeTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                          ComponentTemplateContext                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeferredFinish                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* AActor::AddComponent(class FName TemplateName, bool bManualAttachment, const struct FTransform& RelativeTransform, const class UObject* ComponentTemplateContext, bool bDeferredFinish)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddComponent");

	Params::Actor_AddComponent Parms{};

	Parms.TemplateName = TemplateName;
	Parms.bManualAttachment = bManualAttachment;
	Parms.RelativeTransform = std::move(RelativeTransform);
	Parms.ComponentTemplateContext = ComponentTemplateContext;
	Parms.bDeferredFinish = bDeferredFinish;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.AddComponentByClass
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UActorComponent>      Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bManualAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       RelativeTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bDeferredFinish                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* AActor::AddComponentByClass(TSubclassOf<class UActorComponent> Class_0, bool bManualAttachment, const struct FTransform& RelativeTransform, bool bDeferredFinish)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddComponentByClass");

	Params::Actor_AddComponentByClass Parms{};

	Parms.Class_0 = Class_0;
	Parms.bManualAttachment = bManualAttachment;
	Parms.RelativeTransform = std::move(RelativeTransform);
	Parms.bDeferredFinish = bDeferredFinish;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.AddTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PrerequisiteActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::AddTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddTickPrerequisiteActor");

	Params::Actor_AddTickPrerequisiteActor Parms{};

	Parms.PrerequisiteActor = PrerequisiteActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.AddTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  PrerequisiteComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddTickPrerequisiteComponent");

	Params::Actor_AddTickPrerequisiteComponent Parms{};

	Parms.PrerequisiteComponent = PrerequisiteComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.DetachRootComponentFromParent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMaintainWorldPosition                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::DetachRootComponentFromParent(bool bMaintainWorldPosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DetachRootComponentFromParent");

	Params::Actor_DetachRootComponentFromParent Parms{};

	Parms.bMaintainWorldPosition = bMaintainWorldPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.DisableInput
// (Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::DisableInput(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableInput");

	Params::Actor_DisableInput Parms{};

	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.EnableInput
// (Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::EnableInput(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableInput");

	Params::Actor_EnableInput Parms{};

	Parms.PlayerController = PlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.FinishAddComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bManualAttachment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       RelativeTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AActor::FinishAddComponent(class UActorComponent* Component, bool bManualAttachment, const struct FTransform& RelativeTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FinishAddComponent");

	Params::Actor_FinishAddComponent Parms{};

	Parms.Component = Component;
	Parms.bManualAttachment = bManualAttachment;
	Parms.RelativeTransform = std::move(RelativeTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.FlushNetDormancy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AActor::FlushNetDormancy()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FlushNetDormancy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.ForceNetUpdate
// (Native, Public, BlueprintCallable)

void AActor::ForceNetUpdate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceNetUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.GetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::GetTickableWhenPaused()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTickableWhenPaused");

	Params::Actor_GetTickableWhenPaused Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_AddActorLocalOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DeltaLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorLocalOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddActorLocalOffset");

	Params::Actor_K2_AddActorLocalOffset Parms{};

	Parms.DeltaLocation = std::move(DeltaLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_AddActorLocalRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         DeltaRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddActorLocalRotation");

	Params::Actor_K2_AddActorLocalRotation Parms{};

	Parms.DeltaRotation = std::move(DeltaRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_AddActorLocalTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorLocalTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddActorLocalTransform");

	Params::Actor_K2_AddActorLocalTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_AddActorWorldOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DeltaLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorWorldOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddActorWorldOffset");

	Params::Actor_K2_AddActorWorldOffset Parms{};

	Parms.DeltaLocation = std::move(DeltaLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_AddActorWorldRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         DeltaRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddActorWorldRotation");

	Params::Actor_K2_AddActorWorldRotation Parms{};

	Parms.DeltaRotation = std::move(DeltaRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_AddActorWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       DeltaTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddActorWorldTransform");

	Params::Actor_K2_AddActorWorldTransform Parms{};

	Parms.DeltaTransform = std::move(DeltaTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_AddActorWorldTransformKeepScale
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       DeltaTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AddActorWorldTransformKeepScale(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddActorWorldTransformKeepScale");

	Params::Actor_K2_AddActorWorldTransformKeepScale Parms{};

	Parms.DeltaTransform = std::move(DeltaTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_AttachRootComponentTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InParent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         AttachLocationType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AttachRootComponentTo(class USceneComponent* InParent, class FName InSocketName, EAttachLocation AttachLocationType, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AttachRootComponentTo");

	Params::Actor_K2_AttachRootComponentTo Parms{};

	Parms.InParent = InParent;
	Parms.InSocketName = InSocketName;
	Parms.AttachLocationType = AttachLocationType;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.K2_AttachRootComponentToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InParentActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         AttachLocationType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AttachRootComponentToActor(class AActor* InParentActor, class FName InSocketName, EAttachLocation AttachLocationType, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AttachRootComponentToActor");

	Params::Actor_K2_AttachRootComponentToActor Parms{};

	Parms.InParentActor = InParentActor;
	Parms.InSocketName = InSocketName;
	Parms.AttachLocationType = AttachLocationType;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.K2_AttachToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ParentActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AttachToActor(class AActor* ParentActor, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AttachToActor");

	Params::Actor_K2_AttachToActor Parms{};

	Parms.ParentActor = ParentActor;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.K2_AttachToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_AttachToComponent(class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AttachToComponent");

	Params::Actor_K2_AttachToComponent Parms{};

	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.K2_DestroyActor
// (Native, Public, BlueprintCallable)

void AActor::K2_DestroyActor()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DestroyActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.K2_DetachFromActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDetachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_DetachFromActor(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DetachFromActor");

	Params::Actor_K2_DetachFromActor Parms{};

	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.K2_OnBecomeViewTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_OnBecomeViewTarget(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnBecomeViewTarget");

	Params::Actor_K2_OnBecomeViewTarget Parms{};

	Parms.PC = PC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.K2_OnEndViewTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_OnEndViewTarget(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnEndViewTarget");

	Params::Actor_K2_OnEndViewTarget Parms{};

	Parms.PC = PC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.K2_OnReset
// (Event, Public, BlueprintEvent)

void AActor::K2_OnReset()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.K2_SetActorLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_SetActorLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetActorLocation");

	Params::Actor_K2_SetActorLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_SetActorLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_SetActorLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetActorLocationAndRotation");

	Params::Actor_K2_SetActorLocationAndRotation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_SetActorRelativeLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewRelativeLocation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_SetActorRelativeLocation(const struct FVector& NewRelativeLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetActorRelativeLocation");

	Params::Actor_K2_SetActorRelativeLocation Parms{};

	Parms.NewRelativeLocation = std::move(NewRelativeLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_SetActorRelativeRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         NewRelativeRotation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_SetActorRelativeRotation(const struct FRotator& NewRelativeRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetActorRelativeRotation");

	Params::Actor_K2_SetActorRelativeRotation Parms{};

	Parms.NewRelativeRotation = std::move(NewRelativeRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_SetActorRelativeTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       NewRelativeTransform                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::K2_SetActorRelativeTransform(const struct FTransform& NewRelativeTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetActorRelativeTransform");

	Params::Actor_K2_SetActorRelativeTransform Parms{};

	Parms.NewRelativeTransform = std::move(NewRelativeTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.Actor.K2_SetActorRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bTeleportPhysics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_SetActorRotation(const struct FRotator& NewRotation, bool bTeleportPhysics)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetActorRotation");

	Params::Actor_K2_SetActorRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);
	Parms.bTeleportPhysics = bTeleportPhysics;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_SetActorTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_SetActorTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetActorTransform");

	Params::Actor_K2_SetActorTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_TeleportTo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DestLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         DestRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::K2_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_TeleportTo");

	Params::Actor_K2_TeleportTo Parms{};

	Parms.DestLocation = std::move(DestLocation);
	Parms.DestRotation = std::move(DestRotation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.MakeNoise
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Loudness                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NoiseInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NoiseLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::MakeNoise(float Loudness, class APawn* NoiseInstigator, const struct FVector& NoiseLocation, float MaxRange, class FName Tag)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MakeNoise");

	Params::Actor_MakeNoise Parms{};

	Parms.Loudness = Loudness;
	Parms.NoiseInstigator = NoiseInstigator;
	Parms.NoiseLocation = std::move(NoiseLocation);
	Parms.MaxRange = MaxRange;
	Parms.Tag = Tag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.OnRep_AttachmentReplication
// (Native, Public)

void AActor::OnRep_AttachmentReplication()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_AttachmentReplication");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.OnRep_Instigator
// (Native, Public)

void AActor::OnRep_Instigator()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Instigator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.OnRep_Owner
// (Native, Protected)

void AActor::OnRep_Owner()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Owner");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.OnRep_ReplicatedMovement
// (Native, Public)

void AActor::OnRep_ReplicatedMovement()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.OnRep_ReplicateMovement
// (Native, Public)

void AActor::OnRep_ReplicateMovement()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicateMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.PrestreamTextures
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableStreaming                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CinematicTextureGroups                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::PrestreamTextures(float Seconds, bool bEnableStreaming, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PrestreamTextures");

	Params::Actor_PrestreamTextures Parms{};

	Parms.Seconds = Seconds;
	Parms.bEnableStreaming = bEnableStreaming;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveActorBeginCursorOver
// (Event, Public, BlueprintEvent)

void AActor::ReceiveActorBeginCursorOver()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorBeginCursorOver");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.ReceiveActorBeginOverlap
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorBeginOverlap(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorBeginOverlap");

	Params::Actor_ReceiveActorBeginOverlap Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveActorEndCursorOver
// (Event, Public, BlueprintEvent)

void AActor::ReceiveActorEndCursorOver()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorEndCursorOver");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.ReceiveActorEndOverlap
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorEndOverlap(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorEndOverlap");

	Params::Actor_ReceiveActorEndOverlap Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveActorOnClicked
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FKey                             ButtonPressed                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnClicked(const struct FKey& ButtonPressed)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorOnClicked");

	Params::Actor_ReceiveActorOnClicked Parms{};

	Parms.ButtonPressed = std::move(ButtonPressed);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveActorOnInputTouchBegin
// (Event, Public, BlueprintEvent)
// Parameters:
// ETouchIndex                             FingerIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnInputTouchBegin(const ETouchIndex FingerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorOnInputTouchBegin");

	Params::Actor_ReceiveActorOnInputTouchBegin Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveActorOnInputTouchEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// ETouchIndex                             FingerIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnInputTouchEnd(const ETouchIndex FingerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorOnInputTouchEnd");

	Params::Actor_ReceiveActorOnInputTouchEnd Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveActorOnInputTouchEnter
// (Event, Public, BlueprintEvent)
// Parameters:
// ETouchIndex                             FingerIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnInputTouchEnter(const ETouchIndex FingerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorOnInputTouchEnter");

	Params::Actor_ReceiveActorOnInputTouchEnter Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveActorOnInputTouchLeave
// (Event, Public, BlueprintEvent)
// Parameters:
// ETouchIndex                             FingerIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnInputTouchLeave(const ETouchIndex FingerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorOnInputTouchLeave");

	Params::Actor_ReceiveActorOnInputTouchLeave Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveActorOnReleased
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FKey                             ButtonReleased                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveActorOnReleased(const struct FKey& ButtonReleased)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveActorOnReleased");

	Params::Actor_ReceiveActorOnReleased Parms{};

	Parms.ButtonReleased = std::move(ButtonReleased);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveAnyDamage
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveAnyDamage(float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveAnyDamage");

	Params::Actor_ReceiveAnyDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AActor::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.ReceiveDestroyed
// (Event, Public, BlueprintEvent)

void AActor::ReceiveDestroyed()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveDestroyed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveEndPlay");

	Params::Actor_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveHit
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              MyComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSelfMoved                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActor::ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveHit");

	Params::Actor_ReceiveHit Parms{};

	Parms.MyComp = MyComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.bSelfMoved = bSelfMoved;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceivePointDamage
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShotFromDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActor::ReceivePointDamage(float Damage, const class UDamageType* DamageType, const struct FVector& HitLocation, const struct FVector& HitNormal, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& ShotFromDirection, class AController* InstigatedBy, class AActor* DamageCauser, const struct FHitResult& HitInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceivePointDamage");

	Params::Actor_ReceivePointDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.HitComponent = HitComponent;
	Parms.BoneName = BoneName;
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.HitInfo = std::move(HitInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveRadialDamage
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   DamageReceived                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveRadialDamage(float DamageReceived, const class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveRadialDamage");

	Params::Actor_ReceiveRadialDamage Parms{};

	Parms.DamageReceived = DamageReceived;
	Parms.DamageType = DamageType;
	Parms.Origin = std::move(Origin);
	Parms.HitInfo = std::move(HitInfo);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveTick");

	Params::Actor_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.RemoveTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PrerequisiteActor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveTickPrerequisiteActor");

	Params::Actor_RemoveTickPrerequisiteActor Parms{};

	Parms.PrerequisiteActor = PrerequisiteActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.RemoveTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  PrerequisiteComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveTickPrerequisiteComponent");

	Params::Actor_RemoveTickPrerequisiteComponent Parms{};

	Parms.PrerequisiteComponent = PrerequisiteComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetActorEnableCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewActorEnableCollision                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorEnableCollision(bool bNewActorEnableCollision)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActorEnableCollision");

	Params::Actor_SetActorEnableCollision Parms{};

	Parms.bNewActorEnableCollision = bNewActorEnableCollision;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetActorHiddenInGame
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewHidden                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorHiddenInGame(bool bNewHidden)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActorHiddenInGame");

	Params::Actor_SetActorHiddenInGame Parms{};

	Parms.bNewHidden = bNewHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetActorRelativeScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewRelativeScale                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorRelativeScale3D(const struct FVector& NewRelativeScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActorRelativeScale3D");

	Params::Actor_SetActorRelativeScale3D Parms{};

	Parms.NewRelativeScale = std::move(NewRelativeScale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetActorScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewScale3D                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorScale3D(const struct FVector& NewScale3D)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActorScale3D");

	Params::Actor_SetActorScale3D Parms{};

	Parms.NewScale3D = std::move(NewScale3D);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetActorTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorTickEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActorTickEnabled");

	Params::Actor_SetActorTickEnabled Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetActorTickInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TickInterval                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetActorTickInterval(float TickInterval)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActorTickInterval");

	Params::Actor_SetActorTickInterval Parms{};

	Parms.TickInterval = TickInterval;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetAutoDestroyWhenFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetAutoDestroyWhenFinished(bool bVal)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAutoDestroyWhenFinished");

	Params::Actor_SetAutoDestroyWhenFinished Parms{};

	Parms.bVal = bVal;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetLifeSpan
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InLifespan                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetLifeSpan(float InLifespan)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLifeSpan");

	Params::Actor_SetLifeSpan Parms{};

	Parms.InLifespan = InLifespan;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetNetDormancy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ENetDormancy                            NewDormancy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetNetDormancy(ENetDormancy NewDormancy)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNetDormancy");

	Params::Actor_SetNetDormancy Parms{};

	Parms.NewDormancy = NewDormancy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetOwner
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewOwner                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetOwner(class AActor* NewOwner)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOwner");

	Params::Actor_SetOwner Parms{};

	Parms.NewOwner = NewOwner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetRayTracingGroupId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InRaytracingGroupId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetRayTracingGroupId(int32 InRaytracingGroupId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRayTracingGroupId");

	Params::Actor_SetRayTracingGroupId Parms{};

	Parms.InRaytracingGroupId = InRaytracingGroupId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetReplicateMovement
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInReplicateMovement                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetReplicateMovement(bool bInReplicateMovement)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetReplicateMovement");

	Params::Actor_SetReplicateMovement Parms{};

	Parms.bInReplicateMovement = bInReplicateMovement;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetReplicates
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInReplicates                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetReplicates(bool bInReplicates)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetReplicates");

	Params::Actor_SetReplicates Parms{};

	Parms.bInReplicates = bInReplicates;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bTickableWhenPaused                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetTickableWhenPaused(bool bTickableWhenPaused)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTickableWhenPaused");

	Params::Actor_SetTickableWhenPaused Parms{};

	Parms.bTickableWhenPaused = bTickableWhenPaused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.SetTickGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           NewTickGroup                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::SetTickGroup(ETickingGroup NewTickGroup)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTickGroup");

	Params::Actor_SetTickGroup Parms{};

	Parms.NewTickGroup = NewTickGroup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Actor.TearOff
// (Native, Public, BlueprintCallable)

void AActor::TearOff()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TearOff");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.UserConstructionScript
// (Event, Public, BlueprintEvent)

void AActor::UserConstructionScript()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Actor.ActorHasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::ActorHasTag(class FName Tag) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ActorHasTag");

	Params::Actor_ActorHasTag Parms{};

	Parms.Tag = Tag;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetActorBounds
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bOnlyCollidingComponents                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeFromChildActors                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::GetActorBounds(bool bOnlyCollidingComponents, struct FVector* Origin, struct FVector* BoxExtent, bool bIncludeFromChildActors) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorBounds");

	Params::Actor_GetActorBounds Parms{};

	Parms.bOnlyCollidingComponents = bOnlyCollidingComponents;
	Parms.bIncludeFromChildActors = bIncludeFromChildActors;

	UObject::ProcessEvent(Func, &Parms);

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);
}


// Function Engine.Actor.GetActorEnableCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::GetActorEnableCollision() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorEnableCollision");

	Params::Actor_GetActorEnableCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetActorEyesViewPoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AActor::GetActorEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorEyesViewPoint");

	Params::Actor_GetActorEyesViewPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function Engine.Actor.GetActorForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorForwardVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorForwardVector");

	Params::Actor_GetActorForwardVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetActorRelativeScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorRelativeScale3D() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorRelativeScale3D");

	Params::Actor_GetActorRelativeScale3D Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetActorRightVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorRightVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorRightVector");

	Params::Actor_GetActorRightVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetActorScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorScale3D() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorScale3D");

	Params::Actor_GetActorScale3D Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetActorTickInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetActorTickInterval() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorTickInterval");

	Params::Actor_GetActorTickInterval Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetActorTimeDilation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetActorTimeDilation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorTimeDilation");

	Params::Actor_GetActorTimeDilation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetActorUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetActorUpVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorUpVector");

	Params::Actor_GetActorUpVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetAllChildActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   ChildActors                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeDescendants                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::GetAllChildActors(TArray<class AActor*>* ChildActors, bool bIncludeDescendants) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllChildActors");

	Params::Actor_GetAllChildActors Parms{};

	Parms.bIncludeDescendants = bIncludeDescendants;

	UObject::ProcessEvent(Func, &Parms);

	if (ChildActors != nullptr)
		*ChildActors = std::move(Parms.ChildActors);
}


// Function Engine.Actor.GetAttachedActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bResetArray                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::GetAttachedActors(TArray<class AActor*>* OutActors, bool bResetArray) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAttachedActors");

	Params::Actor_GetAttachedActors Parms{};

	Parms.bResetArray = bResetArray;

	UObject::ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Engine.Actor.GetAttachParentActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AActor::GetAttachParentActor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAttachParentActor");

	Params::Actor_GetAttachParentActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetAttachParentSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AActor::GetAttachParentSocketName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAttachParentSocketName");

	Params::Actor_GetAttachParentSocketName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetComponentByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* AActor::GetComponentByClass(TSubclassOf<class UActorComponent> ComponentClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetComponentByClass");

	Params::Actor_GetComponentByClass Parms{};

	Parms.ComponentClass = ComponentClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetComponentsByInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class IInterface>           Interface                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> AActor::GetComponentsByInterface(TSubclassOf<class IInterface> Interface) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetComponentsByInterface");

	Params::Actor_GetComponentsByInterface Parms{};

	Parms.Interface = Interface;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetComponentsByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> AActor::GetComponentsByTag(TSubclassOf<class UActorComponent> ComponentClass, class FName Tag) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetComponentsByTag");

	Params::Actor_GetComponentsByTag Parms{};

	Parms.ComponentClass = ComponentClass;
	Parms.Tag = Tag;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetDistanceTo(const class AActor* OtherActor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDistanceTo");

	Params::Actor_GetDistanceTo Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetDotProductTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetDotProductTo(const class AActor* OtherActor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDotProductTo");

	Params::Actor_GetDotProductTo Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetGameTimeSinceCreation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetGameTimeSinceCreation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGameTimeSinceCreation");

	Params::Actor_GetGameTimeSinceCreation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetHorizontalDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetHorizontalDistanceTo(const class AActor* OtherActor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHorizontalDistanceTo");

	Params::Actor_GetHorizontalDistanceTo Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetHorizontalDotProductTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetHorizontalDotProductTo(const class AActor* OtherActor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHorizontalDotProductTo");

	Params::Actor_GetHorizontalDotProductTo Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetInputAxisKeyValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             InputAxisKey                                           (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetInputAxisKeyValue(const struct FKey& InputAxisKey) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputAxisKeyValue");

	Params::Actor_GetInputAxisKeyValue Parms{};

	Parms.InputAxisKey = std::move(InputAxisKey);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetInputAxisValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InputAxisName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetInputAxisValue(const class FName InputAxisName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputAxisValue");

	Params::Actor_GetInputAxisValue Parms{};

	Parms.InputAxisName = InputAxisName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetInputVectorAxisValue
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             InputAxisKey                                           (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetInputVectorAxisValue(const struct FKey& InputAxisKey) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputVectorAxisValue");

	Params::Actor_GetInputVectorAxisValue Parms{};

	Parms.InputAxisKey = std::move(InputAxisKey);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AActor::GetInstigator() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstigator");

	Params::Actor_GetInstigator Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetInstigatorController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* AActor::GetInstigatorController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstigatorController");

	Params::Actor_GetInstigatorController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULevel*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* AActor::GetLevel() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLevel");

	Params::Actor_GetLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetLevelTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AActor::GetLevelTransform() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLevelTransform");

	Params::Actor_GetLevelTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetLifeSpan
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetLifeSpan() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLifeSpan");

	Params::Actor_GetLifeSpan Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetLocalRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENetRole                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENetRole AActor::GetLocalRole() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocalRole");

	Params::Actor_GetLocalRole Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetOverlappingActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   OverlappingActors                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AActor::GetOverlappingActors(TArray<class AActor*>* OverlappingActors, TSubclassOf<class AActor> ClassFilter) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOverlappingActors");

	Params::Actor_GetOverlappingActors Parms{};

	Parms.ClassFilter = ClassFilter;

	UObject::ProcessEvent(Func, &Parms);

	if (OverlappingActors != nullptr)
		*OverlappingActors = std::move(Parms.OverlappingActors);
}


// Function Engine.Actor.GetOverlappingComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UPrimitiveComponent*>      OverlappingComponents                                  (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AActor::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* OverlappingComponents) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOverlappingComponents");

	Params::Actor_GetOverlappingComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OverlappingComponents != nullptr)
		*OverlappingComponents = std::move(Parms.OverlappingComponents);
}


// Function Engine.Actor.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AActor::GetOwner() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwner");

	Params::Actor_GetOwner Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetParentActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AActor::GetParentActor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParentActor");

	Params::Actor_GetParentActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetParentComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChildActorComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChildActorComponent* AActor::GetParentComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParentComponent");

	Params::Actor_GetParentComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetRayTracingGroupId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AActor::GetRayTracingGroupId() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRayTracingGroupId");

	Params::Actor_GetRayTracingGroupId Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetRemoteRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ENetRole                                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENetRole AActor::GetRemoteRole() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRemoteRole");

	Params::Actor_GetRemoteRole Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetSquaredDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetSquaredDistanceTo(const class AActor* OtherActor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSquaredDistanceTo");

	Params::Actor_GetSquaredDistanceTo Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetSquaredHorizontalDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetSquaredHorizontalDistanceTo(const class AActor* OtherActor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSquaredHorizontalDistanceTo");

	Params::Actor_GetSquaredHorizontalDistanceTo Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTransform                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FTransform AActor::GetTransform() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransform");

	Params::Actor_GetTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::GetVelocity() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVelocity");

	Params::Actor_GetVelocity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.GetVerticalDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           OtherActor                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AActor::GetVerticalDistanceTo(const class AActor* OtherActor) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVerticalDistanceTo");

	Params::Actor_GetVerticalDistanceTo Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.HasAuthority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::HasAuthority() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasAuthority");

	Params::Actor_HasAuthority Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.IsActorBeingDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::IsActorBeingDestroyed() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsActorBeingDestroyed");

	Params::Actor_IsActorBeingDestroyed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.IsActorTickEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::IsActorTickEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsActorTickEnabled");

	Params::Actor_IsActorTickEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.IsChildActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::IsChildActor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsChildActor");

	Params::Actor_IsChildActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.IsOverlappingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Other                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::IsOverlappingActor(const class AActor* Other) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOverlappingActor");

	Params::Actor_IsOverlappingActor Parms{};

	Parms.Other = Other;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_GetActorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AActor::K2_GetActorLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetActorLocation");

	Params::Actor_K2_GetActorLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_GetActorRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AActor::K2_GetActorRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetActorRotation");

	Params::Actor_K2_GetActorRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_GetComponentsByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> AActor::K2_GetComponentsByClass(TSubclassOf<class UActorComponent> ComponentClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetComponentsByClass");

	Params::Actor_K2_GetComponentsByClass Parms{};

	Parms.ComponentClass = ComponentClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.K2_GetRootComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AActor::K2_GetRootComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetRootComponent");

	Params::Actor_K2_GetRootComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Actor.WasRecentlyRendered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AActor::WasRecentlyRendered(float Tolerance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasRecentlyRendered");

	Params::Actor_WasRecentlyRendered Parms{};

	Parms.Tolerance = Tolerance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameStateBase.OnRep_GameModeClass
// (Native, Protected)

void AGameStateBase::OnRep_GameModeClass()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_GameModeClass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameStateBase.OnRep_ReplicatedHasBegunPlay
// (Native, Protected)

void AGameStateBase::OnRep_ReplicatedHasBegunPlay()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedHasBegunPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameStateBase.OnRep_ReplicatedWorldTimeSeconds
// (Native, Protected)

void AGameStateBase::OnRep_ReplicatedWorldTimeSeconds()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedWorldTimeSeconds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameStateBase.OnRep_SpectatorClass
// (Native, Protected)

void AGameStateBase::OnRep_SpectatorClass()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_SpectatorClass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameStateBase.GetPlayerRespawnDelay
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGameStateBase::GetPlayerRespawnDelay(class AController* Controller) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayerRespawnDelay");

	Params::GameStateBase_GetPlayerRespawnDelay Parms{};

	Parms.Controller = Controller;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameStateBase.GetPlayerStartTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGameStateBase::GetPlayerStartTime(class AController* Controller) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayerStartTime");

	Params::GameStateBase_GetPlayerStartTime Parms{};

	Parms.Controller = Controller;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameStateBase.GetServerWorldTimeSeconds
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGameStateBase::GetServerWorldTimeSeconds() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetServerWorldTimeSeconds");

	Params::GameStateBase_GetServerWorldTimeSeconds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameStateBase.HasBegunPlay
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameStateBase::HasBegunPlay() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasBegunPlay");

	Params::GameStateBase_HasBegunPlay Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameStateBase.HasMatchEnded
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameStateBase::HasMatchEnded() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasMatchEnded");

	Params::GameStateBase_HasMatchEnded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameStateBase.HasMatchStarted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameStateBase::HasMatchStarted() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasMatchStarted");

	Params::GameStateBase_HasMatchStarted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.CopyParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FConstraintInstanceAccessor      SourceAccessor                                         (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bKeepPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeepRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::CopyParams(struct FConstraintInstanceAccessor& Accessor, struct FConstraintInstanceAccessor& SourceAccessor, bool bKeepPosition, bool bKeepRotation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CopyParams");

	Params::ConstraintInstanceBlueprintLibrary_CopyParams Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.SourceAccessor = std::move(SourceAccessor);
	Parms.bKeepPosition = bKeepPosition;
	Parms.bKeepRotation = bKeepRotation;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
	SourceAccessor = std::move(Parms.SourceAccessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularBreakable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAngularBreakable                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularBreakThreshold                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularBreakable(struct FConstraintInstanceAccessor& Accessor, bool* bAngularBreakable, float* AngularBreakThreshold)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularBreakable");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularBreakable Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bAngularBreakable != nullptr)
		*bAngularBreakable = Parms.bAngularBreakable;

	if (AngularBreakThreshold != nullptr)
		*AngularBreakThreshold = Parms.AngularBreakThreshold;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularDriveMode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAngularDriveMode                       OutDriveMode                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularDriveMode(struct FConstraintInstanceAccessor& Accessor, EAngularDriveMode* OutDriveMode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularDriveMode");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularDriveMode Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (OutDriveMode != nullptr)
		*OutDriveMode = Parms.OutDriveMode;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularDriveParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OutPositionStrength                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutVelocityStrength                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutForceLimit                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularDriveParams(struct FConstraintInstanceAccessor& Accessor, float* OutPositionStrength, float* OutVelocityStrength, float* OutForceLimit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularDriveParams");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularDriveParams Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (OutPositionStrength != nullptr)
		*OutPositionStrength = Parms.OutPositionStrength;

	if (OutVelocityStrength != nullptr)
		*OutVelocityStrength = Parms.OutVelocityStrength;

	if (OutForceLimit != nullptr)
		*OutForceLimit = Parms.OutForceLimit;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularLimits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAngularConstraintMotion                Swing1MotionType                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing1LimitAngle                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAngularConstraintMotion                Swing2MotionType                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing2LimitAngle                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAngularConstraintMotion                TwistMotionType                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitAngle                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularLimits(struct FConstraintInstanceAccessor& Accessor, EAngularConstraintMotion* Swing1MotionType, float* Swing1LimitAngle, EAngularConstraintMotion* Swing2MotionType, float* Swing2LimitAngle, EAngularConstraintMotion* TwistMotionType, float* TwistLimitAngle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularLimits");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularLimits Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (Swing1MotionType != nullptr)
		*Swing1MotionType = Parms.Swing1MotionType;

	if (Swing1LimitAngle != nullptr)
		*Swing1LimitAngle = Parms.Swing1LimitAngle;

	if (Swing2MotionType != nullptr)
		*Swing2MotionType = Parms.Swing2MotionType;

	if (Swing2LimitAngle != nullptr)
		*Swing2LimitAngle = Parms.Swing2LimitAngle;

	if (TwistMotionType != nullptr)
		*TwistMotionType = Parms.TwistMotionType;

	if (TwistLimitAngle != nullptr)
		*TwistLimitAngle = Parms.TwistLimitAngle;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularOrientationTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         OutPosTarget                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularOrientationTarget(struct FConstraintInstanceAccessor& Accessor, struct FRotator* OutPosTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularOrientationTarget");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularOrientationTarget Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (OutPosTarget != nullptr)
		*OutPosTarget = std::move(Parms.OutPosTarget);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularPlasticity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAngularPlasticity                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularPlasticityThreshold                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularPlasticity(struct FConstraintInstanceAccessor& Accessor, bool* bAngularPlasticity, float* AngularPlasticityThreshold)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularPlasticity");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularPlasticity Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bAngularPlasticity != nullptr)
		*bAngularPlasticity = Parms.bAngularPlasticity;

	if (AngularPlasticityThreshold != nullptr)
		*AngularPlasticityThreshold = Parms.AngularPlasticityThreshold;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularSoftSwingLimitParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSoftSwingLimit                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwingLimitStiffness                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwingLimitDamping                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwingLimitRestitution                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwingLimitContactDistance                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularSoftSwingLimitParams(struct FConstraintInstanceAccessor& Accessor, bool* bSoftSwingLimit, float* SwingLimitStiffness, float* SwingLimitDamping, float* SwingLimitRestitution, float* SwingLimitContactDistance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularSoftSwingLimitParams");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularSoftSwingLimitParams Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bSoftSwingLimit != nullptr)
		*bSoftSwingLimit = Parms.bSoftSwingLimit;

	if (SwingLimitStiffness != nullptr)
		*SwingLimitStiffness = Parms.SwingLimitStiffness;

	if (SwingLimitDamping != nullptr)
		*SwingLimitDamping = Parms.SwingLimitDamping;

	if (SwingLimitRestitution != nullptr)
		*SwingLimitRestitution = Parms.SwingLimitRestitution;

	if (SwingLimitContactDistance != nullptr)
		*SwingLimitContactDistance = Parms.SwingLimitContactDistance;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularSoftTwistLimitParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSoftTwistLimit                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitStiffness                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitDamping                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitRestitution                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitContactDistance                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularSoftTwistLimitParams(struct FConstraintInstanceAccessor& Accessor, bool* bSoftTwistLimit, float* TwistLimitStiffness, float* TwistLimitDamping, float* TwistLimitRestitution, float* TwistLimitContactDistance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularSoftTwistLimitParams");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularSoftTwistLimitParams Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bSoftTwistLimit != nullptr)
		*bSoftTwistLimit = Parms.bSoftTwistLimit;

	if (TwistLimitStiffness != nullptr)
		*TwistLimitStiffness = Parms.TwistLimitStiffness;

	if (TwistLimitDamping != nullptr)
		*TwistLimitDamping = Parms.TwistLimitDamping;

	if (TwistLimitRestitution != nullptr)
		*TwistLimitRestitution = Parms.TwistLimitRestitution;

	if (TwistLimitContactDistance != nullptr)
		*TwistLimitContactDistance = Parms.TwistLimitContactDistance;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularVelocityDriveSLERP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutEnableSLERP                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularVelocityDriveSLERP(struct FConstraintInstanceAccessor& Accessor, bool* bOutEnableSLERP)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularVelocityDriveSLERP");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularVelocityDriveSLERP Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bOutEnableSLERP != nullptr)
		*bOutEnableSLERP = Parms.bOutEnableSLERP;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularVelocityDriveTwistAndSwing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutEnableTwistDrive                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnableSwingDrive                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularVelocityDriveTwistAndSwing(struct FConstraintInstanceAccessor& Accessor, bool* bOutEnableTwistDrive, bool* bOutEnableSwingDrive)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularVelocityDriveTwistAndSwing");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularVelocityDriveTwistAndSwing Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bOutEnableTwistDrive != nullptr)
		*bOutEnableTwistDrive = Parms.bOutEnableTwistDrive;

	if (bOutEnableSwingDrive != nullptr)
		*bOutEnableSwingDrive = Parms.bOutEnableSwingDrive;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAngularVelocityTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutVelTarget                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAngularVelocityTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector* OutVelTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAngularVelocityTarget");

	Params::ConstraintInstanceBlueprintLibrary_GetAngularVelocityTarget Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (OutVelTarget != nullptr)
		*OutVelTarget = std::move(Parms.OutVelTarget);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetAttachedBodyNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ParentBody                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ChildBody                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetAttachedBodyNames(struct FConstraintInstanceAccessor& Accessor, class FName* ParentBody, class FName* ChildBody)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAttachedBodyNames");

	Params::ConstraintInstanceBlueprintLibrary_GetAttachedBodyNames Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (ParentBody != nullptr)
		*ParentBody = Parms.ParentBody;

	if (ChildBody != nullptr)
		*ChildBody = Parms.ChildBody;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetDisableCollsion
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConstraintInstanceBlueprintLibrary::GetDisableCollsion(struct FConstraintInstanceAccessor& Accessor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDisableCollsion");

	Params::ConstraintInstanceBlueprintLibrary_GetDisableCollsion Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	return Parms.ReturnValue;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearBreakable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bLinearBreakable                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearBreakThreshold                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearBreakable(struct FConstraintInstanceAccessor& Accessor, bool* bLinearBreakable, float* LinearBreakThreshold)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearBreakable");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearBreakable Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bLinearBreakable != nullptr)
		*bLinearBreakable = Parms.bLinearBreakable;

	if (LinearBreakThreshold != nullptr)
		*LinearBreakThreshold = Parms.LinearBreakThreshold;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearDriveParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OutPositionStrength                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutVelocityStrength                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutForceLimit                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearDriveParams(struct FConstraintInstanceAccessor& Accessor, float* OutPositionStrength, float* OutVelocityStrength, float* OutForceLimit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearDriveParams");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearDriveParams Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (OutPositionStrength != nullptr)
		*OutPositionStrength = Parms.OutPositionStrength;

	if (OutVelocityStrength != nullptr)
		*OutVelocityStrength = Parms.OutVelocityStrength;

	if (OutForceLimit != nullptr)
		*OutForceLimit = Parms.OutForceLimit;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearLimits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ELinearConstraintMotion                 XMotion                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELinearConstraintMotion                 YMotion                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELinearConstraintMotion                 ZMotion                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Limit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearLimits(struct FConstraintInstanceAccessor& Accessor, ELinearConstraintMotion* XMotion, ELinearConstraintMotion* YMotion, ELinearConstraintMotion* ZMotion, float* Limit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearLimits");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearLimits Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (XMotion != nullptr)
		*XMotion = Parms.XMotion;

	if (YMotion != nullptr)
		*YMotion = Parms.YMotion;

	if (ZMotion != nullptr)
		*ZMotion = Parms.ZMotion;

	if (Limit != nullptr)
		*Limit = Parms.Limit;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearPlasticity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bLinearPlasticity                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearPlasticityThreshold                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConstraintPlasticityType               PlasticityType                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearPlasticity(struct FConstraintInstanceAccessor& Accessor, bool* bLinearPlasticity, float* LinearPlasticityThreshold, EConstraintPlasticityType* PlasticityType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearPlasticity");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearPlasticity Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bLinearPlasticity != nullptr)
		*bLinearPlasticity = Parms.bLinearPlasticity;

	if (LinearPlasticityThreshold != nullptr)
		*LinearPlasticityThreshold = Parms.LinearPlasticityThreshold;

	if (PlasticityType != nullptr)
		*PlasticityType = Parms.PlasticityType;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearPositionDrive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutEnableDriveX                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnableDriveY                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnableDriveZ                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearPositionDrive(struct FConstraintInstanceAccessor& Accessor, bool* bOutEnableDriveX, bool* bOutEnableDriveY, bool* bOutEnableDriveZ)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearPositionDrive");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearPositionDrive Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bOutEnableDriveX != nullptr)
		*bOutEnableDriveX = Parms.bOutEnableDriveX;

	if (bOutEnableDriveY != nullptr)
		*bOutEnableDriveY = Parms.bOutEnableDriveY;

	if (bOutEnableDriveZ != nullptr)
		*bOutEnableDriveZ = Parms.bOutEnableDriveZ;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearPositionTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutPosTarget                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearPositionTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector* OutPosTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearPositionTarget");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearPositionTarget Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (OutPosTarget != nullptr)
		*OutPosTarget = std::move(Parms.OutPosTarget);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearSoftLimitParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSoftLinearLimit                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearLimitStiffness                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearLimitDamping                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearLimitRestitution                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearLimitContactDistance                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearSoftLimitParams(struct FConstraintInstanceAccessor& Accessor, bool* bSoftLinearLimit, float* LinearLimitStiffness, float* LinearLimitDamping, float* LinearLimitRestitution, float* LinearLimitContactDistance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearSoftLimitParams");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearSoftLimitParams Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bSoftLinearLimit != nullptr)
		*bSoftLinearLimit = Parms.bSoftLinearLimit;

	if (LinearLimitStiffness != nullptr)
		*LinearLimitStiffness = Parms.LinearLimitStiffness;

	if (LinearLimitDamping != nullptr)
		*LinearLimitDamping = Parms.LinearLimitDamping;

	if (LinearLimitRestitution != nullptr)
		*LinearLimitRestitution = Parms.LinearLimitRestitution;

	if (LinearLimitContactDistance != nullptr)
		*LinearLimitContactDistance = Parms.LinearLimitContactDistance;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearVelocityDrive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutEnableDriveX                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnableDriveY                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnableDriveZ                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearVelocityDrive(struct FConstraintInstanceAccessor& Accessor, bool* bOutEnableDriveX, bool* bOutEnableDriveY, bool* bOutEnableDriveZ)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearVelocityDrive");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearVelocityDrive Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bOutEnableDriveX != nullptr)
		*bOutEnableDriveX = Parms.bOutEnableDriveX;

	if (bOutEnableDriveY != nullptr)
		*bOutEnableDriveY = Parms.bOutEnableDriveY;

	if (bOutEnableDriveZ != nullptr)
		*bOutEnableDriveZ = Parms.bOutEnableDriveZ;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetLinearVelocityTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutVelTarget                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetLinearVelocityTarget(struct FConstraintInstanceAccessor& Accessor, struct FVector* OutVelTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLinearVelocityTarget");

	Params::ConstraintInstanceBlueprintLibrary_GetLinearVelocityTarget Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (OutVelTarget != nullptr)
		*OutVelTarget = std::move(Parms.OutVelTarget);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetOrientationDriveSLERP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutEnableSLERP                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetOrientationDriveSLERP(struct FConstraintInstanceAccessor& Accessor, bool* bOutEnableSLERP)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetOrientationDriveSLERP");

	Params::ConstraintInstanceBlueprintLibrary_GetOrientationDriveSLERP Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bOutEnableSLERP != nullptr)
		*bOutEnableSLERP = Parms.bOutEnableSLERP;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetOrientationDriveTwistAndSwing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutEnableTwistDrive                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutEnableSwingDrive                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetOrientationDriveTwistAndSwing(struct FConstraintInstanceAccessor& Accessor, bool* bOutEnableTwistDrive, bool* bOutEnableSwingDrive)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetOrientationDriveTwistAndSwing");

	Params::ConstraintInstanceBlueprintLibrary_GetOrientationDriveTwistAndSwing Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bOutEnableTwistDrive != nullptr)
		*bOutEnableTwistDrive = Parms.bOutEnableTwistDrive;

	if (bOutEnableSwingDrive != nullptr)
		*bOutEnableSwingDrive = Parms.bOutEnableSwingDrive;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetParentDominates
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UConstraintInstanceBlueprintLibrary::GetParentDominates(struct FConstraintInstanceAccessor& Accessor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetParentDominates");

	Params::ConstraintInstanceBlueprintLibrary_GetParentDominates Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	return Parms.ReturnValue;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.GetProjectionParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableProjection                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ProjectionLinearAlpha                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ProjectionAngularAlpha                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::GetProjectionParams(struct FConstraintInstanceAccessor& Accessor, bool* bEnableProjection, float* ProjectionLinearAlpha, float* ProjectionAngularAlpha)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProjectionParams");

	Params::ConstraintInstanceBlueprintLibrary_GetProjectionParams Parms{};

	Parms.Accessor = std::move(Accessor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);

	if (bEnableProjection != nullptr)
		*bEnableProjection = Parms.bEnableProjection;

	if (ProjectionLinearAlpha != nullptr)
		*ProjectionLinearAlpha = Parms.ProjectionLinearAlpha;

	if (ProjectionAngularAlpha != nullptr)
		*ProjectionAngularAlpha = Parms.ProjectionAngularAlpha;
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularBreakable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAngularBreakable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularBreakThreshold                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularBreakable(struct FConstraintInstanceAccessor& Accessor, bool bAngularBreakable, float AngularBreakThreshold)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularBreakable");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularBreakable Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bAngularBreakable = bAngularBreakable;
	Parms.AngularBreakThreshold = AngularBreakThreshold;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularDriveMode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAngularDriveMode                       DriveMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularDriveMode(struct FConstraintInstanceAccessor& Accessor, EAngularDriveMode DriveMode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularDriveMode");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularDriveMode Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.DriveMode = DriveMode;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularDriveParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   PositionStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VelocityStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForceLimit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularDriveParams(struct FConstraintInstanceAccessor& Accessor, float PositionStrength, float VelocityStrength, float InForceLimit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularDriveParams");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularDriveParams Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.PositionStrength = PositionStrength;
	Parms.VelocityStrength = VelocityStrength;
	Parms.InForceLimit = InForceLimit;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularLimits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAngularConstraintMotion                Swing1MotionType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing1LimitAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAngularConstraintMotion                Swing2MotionType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing2LimitAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAngularConstraintMotion                TwistMotionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitAngle                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularLimits(struct FConstraintInstanceAccessor& Accessor, EAngularConstraintMotion Swing1MotionType, float Swing1LimitAngle, EAngularConstraintMotion Swing2MotionType, float Swing2LimitAngle, EAngularConstraintMotion TwistMotionType, float TwistLimitAngle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularLimits");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularLimits Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.Swing1MotionType = Swing1MotionType;
	Parms.Swing1LimitAngle = Swing1LimitAngle;
	Parms.Swing2MotionType = Swing2MotionType;
	Parms.Swing2LimitAngle = Swing2LimitAngle;
	Parms.TwistMotionType = TwistMotionType;
	Parms.TwistLimitAngle = TwistLimitAngle;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularOrientationTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         InPosTarget                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularOrientationTarget(struct FConstraintInstanceAccessor& Accessor, const struct FRotator& InPosTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularOrientationTarget");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularOrientationTarget Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.InPosTarget = std::move(InPosTarget);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularPlasticity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAngularPlasticity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularPlasticityThreshold                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularPlasticity(struct FConstraintInstanceAccessor& Accessor, bool bAngularPlasticity, float AngularPlasticityThreshold)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularPlasticity");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularPlasticity Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bAngularPlasticity = bAngularPlasticity;
	Parms.AngularPlasticityThreshold = AngularPlasticityThreshold;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularSoftSwingLimitParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSoftSwingLimit                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwingLimitStiffness                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwingLimitDamping                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwingLimitRestitution                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwingLimitContactDistance                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularSoftSwingLimitParams(struct FConstraintInstanceAccessor& Accessor, bool bSoftSwingLimit, float SwingLimitStiffness, float SwingLimitDamping, float SwingLimitRestitution, float SwingLimitContactDistance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularSoftSwingLimitParams");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularSoftSwingLimitParams Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bSoftSwingLimit = bSoftSwingLimit;
	Parms.SwingLimitStiffness = SwingLimitStiffness;
	Parms.SwingLimitDamping = SwingLimitDamping;
	Parms.SwingLimitRestitution = SwingLimitRestitution;
	Parms.SwingLimitContactDistance = SwingLimitContactDistance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularSoftTwistLimitParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSoftTwistLimit                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitStiffness                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitDamping                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitRestitution                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitContactDistance                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularSoftTwistLimitParams(struct FConstraintInstanceAccessor& Accessor, bool bSoftTwistLimit, float TwistLimitStiffness, float TwistLimitDamping, float TwistLimitRestitution, float TwistLimitContactDistance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularSoftTwistLimitParams");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularSoftTwistLimitParams Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bSoftTwistLimit = bSoftTwistLimit;
	Parms.TwistLimitStiffness = TwistLimitStiffness;
	Parms.TwistLimitDamping = TwistLimitDamping;
	Parms.TwistLimitRestitution = TwistLimitRestitution;
	Parms.TwistLimitContactDistance = TwistLimitContactDistance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularVelocityDriveSLERP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableSLERP                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularVelocityDriveSLERP(struct FConstraintInstanceAccessor& Accessor, bool bEnableSLERP)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularVelocityDriveSLERP");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularVelocityDriveSLERP Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bEnableSLERP = bEnableSLERP;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularVelocityDriveTwistAndSwing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableTwistDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableSwingDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularVelocityDriveTwistAndSwing(struct FConstraintInstanceAccessor& Accessor, bool bEnableTwistDrive, bool bEnableSwingDrive)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularVelocityDriveTwistAndSwing");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularVelocityDriveTwistAndSwing Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bEnableSwingDrive = bEnableSwingDrive;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetAngularVelocityTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          InVelTarget                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetAngularVelocityTarget(struct FConstraintInstanceAccessor& Accessor, const struct FVector& InVelTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetAngularVelocityTarget");

	Params::ConstraintInstanceBlueprintLibrary_SetAngularVelocityTarget Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.InVelTarget = std::move(InVelTarget);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetDisableCollision
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bDisableCollision                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetDisableCollision(struct FConstraintInstanceAccessor& Accessor, bool bDisableCollision)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetDisableCollision");

	Params::ConstraintInstanceBlueprintLibrary_SetDisableCollision Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bDisableCollision = bDisableCollision;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearBreakable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bLinearBreakable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearBreakThreshold                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearBreakable(struct FConstraintInstanceAccessor& Accessor, bool bLinearBreakable, float LinearBreakThreshold)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearBreakable");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearBreakable Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bLinearBreakable = bLinearBreakable;
	Parms.LinearBreakThreshold = LinearBreakThreshold;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearDriveParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   PositionStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VelocityStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForceLimit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearDriveParams(struct FConstraintInstanceAccessor& Accessor, float PositionStrength, float VelocityStrength, float InForceLimit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearDriveParams");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearDriveParams Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.PositionStrength = PositionStrength;
	Parms.VelocityStrength = VelocityStrength;
	Parms.InForceLimit = InForceLimit;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearLimits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ELinearConstraintMotion                 XMotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELinearConstraintMotion                 YMotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELinearConstraintMotion                 ZMotion                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Limit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearLimits(struct FConstraintInstanceAccessor& Accessor, ELinearConstraintMotion XMotion, ELinearConstraintMotion YMotion, ELinearConstraintMotion ZMotion, float Limit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearLimits");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearLimits Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.XMotion = XMotion;
	Parms.YMotion = YMotion;
	Parms.ZMotion = ZMotion;
	Parms.Limit = Limit;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearPlasticity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bLinearPlasticity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearPlasticityThreshold                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConstraintPlasticityType               PlasticityType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearPlasticity(struct FConstraintInstanceAccessor& Accessor, bool bLinearPlasticity, float LinearPlasticityThreshold, EConstraintPlasticityType PlasticityType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearPlasticity");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearPlasticity Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bLinearPlasticity = bLinearPlasticity;
	Parms.LinearPlasticityThreshold = LinearPlasticityThreshold;
	Parms.PlasticityType = PlasticityType;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearPositionDrive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveX                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveY                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveZ                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearPositionDrive(struct FConstraintInstanceAccessor& Accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearPositionDrive");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearPositionDrive Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bEnableDriveX = bEnableDriveX;
	Parms.bEnableDriveY = bEnableDriveY;
	Parms.bEnableDriveZ = bEnableDriveZ;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearPositionTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          InPosTarget                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearPositionTarget(struct FConstraintInstanceAccessor& Accessor, const struct FVector& InPosTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearPositionTarget");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearPositionTarget Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.InPosTarget = std::move(InPosTarget);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearSoftLimitParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSoftLinearLimit                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearLimitStiffness                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearLimitDamping                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearLimitRestitution                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearLimitContactDistance                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearSoftLimitParams(struct FConstraintInstanceAccessor& Accessor, bool bSoftLinearLimit, float LinearLimitStiffness, float LinearLimitDamping, float LinearLimitRestitution, float LinearLimitContactDistance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearSoftLimitParams");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearSoftLimitParams Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bSoftLinearLimit = bSoftLinearLimit;
	Parms.LinearLimitStiffness = LinearLimitStiffness;
	Parms.LinearLimitDamping = LinearLimitDamping;
	Parms.LinearLimitRestitution = LinearLimitRestitution;
	Parms.LinearLimitContactDistance = LinearLimitContactDistance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearVelocityDrive
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveX                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveY                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveZ                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearVelocityDrive(struct FConstraintInstanceAccessor& Accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearVelocityDrive");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearVelocityDrive Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bEnableDriveX = bEnableDriveX;
	Parms.bEnableDriveY = bEnableDriveY;
	Parms.bEnableDriveZ = bEnableDriveZ;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetLinearVelocityTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          InVelTarget                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetLinearVelocityTarget(struct FConstraintInstanceAccessor& Accessor, const struct FVector& InVelTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearVelocityTarget");

	Params::ConstraintInstanceBlueprintLibrary_SetLinearVelocityTarget Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.InVelTarget = std::move(InVelTarget);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetOrientationDriveSLERP
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableSLERP                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetOrientationDriveSLERP(struct FConstraintInstanceAccessor& Accessor, bool bEnableSLERP)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetOrientationDriveSLERP");

	Params::ConstraintInstanceBlueprintLibrary_SetOrientationDriveSLERP Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bEnableSLERP = bEnableSLERP;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetOrientationDriveTwistAndSwing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableTwistDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableSwingDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetOrientationDriveTwistAndSwing(struct FConstraintInstanceAccessor& Accessor, bool bEnableTwistDrive, bool bEnableSwingDrive)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetOrientationDriveTwistAndSwing");

	Params::ConstraintInstanceBlueprintLibrary_SetOrientationDriveTwistAndSwing Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bEnableSwingDrive = bEnableSwingDrive;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetParentDominates
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bParentDominates                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetParentDominates(struct FConstraintInstanceAccessor& Accessor, bool bParentDominates)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetParentDominates");

	Params::ConstraintInstanceBlueprintLibrary_SetParentDominates Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bParentDominates = bParentDominates;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.ConstraintInstanceBlueprintLibrary.SetProjectionParams
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      Accessor                                               (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnableProjection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ProjectionLinearAlpha                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ProjectionAngularAlpha                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstraintInstanceBlueprintLibrary::SetProjectionParams(struct FConstraintInstanceAccessor& Accessor, bool bEnableProjection, float ProjectionLinearAlpha, float ProjectionAngularAlpha)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetProjectionParams");

	Params::ConstraintInstanceBlueprintLibrary_SetProjectionParams Parms{};

	Parms.Accessor = std::move(Accessor);
	Parms.bEnableProjection = bEnableProjection;
	Parms.ProjectionLinearAlpha = ProjectionLinearAlpha;
	Parms.ProjectionAngularAlpha = ProjectionAngularAlpha;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Accessor = std::move(Parms.Accessor);
}


// Function Engine.MovementComponent.K2_MoveUpdatedComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementComponent::K2_MoveUpdatedComponent(const struct FVector& Delta, const struct FRotator& NewRotation, struct FHitResult* OutHit, bool bSweep, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_MoveUpdatedComponent");

	Params::MovementComponent_K2_MoveUpdatedComponent Parms{};

	Parms.Delta = std::move(Delta);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.PhysicsVolumeChanged
// (Native, Public)
// Parameters:
// class APhysicsVolume*                   NewVolume                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PhysicsVolumeChanged");

	Params::MovementComponent_PhysicsVolumeChanged Parms{};

	Parms.NewVolume = NewVolume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MovementComponent.SetPlaneConstraintAxisSetting
// (Native, Public, BlueprintCallable)
// Parameters:
// EPlaneConstraintAxisSetting             NewAxisSetting                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintAxisSetting(EPlaneConstraintAxisSetting NewAxisSetting)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlaneConstraintAxisSetting");

	Params::MovementComponent_SetPlaneConstraintAxisSetting Parms{};

	Parms.NewAxisSetting = NewAxisSetting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MovementComponent.SetPlaneConstraintEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlaneConstraintEnabled");

	Params::MovementComponent_SetPlaneConstraintEnabled Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MovementComponent.SetPlaneConstraintFromVectors
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Forward                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Up                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintFromVectors(const struct FVector& Forward, const struct FVector& Up)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlaneConstraintFromVectors");

	Params::MovementComponent_SetPlaneConstraintFromVectors Parms{};

	Parms.Forward = std::move(Forward);
	Parms.Up = std::move(Up);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MovementComponent.SetPlaneConstraintNormal
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          PlaneNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintNormal(const struct FVector& PlaneNormal)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlaneConstraintNormal");

	Params::MovementComponent_SetPlaneConstraintNormal Parms{};

	Parms.PlaneNormal = std::move(PlaneNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MovementComponent.SetPlaneConstraintOrigin
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          PlaneOrigin                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetPlaneConstraintOrigin(const struct FVector& PlaneOrigin)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlaneConstraintOrigin");

	Params::MovementComponent_SetPlaneConstraintOrigin Parms{};

	Parms.PlaneOrigin = std::move(PlaneOrigin);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MovementComponent.SetUpdatedComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  NewUpdatedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementComponent::SetUpdatedComponent(class USceneComponent* NewUpdatedComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUpdatedComponent");

	Params::MovementComponent_SetUpdatedComponent Parms{};

	Parms.NewUpdatedComponent = NewUpdatedComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MovementComponent.SnapUpdatedComponentToPlane
// (Native, Public, BlueprintCallable)

void UMovementComponent::SnapUpdatedComponentToPlane()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SnapUpdatedComponentToPlane");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.MovementComponent.StopMovementImmediately
// (Native, Public, BlueprintCallable)

void UMovementComponent::StopMovementImmediately()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopMovementImmediately");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.MovementComponent.ConstrainDirectionToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementComponent::ConstrainDirectionToPlane(const struct FVector& Direction) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConstrainDirectionToPlane");

	Params::MovementComponent_ConstrainDirectionToPlane Parms{};

	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.ConstrainLocationToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementComponent::ConstrainLocationToPlane(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConstrainLocationToPlane");

	Params::MovementComponent_ConstrainLocationToPlane Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.ConstrainNormalToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementComponent::ConstrainNormalToPlane(const struct FVector& Normal) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConstrainNormalToPlane");

	Params::MovementComponent_ConstrainNormalToPlane Parms{};

	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.GetGravityZ
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementComponent::GetGravityZ() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGravityZ");

	Params::MovementComponent_GetGravityZ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.GetMaxSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementComponent::GetMaxSpeed() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxSpeed");

	Params::MovementComponent_GetMaxSpeed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.GetPhysicsVolume
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APhysicsVolume*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APhysicsVolume* UMovementComponent::GetPhysicsVolume() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicsVolume");

	Params::MovementComponent_GetPhysicsVolume Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.GetPlaneConstraintAxisSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlaneConstraintAxisSetting             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlaneConstraintAxisSetting UMovementComponent::GetPlaneConstraintAxisSetting() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlaneConstraintAxisSetting");

	Params::MovementComponent_GetPlaneConstraintAxisSetting Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.GetPlaneConstraintNormal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UMovementComponent::GetPlaneConstraintNormal() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlaneConstraintNormal");

	Params::MovementComponent_GetPlaneConstraintNormal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.GetPlaneConstraintOrigin
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UMovementComponent::GetPlaneConstraintOrigin() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlaneConstraintOrigin");

	Params::MovementComponent_GetPlaneConstraintOrigin Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MovementComponent.IsExceedingMaxSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementComponent::IsExceedingMaxSpeed(float MaxSpeed) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsExceedingMaxSpeed");

	Params::MovementComponent_IsExceedingMaxSpeed Parms{};

	Parms.MaxSpeed = MaxSpeed;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ProjectileMovementComponent.MoveInterpolationTarget
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::MoveInterpolationTarget(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MoveInterpolationTarget");

	Params::ProjectileMovementComponent_MoveInterpolationTarget Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ProjectileMovementComponent.ResetInterpolation
// (Native, Public, BlueprintCallable)

void UProjectileMovementComponent::ResetInterpolation()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetInterpolation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ProjectileMovementComponent.SetInterpolatedComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::SetInterpolatedComponent(class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInterpolatedComponent");

	Params::ProjectileMovementComponent_SetInterpolatedComponent Parms{};

	Parms.Component = Component;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::SetVelocityInLocalSpace(const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVelocityInLocalSpace");

	Params::ProjectileMovementComponent_SetVelocityInLocalSpace Parms{};

	Parms.NewVelocity = std::move(NewVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ProjectileMovementComponent.StopSimulating
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UProjectileMovementComponent::StopSimulating(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopSimulating");

	Params::ProjectileMovementComponent_StopSimulating Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ProjectileMovementComponent.IsInterpolationComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectileMovementComponent::IsInterpolationComplete() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInterpolationComplete");

	Params::ProjectileMovementComponent_IsInterpolationComplete Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ProjectileMovementComponent.IsVelocityUnderSimulationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectileMovementComponent::IsVelocityUnderSimulationThreshold() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsVelocityUnderSimulationThreshold");

	Params::ProjectileMovementComponent_IsVelocityUnderSimulationThreshold Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ProjectileMovementComponent.LimitVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          NewVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UProjectileMovementComponent::LimitVelocity(const struct FVector& NewVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LimitVelocity");

	Params::ProjectileMovementComponent_LimitVelocity Parms{};

	Parms.NewVelocity = std::move(NewVelocity);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.DetachFromParent
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bMaintainWorldPosition                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCallModify                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::DetachFromParent(bool bMaintainWorldPosition, bool bCallModify)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DetachFromParent");

	Params::SceneComponent_DetachFromParent Parms{};

	Parms.bMaintainWorldPosition = bMaintainWorldPosition;
	Parms.bCallModify = bCallModify;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.K2_AddLocalOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DeltaLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddLocalOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddLocalOffset");

	Params::SceneComponent_K2_AddLocalOffset Parms{};

	Parms.DeltaLocation = std::move(DeltaLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AddLocalRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         DeltaRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddLocalRotation");

	Params::SceneComponent_K2_AddLocalRotation Parms{};

	Parms.DeltaRotation = std::move(DeltaRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AddLocalTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       DeltaTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddLocalTransform(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddLocalTransform");

	Params::SceneComponent_K2_AddLocalTransform Parms{};

	Parms.DeltaTransform = std::move(DeltaTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AddRelativeLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DeltaLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddRelativeLocation(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddRelativeLocation");

	Params::SceneComponent_K2_AddRelativeLocation Parms{};

	Parms.DeltaLocation = std::move(DeltaLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AddRelativeRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         DeltaRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddRelativeRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddRelativeRotation");

	Params::SceneComponent_K2_AddRelativeRotation Parms{};

	Parms.DeltaRotation = std::move(DeltaRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AddWorldOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DeltaLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddWorldOffset(const struct FVector& DeltaLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddWorldOffset");

	Params::SceneComponent_K2_AddWorldOffset Parms{};

	Parms.DeltaLocation = std::move(DeltaLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AddWorldRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         DeltaRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddWorldRotation");

	Params::SceneComponent_K2_AddWorldRotation Parms{};

	Parms.DeltaRotation = std::move(DeltaRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AddWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       DeltaTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddWorldTransform");

	Params::SceneComponent_K2_AddWorldTransform Parms{};

	Parms.DeltaTransform = std::move(DeltaTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AddWorldTransformKeepScale
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       DeltaTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_AddWorldTransformKeepScale(const struct FTransform& DeltaTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AddWorldTransformKeepScale");

	Params::SceneComponent_K2_AddWorldTransformKeepScale Parms{};

	Parms.DeltaTransform = std::move(DeltaTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_AttachTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InParent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         AttachType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::K2_AttachTo(class USceneComponent* InParent, class FName InSocketName, EAttachLocation AttachType, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AttachTo");

	Params::SceneComponent_K2_AttachTo Parms{};

	Parms.InParent = InParent;
	Parms.InSocketName = InSocketName;
	Parms.AttachType = AttachType;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.K2_AttachToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWeldSimulatedBodies                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::K2_AttachToComponent(class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_AttachToComponent");

	Params::SceneComponent_K2_AttachToComponent Parms{};

	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bWeldSimulatedBodies = bWeldSimulatedBodies;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.K2_DetachFromComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDetachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCallModify                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_DetachFromComponent(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule, bool bCallModify)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DetachFromComponent");

	Params::SceneComponent_K2_DetachFromComponent Parms{};

	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;
	Parms.bCallModify = bCallModify;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.K2_SetRelativeLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetRelativeLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetRelativeLocation");

	Params::SceneComponent_K2_SetRelativeLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetRelativeLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetRelativeLocationAndRotation");

	Params::SceneComponent_K2_SetRelativeLocationAndRotation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_SetRelativeRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetRelativeRotation(const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetRelativeRotation");

	Params::SceneComponent_K2_SetRelativeRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_SetRelativeTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetRelativeTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetRelativeTransform");

	Params::SceneComponent_K2_SetRelativeTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_SetWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetWorldLocation(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetWorldLocation");

	Params::SceneComponent_K2_SetWorldLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_SetWorldLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetWorldLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetWorldLocationAndRotation");

	Params::SceneComponent_K2_SetWorldLocationAndRotation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_SetWorldRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetWorldRotation(const struct FRotator& NewRotation, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetWorldRotation");

	Params::SceneComponent_K2_SetWorldRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.K2_SetWorldTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::K2_SetWorldTransform(const struct FTransform& NewTransform, bool bSweep, struct FHitResult* SweepHitResult, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetWorldTransform");

	Params::SceneComponent_K2_SetWorldTransform Parms{};

	Parms.NewTransform = std::move(NewTransform);
	Parms.bSweep = bSweep;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);
}


// Function Engine.SceneComponent.OnRep_AttachChildren
// (Final, Native, Private)

void USceneComponent::OnRep_AttachChildren()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_AttachChildren");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneComponent.OnRep_AttachParent
// (Final, Native, Private)

void USceneComponent::OnRep_AttachParent()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_AttachParent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneComponent.OnRep_AttachSocketName
// (Final, Native, Private)

void USceneComponent::OnRep_AttachSocketName()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_AttachSocketName");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneComponent.OnRep_Transform
// (Final, Native, Private)

void USceneComponent::OnRep_Transform()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Transform");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneComponent.OnRep_Visibility
// (Final, Native, Private)
// Parameters:
// bool                                    OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::OnRep_Visibility(bool OldValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Visibility");

	Params::SceneComponent_OnRep_Visibility Parms{};

	Parms.OldValue = OldValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.ResetRelativeTransform
// (Final, Native, Public, BlueprintCallable)

void USceneComponent::ResetRelativeTransform()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetRelativeTransform");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneComponent.SetAbsolute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewAbsoluteLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewAbsoluteRotation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewAbsoluteScale                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAbsolute");

	Params::SceneComponent_SetAbsolute Parms{};

	Parms.bNewAbsoluteLocation = bNewAbsoluteLocation;
	Parms.bNewAbsoluteRotation = bNewAbsoluteRotation;
	Parms.bNewAbsoluteScale = bNewAbsoluteScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.SetHiddenInGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewHidden                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetHiddenInGame(bool NewHidden, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHiddenInGame");

	Params::SceneComponent_SetHiddenInGame Parms{};

	Parms.NewHidden = NewHidden;
	Parms.bPropagateToChildren = bPropagateToChildren;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.SetMobility
// (Native, Public, BlueprintCallable)
// Parameters:
// EComponentMobility                      NewMobility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetMobility(EComponentMobility NewMobility)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMobility");

	Params::SceneComponent_SetMobility Parms{};

	Parms.NewMobility = NewMobility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.SetRelativeScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewScale3D                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetRelativeScale3D(const struct FVector& NewScale3D)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRelativeScale3D");

	Params::SceneComponent_SetRelativeScale3D Parms{};

	Parms.NewScale3D = std::move(NewScale3D);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.SetShouldUpdatePhysicsVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInShouldUpdatePhysicsVolume                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetShouldUpdatePhysicsVolume(bool bInShouldUpdatePhysicsVolume)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShouldUpdatePhysicsVolume");

	Params::SceneComponent_SetShouldUpdatePhysicsVolume Parms{};

	Parms.bInShouldUpdatePhysicsVolume = bInShouldUpdatePhysicsVolume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.SetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVisibility");

	Params::SceneComponent_SetVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;
	Parms.bPropagateToChildren = bPropagateToChildren;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.SetWorldScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::SetWorldScale3D(const struct FVector& NewScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWorldScale3D");

	Params::SceneComponent_SetWorldScale3D Parms{};

	Parms.NewScale = std::move(NewScale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.ToggleVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneComponent::ToggleVisibility(bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleVisibility");

	Params::SceneComponent_ToggleVisibility Parms{};

	Parms.bPropagateToChildren = bPropagateToChildren;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneComponent.DoesSocketExist
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::DoesSocketExist(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DoesSocketExist");

	Params::SceneComponent_DoesSocketExist Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetAllSocketNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> USceneComponent::GetAllSocketNames() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllSocketNames");

	Params::SceneComponent_GetAllSocketNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetAttachParent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* USceneComponent::GetAttachParent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAttachParent");

	Params::SceneComponent_GetAttachParent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetAttachSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USceneComponent::GetAttachSocketName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAttachSocketName");

	Params::SceneComponent_GetAttachSocketName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetChildComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ChildIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* USceneComponent::GetChildComponent(int32 ChildIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetChildComponent");

	Params::SceneComponent_GetChildComponent Parms{};

	Parms.ChildIndex = ChildIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetChildrenComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    bIncludeAllDescendants                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          Children                                               (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USceneComponent::GetChildrenComponents(bool bIncludeAllDescendants, TArray<class USceneComponent*>* Children) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetChildrenComponents");

	Params::SceneComponent_GetChildrenComponents Parms{};

	Parms.bIncludeAllDescendants = bIncludeAllDescendants;

	UObject::ProcessEvent(Func, &Parms);

	if (Children != nullptr)
		*Children = std::move(Parms.Children);
}


// Function Engine.SceneComponent.GetComponentVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetComponentVelocity() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetComponentVelocity");

	Params::SceneComponent_GetComponentVelocity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetForwardVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetForwardVector");

	Params::SceneComponent_GetForwardVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetNumChildrenComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USceneComponent::GetNumChildrenComponents() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumChildrenComponents");

	Params::SceneComponent_GetNumChildrenComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetParentComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class USceneComponent*>          Parents                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USceneComponent::GetParentComponents(TArray<class USceneComponent*>* Parents) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParentComponents");

	Params::SceneComponent_GetParentComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Parents != nullptr)
		*Parents = std::move(Parms.Parents);
}


// Function Engine.SceneComponent.GetPhysicsVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APhysicsVolume*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APhysicsVolume* USceneComponent::GetPhysicsVolume() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicsVolume");

	Params::SceneComponent_GetPhysicsVolume Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetRelativeTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USceneComponent::GetRelativeTransform() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRelativeTransform");

	Params::SceneComponent_GetRelativeTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetRightVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetRightVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRightVector");

	Params::SceneComponent_GetRightVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetShouldUpdatePhysicsVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::GetShouldUpdatePhysicsVolume() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShouldUpdatePhysicsVolume");

	Params::SceneComponent_GetShouldUpdatePhysicsVolume Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetSocketLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetSocketLocation(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSocketLocation");

	Params::SceneComponent_GetSocketLocation Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetSocketQuaternion
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat USceneComponent::GetSocketQuaternion(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSocketQuaternion");

	Params::SceneComponent_GetSocketQuaternion Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetSocketRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USceneComponent::GetSocketRotation(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSocketRotation");

	Params::SceneComponent_GetSocketRotation Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetSocketTransform
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERelativeTransformSpace                 TransformSpace                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USceneComponent::GetSocketTransform(class FName InSocketName, ERelativeTransformSpace TransformSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSocketTransform");

	Params::SceneComponent_GetSocketTransform Parms{};

	Parms.InSocketName = InSocketName;
	Parms.TransformSpace = TransformSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.GetUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::GetUpVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUpVector");

	Params::SceneComponent_GetUpVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.IsAnySimulatingPhysics
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::IsAnySimulatingPhysics() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAnySimulatingPhysics");

	Params::SceneComponent_IsAnySimulatingPhysics Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.IsSimulatingPhysics
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::IsSimulatingPhysics(class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSimulatingPhysics");

	Params::SceneComponent_IsSimulatingPhysics Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.IsVisible
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneComponent::IsVisible() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsVisible");

	Params::SceneComponent_IsVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.K2_GetComponentLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::K2_GetComponentLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetComponentLocation");

	Params::SceneComponent_K2_GetComponentLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.K2_GetComponentRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USceneComponent::K2_GetComponentRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetComponentRotation");

	Params::SceneComponent_K2_GetComponentRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.K2_GetComponentScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USceneComponent::K2_GetComponentScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetComponentScale");

	Params::SceneComponent_K2_GetComponentScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneComponent.K2_GetComponentToWorld
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USceneComponent::K2_GetComponentToWorld() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetComponentToWorld");

	Params::SceneComponent_K2_GetComponentToWorld Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhysicsSpringComponent::GetNormalizedCompressionScalar() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNormalizedCompressionScalar");

	Params::PhysicsSpringComponent_GetNormalizedCompressionScalar Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPhysicsSpringComponent::GetSpringCurrentEndPoint() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSpringCurrentEndPoint");

	Params::PhysicsSpringComponent_GetSpringCurrentEndPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsSpringComponent.GetSpringDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPhysicsSpringComponent::GetSpringDirection() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSpringDirection");

	Params::PhysicsSpringComponent_GetSpringDirection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsSpringComponent.GetSpringRestingPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPhysicsSpringComponent::GetSpringRestingPoint() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSpringRestingPoint");

	Params::PhysicsSpringComponent_GetSpringRestingPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintAsyncActionBase.Activate
// (Native, Public, BlueprintCallable)

void UBlueprintAsyncActionBase::Activate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Activate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.KismetInternationalizationLibrary.ClearCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AssetGroup                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SaveToConfig                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetInternationalizationLibrary::ClearCurrentAssetGroupCulture(const class FName AssetGroup, const bool SaveToConfig)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClearCurrentAssetGroupCulture");

	Params::KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture Parms{};

	Parms.AssetGroup = AssetGroup;
	Parms.SaveToConfig = SaveToConfig;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetInternationalizationLibrary.GetCultureDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Culture                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Localized                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCultureDisplayName(const class FString& Culture, const bool Localized)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCultureDisplayName");

	Params::KismetInternationalizationLibrary_GetCultureDisplayName Parms{};

	Parms.Culture = std::move(Culture);
	Parms.Localized = Localized;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             AssetGroup                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCurrentAssetGroupCulture(const class FName AssetGroup)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentAssetGroupCulture");

	Params::KismetInternationalizationLibrary_GetCurrentAssetGroupCulture Parms{};

	Parms.AssetGroup = AssetGroup;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCurrentCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCurrentCulture()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentCulture");

	Params::KismetInternationalizationLibrary_GetCurrentCulture Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCurrentLanguage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCurrentLanguage()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentLanguage");

	Params::KismetInternationalizationLibrary_GetCurrentLanguage Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCurrentLocale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetCurrentLocale()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentLocale");

	Params::KismetInternationalizationLibrary_GetCurrentLocale Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetLocalizedCultures
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    IncludeGame                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeEngine                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeEditor                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeAdditional                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetInternationalizationLibrary::GetLocalizedCultures(const bool IncludeGame, const bool IncludeEngine, const bool IncludeEditor, const bool IncludeAdditional)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLocalizedCultures");

	Params::KismetInternationalizationLibrary_GetLocalizedCultures Parms{};

	Parms.IncludeGame = IncludeGame;
	Parms.IncludeEngine = IncludeEngine;
	Parms.IncludeEditor = IncludeEditor;
	Parms.IncludeAdditional = IncludeAdditional;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetNativeCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELocalizedTextSourceCategory            TextCategory                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetNativeCulture(const ELocalizedTextSourceCategory TextCategory)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetNativeCulture");

	Params::KismetInternationalizationLibrary_GetNativeCulture Parms{};

	Parms.TextCategory = TextCategory;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetSuitableCulture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   AvailableCultures                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           CultureToMatch                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FallbackCulture                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetInternationalizationLibrary::GetSuitableCulture(const TArray<class FString>& AvailableCultures, const class FString& CultureToMatch, const class FString& FallbackCulture)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSuitableCulture");

	Params::KismetInternationalizationLibrary_GetSuitableCulture Parms{};

	Parms.AvailableCultures = std::move(AvailableCultures);
	Parms.CultureToMatch = std::move(CultureToMatch);
	Parms.FallbackCulture = std::move(FallbackCulture);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AssetGroup                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Culture                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SaveToConfig                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentAssetGroupCulture(const class FName AssetGroup, const class FString& Culture, const bool SaveToConfig)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetCurrentAssetGroupCulture");

	Params::KismetInternationalizationLibrary_SetCurrentAssetGroupCulture Parms{};

	Parms.AssetGroup = AssetGroup;
	Parms.Culture = std::move(Culture);
	Parms.SaveToConfig = SaveToConfig;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Culture                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SaveToConfig                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentCulture(const class FString& Culture, const bool SaveToConfig)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetCurrentCulture");

	Params::KismetInternationalizationLibrary_SetCurrentCulture Parms{};

	Parms.Culture = std::move(Culture);
	Parms.SaveToConfig = SaveToConfig;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Culture                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SaveToConfig                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentLanguage(const class FString& Culture, const bool SaveToConfig)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetCurrentLanguage");

	Params::KismetInternationalizationLibrary_SetCurrentLanguage Parms{};

	Parms.Culture = std::move(Culture);
	Parms.SaveToConfig = SaveToConfig;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLanguageAndLocale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Culture                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SaveToConfig                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentLanguageAndLocale(const class FString& Culture, const bool SaveToConfig)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetCurrentLanguageAndLocale");

	Params::KismetInternationalizationLibrary_SetCurrentLanguageAndLocale Parms{};

	Parms.Culture = std::move(Culture);
	Parms.SaveToConfig = SaveToConfig;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLocale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Culture                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SaveToConfig                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInternationalizationLibrary::SetCurrentLocale(const class FString& Culture, const bool SaveToConfig)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetCurrentLocale");

	Params::KismetInternationalizationLibrary_SetCurrentLocale Parms{};

	Parms.Culture = std::move(Culture);
	Parms.SaveToConfig = SaveToConfig;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.AddAngularImpulseInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddAngularImpulseInDegrees(const struct FVector& Impulse, class FName BoneName, bool bVelChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAngularImpulseInDegrees");

	Params::PrimitiveComponent_AddAngularImpulseInDegrees Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddAngularImpulseInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddAngularImpulseInRadians(const struct FVector& Impulse, class FName BoneName, bool bVelChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAngularImpulseInRadians");

	Params::PrimitiveComponent_AddAngularImpulseInRadians Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAccelChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddForce(const struct FVector& Force, class FName BoneName, bool bAccelChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddForce");

	Params::PrimitiveComponent_AddForce Parms{};

	Parms.Force = std::move(Force);
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddForceAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddForceAtLocation(const struct FVector& Force, const struct FVector& Location, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddForceAtLocation");

	Params::PrimitiveComponent_AddForceAtLocation Parms{};

	Parms.Force = std::move(Force);
	Parms.Location = std::move(Location);
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddForceAtLocationLocal
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddForceAtLocationLocal(const struct FVector& Force, const struct FVector& Location, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddForceAtLocationLocal");

	Params::PrimitiveComponent_AddForceAtLocationLocal Parms{};

	Parms.Force = std::move(Force);
	Parms.Location = std::move(Location);
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddImpulse(const struct FVector& Impulse, class FName BoneName, bool bVelChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddImpulse");

	Params::PrimitiveComponent_AddImpulse Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddImpulseAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddImpulseAtLocation(const struct FVector& Impulse, const struct FVector& Location, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddImpulseAtLocation");

	Params::PrimitiveComponent_AddImpulseAtLocation Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.Location = std::move(Location);
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddRadialForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialImpulseFalloff                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAccelChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddRadialForce(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff, bool bAccelChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddRadialForce");

	Params::PrimitiveComponent_AddRadialForce Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;
	Parms.bAccelChange = bAccelChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddRadialImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialImpulseFalloff                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff, bool bVelChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddRadialImpulse");

	Params::PrimitiveComponent_AddRadialImpulse Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.Falloff = Falloff;
	Parms.bVelChange = bVelChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddTorqueInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Torque                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAccelChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddTorqueInDegrees(const struct FVector& Torque, class FName BoneName, bool bAccelChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddTorqueInDegrees");

	Params::PrimitiveComponent_AddTorqueInDegrees Parms{};

	Parms.Torque = std::move(Torque);
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddTorqueInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Torque                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAccelChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddTorqueInRadians(const struct FVector& Torque, class FName BoneName, bool bAccelChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddTorqueInRadians");

	Params::PrimitiveComponent_AddTorqueInRadians Parms{};

	Parms.Torque = std::move(Torque);
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.AddVelocityChangeImpulseAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::AddVelocityChangeImpulseAtLocation(const struct FVector& Impulse, const struct FVector& Location, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddVelocityChangeImpulseAtLocation");

	Params::PrimitiveComponent_AddVelocityChangeImpulseAtLocation Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.Location = std::move(Location);
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.ClearMoveIgnoreActors
// (Final, Native, Public, BlueprintCallable)

void UPrimitiveComponent::ClearMoveIgnoreActors()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMoveIgnoreActors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PrimitiveComponent.ClearMoveIgnoreComponents
// (Final, Native, Public, BlueprintCallable)

void UPrimitiveComponent::ClearMoveIgnoreComponents()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMoveIgnoreComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UPrimitiveComponent::CopyArrayOfMoveIgnoreActors()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CopyArrayOfMoveIgnoreActors");

	Params::PrimitiveComponent_CopyArrayOfMoveIgnoreActors Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*>      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPrimitiveComponent*> UPrimitiveComponent::CopyArrayOfMoveIgnoreComponents()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CopyArrayOfMoveIgnoreComponents");

	Params::PrimitiveComponent_CopyArrayOfMoveIgnoreComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic(int32 ElementIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreateAndSetMaterialInstanceDynamic");

	Params::PrimitiveComponent_CreateAndSetMaterialInstanceDynamic Parms{};

	Parms.ElementIndex = ElementIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamicFromMaterial(int32 ElementIndex, class UMaterialInterface* Parent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreateAndSetMaterialInstanceDynamicFromMaterial");

	Params::PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial Parms{};

	Parms.ElementIndex = ElementIndex;
	Parms.Parent = Parent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               SourceMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OptionalName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UPrimitiveComponent::CreateDynamicMaterialInstance(int32 ElementIndex, class UMaterialInterface* SourceMaterial, class FName OptionalName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreateDynamicMaterialInstance");

	Params::PrimitiveComponent_CreateDynamicMaterialInstance Parms{};

	Parms.ElementIndex = ElementIndex;
	Parms.SourceMaterial = SourceMaterial;
	Parms.OptionalName = OptionalName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsLinearVelocity(class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicsLinearVelocity");

	Params::PrimitiveComponent_GetPhysicsLinearVelocity Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsLinearVelocityAtPoint(const struct FVector& Point, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicsLinearVelocityAtPoint");

	Params::PrimitiveComponent_GetPhysicsLinearVelocityAtPoint Parms{};

	Parms.Point = std::move(Point);
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.IgnoreActorWhenMoving
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldIgnore                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::IgnoreActorWhenMoving(class AActor* Actor, bool bShouldIgnore)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IgnoreActorWhenMoving");

	Params::PrimitiveComponent_IgnoreActorWhenMoving Parms{};

	Parms.Actor = Actor;
	Parms.bShouldIgnore = bShouldIgnore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.IgnoreComponentWhenMoving
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldIgnore                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::IgnoreComponentWhenMoving(class UPrimitiveComponent* Component, bool bShouldIgnore)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IgnoreComponentWhenMoving");

	Params::PrimitiveComponent_IgnoreComponentWhenMoving Parms{};

	Parms.Component = Component;
	Parms.bShouldIgnore = bShouldIgnore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.IsAnyRigidBodyAwake
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::IsAnyRigidBodyAwake()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAnyRigidBodyAwake");

	Params::PrimitiveComponent_IsAnyRigidBodyAwake Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_BoxOverlapComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InBoxCentre                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             InBox                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentShowTrace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_BoxOverlapComponent(const struct FVector& InBoxCentre, const struct FBox& InBox, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_BoxOverlapComponent");

	Params::PrimitiveComponent_K2_BoxOverlapComponent Parms{};

	Parms.InBoxCentre = std::move(InBoxCentre);
	Parms.InBox = std::move(InBox);
	Parms.bTraceComplex = bTraceComplex;
	Parms.bShowTrace = bShowTrace;
	Parms.bPersistentShowTrace = bPersistentShowTrace;

	UObject::ProcessEvent(Func, &Parms);

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_LineTraceComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentShowTrace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_LineTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_LineTraceComponent");

	Params::PrimitiveComponent_K2_LineTraceComponent Parms{};

	Parms.TraceStart = std::move(TraceStart);
	Parms.TraceEnd = std::move(TraceEnd);
	Parms.bTraceComplex = bTraceComplex;
	Parms.bShowTrace = bShowTrace;
	Parms.bPersistentShowTrace = bPersistentShowTrace;

	UObject::ProcessEvent(Func, &Parms);

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_SphereOverlapComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InSphereCentre                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSphereRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentShowTrace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_SphereOverlapComponent(const struct FVector& InSphereCentre, float InSphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SphereOverlapComponent");

	Params::PrimitiveComponent_K2_SphereOverlapComponent Parms{};

	Parms.InSphereCentre = std::move(InSphereCentre);
	Parms.InSphereRadius = InSphereRadius;
	Parms.bTraceComplex = bTraceComplex;
	Parms.bShowTrace = bShowTrace;
	Parms.bPersistentShowTrace = bPersistentShowTrace;

	UObject::ProcessEvent(Func, &Parms);

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_SphereTraceComponent
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistentShowTrace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_SphereTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, float SphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SphereTraceComponent");

	Params::PrimitiveComponent_K2_SphereTraceComponent Parms{};

	Parms.TraceStart = std::move(TraceStart);
	Parms.TraceEnd = std::move(TraceEnd);
	Parms.SphereRadius = SphereRadius;
	Parms.bTraceComplex = bTraceComplex;
	Parms.bShowTrace = bShowTrace;
	Parms.bPersistentShowTrace = bPersistentShowTrace;

	UObject::ProcessEvent(Func, &Parms);

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.PutRigidBodyToSleep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::PutRigidBodyToSleep(class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PutRigidBodyToSleep");

	Params::PrimitiveComponent_PutRigidBodyToSleep Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetAllMassScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMassScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllMassScale(float InMassScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllMassScale");

	Params::PrimitiveComponent_SetAllMassScale Parms{};

	Parms.InMassScale = InMassScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewAngVel                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllPhysicsAngularVelocityInDegrees(const struct FVector& NewAngVel, bool bAddToCurrent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllPhysicsAngularVelocityInDegrees");

	Params::PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees Parms{};

	Parms.NewAngVel = std::move(NewAngVel);
	Parms.bAddToCurrent = bAddToCurrent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInRadians
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewAngVel                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllPhysicsAngularVelocityInRadians(const struct FVector& NewAngVel, bool bAddToCurrent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllPhysicsAngularVelocityInRadians");

	Params::PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians Parms{};

	Parms.NewAngVel = std::move(NewAngVel);
	Parms.bAddToCurrent = bAddToCurrent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewVel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllPhysicsLinearVelocity");

	Params::PrimitiveComponent_SetAllPhysicsLinearVelocity Parms{};

	Parms.NewVel = std::move(NewVel);
	Parms.bAddToCurrent = bAddToCurrent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetAllUseCCD
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InUseCCD                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAllUseCCD(bool InUseCCD)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllUseCCD");

	Params::PrimitiveComponent_SetAllUseCCD Parms{};

	Parms.InUseCCD = InUseCCD;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetAngularDamping
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDamping                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetAngularDamping(float InDamping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularDamping");

	Params::PrimitiveComponent_SetAngularDamping Parms{};

	Parms.InDamping = InDamping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetBoundsScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewBoundsScale                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetBoundsScale(float NewBoundsScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoundsScale");

	Params::PrimitiveComponent_SetBoundsScale Parms{};

	Parms.NewBoundsScale = NewBoundsScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCastContactShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCastContactShadow                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCastContactShadow(bool bInCastContactShadow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastContactShadow");

	Params::PrimitiveComponent_SetCastContactShadow Parms{};

	Parms.bInCastContactShadow = bInCastContactShadow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCastHiddenShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewCastHiddenShadow                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCastHiddenShadow(bool NewCastHiddenShadow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastHiddenShadow");

	Params::PrimitiveComponent_SetCastHiddenShadow Parms{};

	Parms.NewCastHiddenShadow = NewCastHiddenShadow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCastInsetShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCastInsetShadow                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCastInsetShadow(bool bInCastInsetShadow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastInsetShadow");

	Params::PrimitiveComponent_SetCastInsetShadow Parms{};

	Parms.bInCastInsetShadow = bInCastInsetShadow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCastShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewCastShadow                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCastShadow(bool NewCastShadow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastShadow");

	Params::PrimitiveComponent_SetCastShadow Parms{};

	Parms.NewCastShadow = NewCastShadow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CenterOfMassOffset                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCenterOfMass(const struct FVector& CenterOfMassOffset, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCenterOfMass");

	Params::PrimitiveComponent_SetCenterOfMass Parms{};

	Parms.CenterOfMassOffset = std::move(CenterOfMassOffset);
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCollisionEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// ECollisionEnabled                       NewType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionEnabled(ECollisionEnabled NewType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCollisionEnabled");

	Params::PrimitiveComponent_SetCollisionEnabled Parms{};

	Parms.NewType = NewType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCollisionObjectType
// (Native, Public, BlueprintCallable)
// Parameters:
// ECollisionChannel                       Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionObjectType(ECollisionChannel Channel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCollisionObjectType");

	Params::PrimitiveComponent_SetCollisionObjectType Parms{};

	Parms.Channel = Channel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCollisionProfileName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InCollisionProfileName                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionProfileName(class FName InCollisionProfileName, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCollisionProfileName");

	Params::PrimitiveComponent_SetCollisionProfileName Parms{};

	Parms.InCollisionProfileName = InCollisionProfileName;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels
// (Native, Public, BlueprintCallable)
// Parameters:
// ECollisionResponse                      NewResponse                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionResponseToAllChannels(ECollisionResponse NewResponse)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCollisionResponseToAllChannels");

	Params::PrimitiveComponent_SetCollisionResponseToAllChannels Parms{};

	Parms.NewResponse = NewResponse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCollisionResponseToChannel
// (Native, Public, BlueprintCallable)
// Parameters:
// ECollisionChannel                       Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionResponse                      NewResponse                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse NewResponse)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCollisionResponseToChannel");

	Params::PrimitiveComponent_SetCollisionResponseToChannel Parms{};

	Parms.Channel = Channel;
	Parms.NewResponse = NewResponse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetConstraintMode
// (Native, Public, BlueprintCallable)
// Parameters:
// EDOFMode                                ConstraintMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetConstraintMode(EDOFMode ConstraintMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConstraintMode");

	Params::PrimitiveComponent_SetConstraintMode Parms{};

	Parms.ConstraintMode = ConstraintMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCullDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCullDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCullDistance(float NewCullDistance)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCullDistance");

	Params::PrimitiveComponent_SetCullDistance Parms{};

	Parms.NewCullDistance = NewCullDistance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCustomDepthStencilValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomDepthStencilValue(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCustomDepthStencilValue");

	Params::PrimitiveComponent_SetCustomDepthStencilValue Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCustomDepthStencilWriteMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERendererStencilMask                    WriteMaskBit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomDepthStencilWriteMask(ERendererStencilMask WriteMaskBit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCustomDepthStencilWriteMask");

	Params::PrimitiveComponent_SetCustomDepthStencilWriteMask Parms{};

	Parms.WriteMaskBit = WriteMaskBit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomPrimitiveDataFloat(int32 DataIndex, float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCustomPrimitiveDataFloat");

	Params::PrimitiveComponent_SetCustomPrimitiveDataFloat Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector2
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomPrimitiveDataVector2(int32 DataIndex, const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCustomPrimitiveDataVector2");

	Params::PrimitiveComponent_SetCustomPrimitiveDataVector2 Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector3
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomPrimitiveDataVector3(int32 DataIndex, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCustomPrimitiveDataVector3");

	Params::PrimitiveComponent_SetCustomPrimitiveDataVector3 Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector4
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetCustomPrimitiveDataVector4(int32 DataIndex, const struct FVector4& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCustomPrimitiveDataVector4");

	Params::PrimitiveComponent_SetCustomPrimitiveDataVector4 Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetDefaultCustomPrimitiveDataFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetDefaultCustomPrimitiveDataFloat(int32 DataIndex, float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultCustomPrimitiveDataFloat");

	Params::PrimitiveComponent_SetDefaultCustomPrimitiveDataFloat Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetDefaultCustomPrimitiveDataVector2
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetDefaultCustomPrimitiveDataVector2(int32 DataIndex, const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultCustomPrimitiveDataVector2");

	Params::PrimitiveComponent_SetDefaultCustomPrimitiveDataVector2 Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetDefaultCustomPrimitiveDataVector3
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetDefaultCustomPrimitiveDataVector3(int32 DataIndex, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultCustomPrimitiveDataVector3");

	Params::PrimitiveComponent_SetDefaultCustomPrimitiveDataVector3 Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetDefaultCustomPrimitiveDataVector4
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetDefaultCustomPrimitiveDataVector4(int32 DataIndex, const struct FVector4& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultCustomPrimitiveDataVector4");

	Params::PrimitiveComponent_SetDefaultCustomPrimitiveDataVector4 Parms{};

	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetEnableGravity
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bGravityEnabled                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetEnableGravity(bool bGravityEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnableGravity");

	Params::PrimitiveComponent_SetEnableGravity Parms{};

	Parms.bGravityEnabled = bGravityEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetExcludeFromLightAttachmentGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInExcludeFromLightAttachmentGroup                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetExcludeFromLightAttachmentGroup(bool bInExcludeFromLightAttachmentGroup)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetExcludeFromLightAttachmentGroup");

	Params::PrimitiveComponent_SetExcludeFromLightAttachmentGroup Parms{};

	Parms.bInExcludeFromLightAttachmentGroup = bInExcludeFromLightAttachmentGroup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetGenerateOverlapEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInGenerateOverlapEvents                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetGenerateOverlapEvents(bool bInGenerateOverlapEvents)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGenerateOverlapEvents");

	Params::PrimitiveComponent_SetGenerateOverlapEvents Parms{};

	Parms.bInGenerateOverlapEvents = bInGenerateOverlapEvents;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetHiddenInSceneCapture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetHiddenInSceneCapture(bool bValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHiddenInSceneCapture");

	Params::PrimitiveComponent_SetHiddenInSceneCapture Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetLightAttachmentsAsGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInLightAttachmentsAsGroup                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetLightAttachmentsAsGroup(bool bInLightAttachmentsAsGroup)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightAttachmentsAsGroup");

	Params::PrimitiveComponent_SetLightAttachmentsAsGroup Parms{};

	Parms.bInLightAttachmentsAsGroup = bInLightAttachmentsAsGroup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetLightingChannels
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bChannel0                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChannel1                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChannel2                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightingChannels");

	Params::PrimitiveComponent_SetLightingChannels Parms{};

	Parms.bChannel0 = bChannel0;
	Parms.bChannel1 = bChannel1;
	Parms.bChannel2 = bChannel2;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetLinearDamping
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDamping                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetLinearDamping(float InDamping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearDamping");

	Params::PrimitiveComponent_SetLinearDamping Parms{};

	Parms.InDamping = InDamping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetMassOverrideInKg
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MassInKg                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideMass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetMassOverrideInKg(class FName BoneName, float MassInKg, bool bOverrideMass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMassOverrideInKg");

	Params::PrimitiveComponent_SetMassOverrideInKg Parms{};

	Parms.BoneName = BoneName;
	Parms.MassInKg = MassInKg;
	Parms.bOverrideMass = bOverrideMass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetMassScale
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMassScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetMassScale(class FName BoneName, float InMassScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMassScale");

	Params::PrimitiveComponent_SetMassScale Parms{};

	Parms.BoneName = BoneName;
	Parms.InMassScale = InMassScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetMaterial(int32 ElementIndex, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaterial");

	Params::PrimitiveComponent_SetMaterial Parms{};

	Parms.ElementIndex = ElementIndex;
	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetMaterialByName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetMaterialByName(class FName MaterialSlotName, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaterialByName");

	Params::PrimitiveComponent_SetMaterialByName Parms{};

	Parms.MaterialSlotName = MaterialSlotName;
	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewNotifyRigidBodyCollision                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNotifyRigidBodyCollision");

	Params::PrimitiveComponent_SetNotifyRigidBodyCollision Parms{};

	Parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetOnlyOwnerSee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewOnlyOwnerSee                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetOnlyOwnerSee(bool bNewOnlyOwnerSee)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOnlyOwnerSee");

	Params::PrimitiveComponent_SetOnlyOwnerSee Parms{};

	Parms.bNewOnlyOwnerSee = bNewOnlyOwnerSee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetOwnerNoSee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewOwnerNoSee                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetOwnerNoSee(bool bNewOwnerNoSee)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOwnerNoSee");

	Params::PrimitiveComponent_SetOwnerNoSee Parms{};

	Parms.bNewOwnerNoSee = bNewOwnerNoSee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewAngVel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsAngularVelocityInDegrees(const struct FVector& NewAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPhysicsAngularVelocityInDegrees");

	Params::PrimitiveComponent_SetPhysicsAngularVelocityInDegrees Parms{};

	Parms.NewAngVel = std::move(NewAngVel);
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewAngVel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsAngularVelocityInRadians(const struct FVector& NewAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPhysicsAngularVelocityInRadians");

	Params::PrimitiveComponent_SetPhysicsAngularVelocityInRadians Parms{};

	Parms.NewAngVel = std::move(NewAngVel);
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewVel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPhysicsLinearVelocity");

	Params::PrimitiveComponent_SetPhysicsLinearVelocity Parms{};

	Parms.NewVel = std::move(NewVel);
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInDegrees
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxAngVel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsMaxAngularVelocityInDegrees(float NewMaxAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPhysicsMaxAngularVelocityInDegrees");

	Params::PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees Parms{};

	Parms.NewMaxAngVel = NewMaxAngVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInRadians
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewMaxAngVel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToCurrent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysicsMaxAngularVelocityInRadians(float NewMaxAngVel, bool bAddToCurrent, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPhysicsMaxAngularVelocityInRadians");

	Params::PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians Parms{};

	Parms.NewMaxAngVel = NewMaxAngVel;
	Parms.bAddToCurrent = bAddToCurrent;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetPhysMaterialOverride
// (Native, Public, BlueprintCallable)
// Parameters:
// class UPhysicalMaterial*                NewPhysMaterial                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPhysMaterialOverride");

	Params::PrimitiveComponent_SetPhysMaterialOverride Parms{};

	Parms.NewPhysMaterial = NewPhysMaterial;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetReceivesDecals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewReceivesDecals                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetReceivesDecals(bool bNewReceivesDecals)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetReceivesDecals");

	Params::PrimitiveComponent_SetReceivesDecals Parms{};

	Parms.bNewReceivesDecals = bNewReceivesDecals;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetRenderCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetRenderCustomDepth(bool bValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderCustomDepth");

	Params::PrimitiveComponent_SetRenderCustomDepth Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetRenderInDepthPass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetRenderInDepthPass(bool bValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderInDepthPass");

	Params::PrimitiveComponent_SetRenderInDepthPass Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetRenderInMainPass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetRenderInMainPass(bool bValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderInMainPass");

	Params::PrimitiveComponent_SetRenderInMainPass Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetSimulatePhysics
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSimulate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetSimulatePhysics(bool bSimulate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSimulatePhysics");

	Params::PrimitiveComponent_SetSimulatePhysics Parms{};

	Parms.bSimulate = bSimulate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetSingleSampleShadowFromStationaryLights
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewSingleSampleShadowFromStationaryLights             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetSingleSampleShadowFromStationaryLights(bool bNewSingleSampleShadowFromStationaryLights)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSingleSampleShadowFromStationaryLights");

	Params::PrimitiveComponent_SetSingleSampleShadowFromStationaryLights Parms{};

	Parms.bNewSingleSampleShadowFromStationaryLights = bNewSingleSampleShadowFromStationaryLights;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetTranslucencySortDistanceOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTranslucencySortDistanceOffset                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetTranslucencySortDistanceOffset(float NewTranslucencySortDistanceOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTranslucencySortDistanceOffset");

	Params::PrimitiveComponent_SetTranslucencySortDistanceOffset Parms{};

	Parms.NewTranslucencySortDistanceOffset = NewTranslucencySortDistanceOffset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetTranslucentSortPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewTranslucentSortPriority                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetTranslucentSortPriority(int32 NewTranslucentSortPriority)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTranslucentSortPriority");

	Params::PrimitiveComponent_SetTranslucentSortPriority Parms{};

	Parms.NewTranslucentSortPriority = NewTranslucentSortPriority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetUseCCD
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InUseCCD                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetUseCCD(bool InUseCCD, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUseCCD");

	Params::PrimitiveComponent_SetUseCCD Parms{};

	Parms.InUseCCD = InUseCCD;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetVisibleInRayTracing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisibleInRayTracing                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetVisibleInRayTracing(bool bNewVisibleInRayTracing)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVisibleInRayTracing");

	Params::PrimitiveComponent_SetVisibleInRayTracing Parms{};

	Parms.bNewVisibleInRayTracing = bNewVisibleInRayTracing;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetVisibleInSceneCaptureOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetVisibleInSceneCaptureOnly(bool bValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVisibleInSceneCaptureOnly");

	Params::PrimitiveComponent_SetVisibleInSceneCaptureOnly Parms{};

	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.SetWalkableSlopeOverride
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FWalkableSlopeOverride           NewOverride                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPrimitiveComponent::SetWalkableSlopeOverride(const struct FWalkableSlopeOverride& NewOverride)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWalkableSlopeOverride");

	Params::PrimitiveComponent_SetWalkableSlopeOverride Parms{};

	Parms.NewOverride = std::move(NewOverride);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.WakeAllRigidBodies
// (Native, Public, BlueprintCallable)

void UPrimitiveComponent::WakeAllRigidBodies()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WakeAllRigidBodies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PrimitiveComponent.WakeRigidBody
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::WakeRigidBody(class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WakeRigidBody");

	Params::PrimitiveComponent_WakeRigidBody Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PrimitiveComponent.CanCharacterStepUp
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::CanCharacterStepUp(class APawn* Pawn) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanCharacterStepUp");

	Params::PrimitiveComponent_CanCharacterStepUp Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetAngularDamping
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetAngularDamping() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAngularDamping");

	Params::PrimitiveComponent_GetAngularDamping Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetCenterOfMass(class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCenterOfMass");

	Params::PrimitiveComponent_GetCenterOfMass Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetClosestPointOnCollision
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutPointOnBody                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetClosestPointOnCollision(const struct FVector& Point, struct FVector* OutPointOnBody, class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClosestPointOnCollision");

	Params::PrimitiveComponent_GetClosestPointOnCollision Parms{};

	Parms.Point = std::move(Point);
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPointOnBody != nullptr)
		*OutPointOnBody = std::move(Parms.OutPointOnBody);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCollisionEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECollisionEnabled                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionEnabled UPrimitiveComponent::GetCollisionEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCollisionEnabled");

	Params::PrimitiveComponent_GetCollisionEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCollisionObjectType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel UPrimitiveComponent::GetCollisionObjectType() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCollisionObjectType");

	Params::PrimitiveComponent_GetCollisionObjectType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCollisionProfileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UPrimitiveComponent::GetCollisionProfileName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCollisionProfileName");

	Params::PrimitiveComponent_GetCollisionProfileName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCollisionResponseToChannel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECollisionChannel                       Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionResponse                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionResponse UPrimitiveComponent::GetCollisionResponseToChannel(ECollisionChannel Channel) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCollisionResponseToChannel");

	Params::PrimitiveComponent_GetCollisionResponseToChannel Parms{};

	Parms.Channel = Channel;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetGenerateOverlapEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::GetGenerateOverlapEvents() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGenerateOverlapEvents");

	Params::PrimitiveComponent_GetGenerateOverlapEvents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetInertiaTensor
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetInertiaTensor(class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInertiaTensor");

	Params::PrimitiveComponent_GetInertiaTensor Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetLinearDamping
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetLinearDamping() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinearDamping");

	Params::PrimitiveComponent_GetLinearDamping Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetMass
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetMass() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMass");

	Params::PrimitiveComponent_GetMass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetMassScale
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPrimitiveComponent::GetMassScale(class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMassScale");

	Params::PrimitiveComponent_GetMassScale Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UPrimitiveComponent::GetMaterial(int32 ElementIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterial");

	Params::PrimitiveComponent_GetMaterial Parms{};

	Parms.ElementIndex = ElementIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetMaterialFromCollisionFaceIndex
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FaceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SectionIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UPrimitiveComponent::GetMaterialFromCollisionFaceIndex(int32 FaceIndex, int32* SectionIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterialFromCollisionFaceIndex");

	Params::PrimitiveComponent_GetMaterialFromCollisionFaceIndex Parms{};

	Parms.FaceIndex = FaceIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (SectionIndex != nullptr)
		*SectionIndex = Parms.SectionIndex;

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetNumMaterials
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPrimitiveComponent::GetNumMaterials() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumMaterials");

	Params::PrimitiveComponent_GetNumMaterials Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetOverlappingActors
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>                   OverlappingActors                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPrimitiveComponent::GetOverlappingActors(TArray<class AActor*>* OverlappingActors, TSubclassOf<class AActor> ClassFilter) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOverlappingActors");

	Params::PrimitiveComponent_GetOverlappingActors Parms{};

	Parms.ClassFilter = ClassFilter;

	UObject::ProcessEvent(Func, &Parms);

	if (OverlappingActors != nullptr)
		*OverlappingActors = std::move(Parms.OverlappingActors);
}


// Function Engine.PrimitiveComponent.GetOverlappingComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UPrimitiveComponent*>      OutOverlappingComponents                               (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPrimitiveComponent::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* OutOverlappingComponents) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOverlappingComponents");

	Params::PrimitiveComponent_GetOverlappingComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutOverlappingComponents != nullptr)
		*OutOverlappingComponents = std::move(Parms.OutOverlappingComponents);
}


// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsAngularVelocityInDegrees(class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicsAngularVelocityInDegrees");

	Params::PrimitiveComponent_GetPhysicsAngularVelocityInDegrees Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInRadians
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::GetPhysicsAngularVelocityInRadians(class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicsAngularVelocityInRadians");

	Params::PrimitiveComponent_GetPhysicsAngularVelocityInRadians Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetWalkableSlopeOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FWalkableSlopeOverride     ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FWalkableSlopeOverride UPrimitiveComponent::GetWalkableSlopeOverride() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWalkableSlopeOverride");

	Params::PrimitiveComponent_GetWalkableSlopeOverride Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.IsGravityEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::IsGravityEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsGravityEnabled");

	Params::PrimitiveComponent_IsGravityEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.IsOverlappingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Other                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::IsOverlappingActor(const class AActor* Other) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOverlappingActor");

	Params::PrimitiveComponent_IsOverlappingActor Parms{};

	Parms.Other = Other;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.IsOverlappingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              OtherComp                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::IsOverlappingComponent(const class UPrimitiveComponent* OtherComp) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOverlappingComponent");

	Params::PrimitiveComponent_IsOverlappingComponent Parms{};

	Parms.OtherComp = OtherComp;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_IsCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_IsCollisionEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_IsCollisionEnabled");

	Params::PrimitiveComponent_K2_IsCollisionEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_IsPhysicsCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_IsPhysicsCollisionEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_IsPhysicsCollisionEnabled");

	Params::PrimitiveComponent_K2_IsPhysicsCollisionEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_IsQueryCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::K2_IsQueryCollisionEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_IsQueryCollisionEnabled");

	Params::PrimitiveComponent_K2_IsQueryCollisionEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.ScaleByMomentOfInertia
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          InputVector                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPrimitiveComponent::ScaleByMomentOfInertia(const struct FVector& InputVector, class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScaleByMomentOfInertia");

	Params::PrimitiveComponent_ScaleByMomentOfInertia Parms{};

	Parms.InputVector = std::move(InputVector);
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PrimitiveComponent.WasRecentlyRendered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPrimitiveComponent::WasRecentlyRendered(float Tolerance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasRecentlyRendered");

	Params::PrimitiveComponent_WasRecentlyRendered Parms{};

	Parms.Tolerance = Tolerance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SphereComponent.SetSphereRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSphereRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USphereComponent::SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSphereRadius");

	Params::SphereComponent_SetSphereRadius Parms{};

	Parms.InSphereRadius = InSphereRadius;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SphereComponent.GetScaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USphereComponent::GetScaledSphereRadius() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledSphereRadius");

	Params::SphereComponent_GetScaledSphereRadius Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SphereComponent.GetShapeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USphereComponent::GetShapeScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShapeScale");

	Params::SphereComponent_GetShapeScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SphereComponent.GetUnscaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USphereComponent::GetUnscaledSphereRadius() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnscaledSphereRadius");

	Params::SphereComponent_GetUnscaledSphereRadius Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.GetMovementBaseActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* APawn::GetMovementBaseActor(const class APawn* Pawn)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMovementBaseActor");

	Params::Pawn_GetMovementBaseActor Parms{};

	Parms.Pawn = Pawn;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.AddControllerPitchInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::AddControllerPitchInput(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddControllerPitchInput");

	Params::Pawn_AddControllerPitchInput Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.AddControllerRollInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::AddControllerRollInput(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddControllerRollInput");

	Params::Pawn_AddControllerRollInput Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.AddControllerYawInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::AddControllerYawInput(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddControllerYawInput");

	Params::Pawn_AddControllerYawInput Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.AddMovementInput
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaleValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::AddMovementInput(const struct FVector& WorldDirection, float ScaleValue, bool bForce)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddMovementInput");

	Params::Pawn_AddMovementInput Parms{};

	Parms.WorldDirection = std::move(WorldDirection);
	Parms.ScaleValue = ScaleValue;
	Parms.bForce = bForce;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.ConsumeMovementInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::ConsumeMovementInputVector()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConsumeMovementInputVector");

	Params::Pawn_ConsumeMovementInputVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.DetachFromControllerPendingDestroy
// (Native, Public, BlueprintCallable)

void APawn::DetachFromControllerPendingDestroy()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DetachFromControllerPendingDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Pawn.OnRep_Controller
// (Native, Public)

void APawn::OnRep_Controller()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Controller");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Pawn.OnRep_PlayerState
// (Native, Public)

void APawn::OnRep_PlayerState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_PlayerState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Pawn.PawnMakeNoise
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Loudness                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NoiseLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseNoiseMakerLocation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NoiseMaker                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::PawnMakeNoise(float Loudness, const struct FVector& NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PawnMakeNoise");

	Params::Pawn_PawnMakeNoise Parms{};

	Parms.Loudness = Loudness;
	Parms.NoiseLocation = std::move(NoiseLocation);
	Parms.bUseNoiseMakerLocation = bUseNoiseMakerLocation;
	Parms.NoiseMaker = NoiseMaker;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.ReceiveControllerChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      OldController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::ReceiveControllerChanged(class AController* OldController, class AController* NewController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveControllerChanged");

	Params::Pawn_ReceiveControllerChanged Parms{};

	Parms.OldController = OldController;
	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.ReceivePossessed
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      NewController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::ReceivePossessed(class AController* NewController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceivePossessed");

	Params::Pawn_ReceivePossessed Parms{};

	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.ReceiveRestarted
// (Event, Public, BlueprintEvent)

void APawn::ReceiveRestarted()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveRestarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Pawn.ReceiveUnpossessed
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      OldController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::ReceiveUnpossessed(class AController* OldController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveUnpossessed");

	Params::Pawn_ReceiveUnpossessed Parms{};

	Parms.OldController = OldController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.SetCanAffectNavigationGeneration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APawn::SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCanAffectNavigationGeneration");

	Params::Pawn_SetCanAffectNavigationGeneration Parms{};

	Parms.bNewValue = bNewValue;
	Parms.bForceUpdate = bForceUpdate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Pawn.SpawnDefaultController
// (Native, Public, BlueprintCallable)

void APawn::SpawnDefaultController()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SpawnDefaultController");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Pawn.GetBaseAimRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator APawn::GetBaseAimRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBaseAimRotation");

	Params::Pawn_GetBaseAimRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.GetController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* APawn::GetController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetController");

	Params::Pawn_GetController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.GetControlRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator APawn::GetControlRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetControlRotation");

	Params::Pawn_GetControlRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.GetLastMovementInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::GetLastMovementInputVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastMovementInputVector");

	Params::Pawn_GetLastMovementInputVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.GetLocalViewingPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* APawn::GetLocalViewingPlayerController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocalViewingPlayerController");

	Params::Pawn_GetLocalViewingPlayerController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.GetMovementComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPawnMovementComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPawnMovementComponent* APawn::GetMovementComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMovementComponent");

	Params::Pawn_GetMovementComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.GetNavAgentLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::GetNavAgentLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNavAgentLocation");

	Params::Pawn_GetNavAgentLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.GetPendingMovementInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APawn::GetPendingMovementInputVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPendingMovementInputVector");

	Params::Pawn_GetPendingMovementInputVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.IsBotControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsBotControlled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsBotControlled");

	Params::Pawn_IsBotControlled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.IsControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsControlled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsControlled");

	Params::Pawn_IsControlled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.IsLocallyControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsLocallyControlled");

	Params::Pawn_IsLocallyControlled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.IsLocallyViewed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsLocallyViewed() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsLocallyViewed");

	Params::Pawn_IsLocallyViewed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsMoveInputIgnored() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsMoveInputIgnored");

	Params::Pawn_IsMoveInputIgnored Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.IsPawnControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsPawnControlled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPawnControlled");

	Params::Pawn_IsPawnControlled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Pawn.IsPlayerControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APawn::IsPlayerControlled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlayerControlled");

	Params::Pawn_IsPlayerControlled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.CanSpectate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                Viewer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     ViewTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::CanSpectate(class APlayerController* Viewer, class APlayerState* ViewTarget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanSpectate");

	Params::GameModeBase_CanSpectate Parms{};

	Parms.Viewer = Viewer;
	Parms.ViewTarget = ViewTarget;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.ChangeName
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNameChange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::ChangeName(class AController* Controller, const class FString& NewName, bool bNameChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChangeName");

	Params::GameModeBase_ChangeName Parms{};

	Parms.Controller = Controller;
	Parms.NewName = std::move(NewName);
	Parms.bNameChange = bNameChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.ChoosePlayerStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGameModeBase::ChoosePlayerStart(class AController* Player)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChoosePlayerStart");

	Params::GameModeBase_ChoosePlayerStart Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.FindPlayerStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IncomingName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGameModeBase::FindPlayerStart(class AController* Player, const class FString& IncomingName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindPlayerStart");

	Params::GameModeBase_FindPlayerStart Parms{};

	Parms.Player = Player;
	Parms.IncomingName = std::move(IncomingName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.GetDefaultPawnClassForController
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AController*                      InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* AGameModeBase::GetDefaultPawnClassForController(class AController* InController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultPawnClassForController");

	Params::GameModeBase_GetDefaultPawnClassForController Parms{};

	Parms.InController = InController;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.GetNumPlayers
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeBase::GetNumPlayers()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumPlayers");

	Params::GameModeBase_GetNumPlayers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.GetNumSpectators
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeBase::GetNumSpectators()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumSpectators");

	Params::GameModeBase_GetNumSpectators Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.HandleStartingNewPlayer
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::HandleStartingNewPlayer(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleStartingNewPlayer");

	Params::GameModeBase_HandleStartingNewPlayer Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.InitializeHUDForPlayer
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::InitializeHUDForPlayer(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitializeHUDForPlayer");

	Params::GameModeBase_InitializeHUDForPlayer Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.InitStartSpot
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           StartSpot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::InitStartSpot(class AActor* StartSpot, class AController* NewPlayer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitStartSpot");

	Params::GameModeBase_InitStartSpot Parms{};

	Parms.StartSpot = StartSpot;
	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.K2_FindPlayerStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IncomingName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGameModeBase::K2_FindPlayerStart(class AController* Player, const class FString& IncomingName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_FindPlayerStart");

	Params::GameModeBase_K2_FindPlayerStart Parms{};

	Parms.Player = Player;
	Parms.IncomingName = std::move(IncomingName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.K2_OnChangeName
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNameChange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_OnChangeName(class AController* Other, const class FString& NewName, bool bNameChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnChangeName");

	Params::GameModeBase_K2_OnChangeName Parms{};

	Parms.Other = Other;
	Parms.NewName = std::move(NewName);
	Parms.bNameChange = bNameChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.K2_OnLogout
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      ExitingController                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_OnLogout(class AController* ExitingController)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnLogout");

	Params::GameModeBase_K2_OnLogout Parms{};

	Parms.ExitingController = ExitingController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.K2_OnRestartPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_OnRestartPlayer(class AController* NewPlayer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnRestartPlayer");

	Params::GameModeBase_K2_OnRestartPlayer Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.K2_OnSwapPlayerControllers
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                OldPC                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                NewPC                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_OnSwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnSwapPlayerControllers");

	Params::GameModeBase_K2_OnSwapPlayerControllers Parms{};

	Parms.OldPC = OldPC;
	Parms.NewPC = NewPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.K2_PostLogin
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::K2_PostLogin(class APlayerController* NewPlayer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_PostLogin");

	Params::GameModeBase_K2_PostLogin Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.PlayerCanRestart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::PlayerCanRestart(class APlayerController* Player)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayerCanRestart");

	Params::GameModeBase_PlayerCanRestart Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.ResetLevel
// (Native, Public, BlueprintCallable)

void AGameModeBase::ResetLevel()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameModeBase.RestartPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::RestartPlayer(class AController* NewPlayer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RestartPlayer");

	Params::GameModeBase_RestartPlayer Parms{};

	Parms.NewPlayer = NewPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.RestartPlayerAtPlayerStart
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           StartSpot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeBase::RestartPlayerAtPlayerStart(class AController* NewPlayer, class AActor* StartSpot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RestartPlayerAtPlayerStart");

	Params::GameModeBase_RestartPlayerAtPlayerStart Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.StartSpot = StartSpot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.RestartPlayerAtTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AController*                      NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AGameModeBase::RestartPlayerAtTransform(class AController* NewPlayer, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RestartPlayerAtTransform");

	Params::GameModeBase_RestartPlayerAtTransform Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.SpawnTransform = std::move(SpawnTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameModeBase.ReturnToMainMenuHost
// (Native, Public, BlueprintCallable)

void AGameModeBase::ReturnToMainMenuHost()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReturnToMainMenuHost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameModeBase.ShouldReset
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ActorToReset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::ShouldReset(class AActor* ActorToReset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShouldReset");

	Params::GameModeBase_ShouldReset Parms{};

	Parms.ActorToReset = ActorToReset;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.SpawnDefaultPawnAtTransform
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AController*                      NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AGameModeBase::SpawnDefaultPawnAtTransform(class AController* NewPlayer, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SpawnDefaultPawnAtTransform");

	Params::GameModeBase_SpawnDefaultPawnAtTransform Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.SpawnTransform = std::move(SpawnTransform);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.SpawnDefaultPawnFor
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      NewPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           StartSpot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AGameModeBase::SpawnDefaultPawnFor(class AController* NewPlayer, class AActor* StartSpot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SpawnDefaultPawnFor");

	Params::GameModeBase_SpawnDefaultPawnFor Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.StartSpot = StartSpot;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.StartPlay
// (Native, Public, BlueprintCallable)

void AGameModeBase::StartPlay()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameModeBase.HasMatchEnded
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::HasMatchEnded() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasMatchEnded");

	Params::GameModeBase_HasMatchEnded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.HasMatchStarted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::HasMatchStarted() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasMatchStarted");

	Params::GameModeBase_HasMatchStarted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameModeBase.MustSpectate
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class APlayerController*                NewPlayerController                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeBase::MustSpectate(class APlayerController* NewPlayerController) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MustSpectate");

	Params::GameModeBase_MustSpectate Parms{};

	Parms.NewPlayerController = NewPlayerController;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameInstance.DebugCreatePlayer
// (Exec, Native, Public)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstance::DebugCreatePlayer(int32 ControllerId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugCreatePlayer");

	Params::GameInstance_DebugCreatePlayer Parms{};

	Parms.ControllerId = ControllerId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameInstance.DebugRemovePlayer
// (Exec, Native, Public)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstance::DebugRemovePlayer(int32 ControllerId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugRemovePlayer");

	Params::GameInstance_DebugRemovePlayer Parms{};

	Parms.ControllerId = ControllerId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameInstance.HandleNetworkError
// (Event, Public, BlueprintEvent)
// Parameters:
// ENetworkFailure                         FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsServer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstance::HandleNetworkError(ENetworkFailure FailureType, bool bIsServer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleNetworkError");

	Params::GameInstance_HandleNetworkError Parms{};

	Parms.FailureType = FailureType;
	Parms.bIsServer = bIsServer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameInstance.HandleTravelError
// (Event, Public, BlueprintEvent)
// Parameters:
// ETravelFailure                          FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstance::HandleTravelError(ETravelFailure FailureType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleTravelError");

	Params::GameInstance_HandleTravelError Parms{};

	Parms.FailureType = FailureType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameInstance.ReceiveInit
// (Event, Public, BlueprintEvent)

void UGameInstance::ReceiveInit()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameInstance.ReceiveShutdown
// (Event, Public, BlueprintEvent)

void UGameInstance::ReceiveShutdown()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveShutdown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.DefaultPawn.LookUpAtRate
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::LookUpAtRate(float Rate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LookUpAtRate");

	Params::DefaultPawn_LookUpAtRate Parms{};

	Parms.Rate = Rate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DefaultPawn.MoveForward
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::MoveForward(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MoveForward");

	Params::DefaultPawn_MoveForward Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DefaultPawn.MoveRight
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::MoveRight(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MoveRight");

	Params::DefaultPawn_MoveRight Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DefaultPawn.MoveUp_World
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::MoveUp_World(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MoveUp_World");

	Params::DefaultPawn_MoveUp_World Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DefaultPawn.TurnAtRate
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADefaultPawn::TurnAtRate(float Rate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TurnAtRate");

	Params::DefaultPawn_TurnAtRate Parms{};

	Parms.Rate = Rate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.KismetNodeHelperLibrary.BitIsMarked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetNodeHelperLibrary::BitIsMarked(int32 Data, int32 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BitIsMarked");

	Params::KismetNodeHelperLibrary_BitIsMarked Parms{};

	Parms.Data = Data;
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.ClearAllBits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetNodeHelperLibrary::ClearAllBits(int32* Data)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClearAllBits");

	Params::KismetNodeHelperLibrary_ClearAllBits Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Data != nullptr)
		*Data = Parms.Data;
}


// Function Engine.KismetNodeHelperLibrary.ClearBit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetNodeHelperLibrary::ClearBit(int32* Data, int32 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClearBit");

	Params::KismetNodeHelperLibrary_ClearBit Parms{};

	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Data != nullptr)
		*Data = Parms.Data;
}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                            Enum                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   EnumeratorValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKismetNodeHelperLibrary::GetEnumeratorName(const class UEnum* Enum, uint8 EnumeratorValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEnumeratorName");

	Params::KismetNodeHelperLibrary_GetEnumeratorName Parms{};

	Parms.Enum = Enum;
	Parms.EnumeratorValue = EnumeratorValue;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                            Enum                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   EnumeratorValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetNodeHelperLibrary::GetEnumeratorUserFriendlyName(const class UEnum* Enum, uint8 EnumeratorValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEnumeratorUserFriendlyName");

	Params::KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName Parms{};

	Parms.Enum = Enum;
	Parms.EnumeratorValue = EnumeratorValue;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorValueFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                            Enum                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   EnumeratorIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetNodeHelperLibrary::GetEnumeratorValueFromIndex(const class UEnum* Enum, uint8 EnumeratorIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEnumeratorValueFromIndex");

	Params::KismetNodeHelperLibrary_GetEnumeratorValueFromIndex Parms{};

	Parms.Enum = Enum;
	Parms.EnumeratorIndex = EnumeratorIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumBits                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetNodeHelperLibrary::GetFirstUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetFirstUnmarkedBit");

	Params::KismetNodeHelperLibrary_GetFirstUnmarkedBit Parms{};

	Parms.Data = Data;
	Parms.StartIdx = StartIdx;
	Parms.NumBits = NumBits;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumBits                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetNodeHelperLibrary::GetRandomUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRandomUnmarkedBit");

	Params::KismetNodeHelperLibrary_GetRandomUnmarkedBit Parms{};

	Parms.Data = Data;
	Parms.StartIdx = StartIdx;
	Parms.NumBits = NumBits;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumBits                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRandom                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetNodeHelperLibrary::GetUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits, bool bRandom)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetUnmarkedBit");

	Params::KismetNodeHelperLibrary_GetUnmarkedBit Parms{};

	Parms.Data = Data;
	Parms.StartIdx = StartIdx;
	Parms.NumBits = NumBits;
	Parms.bRandom = bRandom;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetValidValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                            Enum                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   EnumeratorValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetNodeHelperLibrary::GetValidValue(const class UEnum* Enum, uint8 EnumeratorValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetValidValue");

	Params::KismetNodeHelperLibrary_GetValidValue Parms{};

	Parms.Enum = Enum;
	Parms.EnumeratorValue = EnumeratorValue;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.HasMarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumBits                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetNodeHelperLibrary::HasMarkedBit(int32 Data, int32 NumBits)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HasMarkedBit");

	Params::KismetNodeHelperLibrary_HasMarkedBit Parms{};

	Parms.Data = Data;
	Parms.NumBits = NumBits;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumBits                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetNodeHelperLibrary::HasUnmarkedBit(int32 Data, int32 NumBits)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HasUnmarkedBit");

	Params::KismetNodeHelperLibrary_HasUnmarkedBit Parms{};

	Parms.Data = Data;
	Parms.NumBits = NumBits;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.MarkBit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetNodeHelperLibrary::MarkBit(int32* Data, int32 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MarkBit");

	Params::KismetNodeHelperLibrary_MarkBit Parms{};

	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Data != nullptr)
		*Data = Parms.Data;
}


// Function Engine.HUD.AddDebugText
// (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class FString                           DebugText                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DesiredOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipOverwriteCheck                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAbsoluteLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeepAttachedToActor                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFont*                            InFont                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FontScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawShadow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::AddDebugText(const class FString& DebugText, class AActor* SrcActor, float Duration, const struct FVector& Offset, const struct FVector& DesiredOffset, const struct FColor& TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont, float FontScale, bool bDrawShadow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddDebugText");

	Params::HUD_AddDebugText Parms{};

	Parms.DebugText = std::move(DebugText);
	Parms.SrcActor = SrcActor;
	Parms.Duration = Duration;
	Parms.Offset = std::move(Offset);
	Parms.DesiredOffset = std::move(DesiredOffset);
	Parms.TextColor = std::move(TextColor);
	Parms.bSkipOverwriteCheck = bSkipOverwriteCheck;
	Parms.bAbsoluteLocation = bAbsoluteLocation;
	Parms.bKeepAttachedToActor = bKeepAttachedToActor;
	Parms.InFont = InFont;
	Parms.FontScale = FontScale;
	Parms.bDrawShadow = bDrawShadow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.AddHitBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsumesInput                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::AddHitBox(const struct FVector2D& Position, const struct FVector2D& Size, class FName InName, bool bConsumesInput, int32 Priority)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddHitBox");

	Params::HUD_AddHitBox Parms{};

	Parms.Position = std::move(Position);
	Parms.Size = std::move(Size);
	Parms.InName = InName;
	Parms.bConsumesInput = bConsumesInput;
	Parms.Priority = Priority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.DrawLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   StartScreenX                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartScreenY                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndScreenX                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndScreenY                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LineThickness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, const struct FLinearColor& LineColor, float LineThickness)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DrawLine");

	Params::HUD_DrawLine Parms{};

	Parms.StartScreenX = StartScreenX;
	Parms.StartScreenY = StartScreenY;
	Parms.EndScreenX = EndScreenX;
	Parms.EndScreenY = EndScreenY;
	Parms.LineColor = std::move(LineColor);
	Parms.LineThickness = LineThickness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.DrawMaterial
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenW                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenH                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaterialU                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaterialV                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaterialUWidth                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaterialVHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScalePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        RotPivot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawMaterial(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DrawMaterial");

	Params::HUD_DrawMaterial Parms{};

	Parms.Material = Material;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;
	Parms.MaterialU = MaterialU;
	Parms.MaterialV = MaterialV;
	Parms.MaterialUWidth = MaterialUWidth;
	Parms.MaterialVHeight = MaterialVHeight;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;
	Parms.Rotation = Rotation;
	Parms.RotPivot = std::move(RotPivot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.DrawMaterialSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenW                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenH                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScalePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawMaterialSimple(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DrawMaterialSimple");

	Params::HUD_DrawMaterialSimple Parms{};

	Parms.Material = Material;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.DrawMaterialTriangle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        V0_Pos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        V1_Pos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        V2_Pos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        V0_UV                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        V1_UV                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        V2_UV                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     V0_Color                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     V1_Color                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     V2_Color                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawMaterialTriangle(class UMaterialInterface* Material, const struct FVector2D& V0_Pos, const struct FVector2D& V1_Pos, const struct FVector2D& V2_Pos, const struct FVector2D& V0_UV, const struct FVector2D& V1_UV, const struct FVector2D& V2_UV, const struct FLinearColor& V0_Color, const struct FLinearColor& V1_Color, const struct FLinearColor& V2_Color)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DrawMaterialTriangle");

	Params::HUD_DrawMaterialTriangle Parms{};

	Parms.Material = Material;
	Parms.V0_Pos = std::move(V0_Pos);
	Parms.V1_Pos = std::move(V1_Pos);
	Parms.V2_Pos = std::move(V2_Pos);
	Parms.V0_UV = std::move(V0_UV);
	Parms.V1_UV = std::move(V1_UV);
	Parms.V2_UV = std::move(V2_UV);
	Parms.V0_Color = std::move(V0_Color);
	Parms.V1_Color = std::move(V1_Color);
	Parms.V2_Color = std::move(V2_Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.DrawRect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     RectColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenW                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenH                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawRect(const struct FLinearColor& RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DrawRect");

	Params::HUD_DrawRect Parms{};

	Parms.RectColor = std::move(RectColor);
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.DrawText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFont*                            Font                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScalePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawText(const class FString& Text, const struct FLinearColor& TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DrawText");

	Params::HUD_DrawText Parms{};

	Parms.Text = std::move(Text);
	Parms.TextColor = std::move(TextColor);
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.Font = Font;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.DrawTexture
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenW                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenH                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TextureU                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TextureV                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TextureUWidth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TextureVHeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TintColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBlendMode                              BlendMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScalePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        RotPivot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawTexture(class UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, const struct FLinearColor& TintColor, EBlendMode BlendMode, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DrawTexture");

	Params::HUD_DrawTexture Parms{};

	Parms.Texture = Texture;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.ScreenW = ScreenW;
	Parms.ScreenH = ScreenH;
	Parms.TextureU = TextureU;
	Parms.TextureV = TextureV;
	Parms.TextureUWidth = TextureUWidth;
	Parms.TextureVHeight = TextureVHeight;
	Parms.TintColor = std::move(TintColor);
	Parms.BlendMode = BlendMode;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;
	Parms.Rotation = Rotation;
	Parms.RotPivot = std::move(RotPivot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.DrawTextureSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScalePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::DrawTextureSimple(class UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DrawTextureSimple");

	Params::HUD_DrawTextureSimple Parms{};

	Parms.Texture = Texture;
	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;
	Parms.Scale = Scale;
	Parms.bScalePosition = bScalePosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.GetActorsInSelectionRectangle
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        FirstPoint                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        SecondPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeNonCollidingComponents                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActorMustBeFullyEnclosed                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::GetActorsInSelectionRectangle(TSubclassOf<class AActor> ClassFilter, const struct FVector2D& FirstPoint, const struct FVector2D& SecondPoint, TArray<class AActor*>* OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorsInSelectionRectangle");

	Params::HUD_GetActorsInSelectionRectangle Parms{};

	Parms.ClassFilter = ClassFilter;
	Parms.FirstPoint = std::move(FirstPoint);
	Parms.SecondPoint = std::move(SecondPoint);
	Parms.bIncludeNonCollidingComponents = bIncludeNonCollidingComponents;
	Parms.bActorMustBeFullyEnclosed = bActorMustBeFullyEnclosed;

	UObject::ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Engine.HUD.NextDebugTarget
// (Exec, Native, Public)

void AHUD::NextDebugTarget()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NextDebugTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.HUD.PreviousDebugTarget
// (Exec, Native, Public)

void AHUD::PreviousDebugTarget()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PreviousDebugTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.HUD.ReceiveDrawHUD
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   SizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveDrawHUD(int32 SizeX, int32 SizeY)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveDrawHUD");

	Params::HUD_ReceiveDrawHUD Parms{};

	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.ReceiveHitBoxBeginCursorOver
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BoxName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveHitBoxBeginCursorOver(const class FName BoxName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveHitBoxBeginCursorOver");

	Params::HUD_ReceiveHitBoxBeginCursorOver Parms{};

	Parms.BoxName = BoxName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.ReceiveHitBoxClick
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BoxName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveHitBoxClick(const class FName BoxName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveHitBoxClick");

	Params::HUD_ReceiveHitBoxClick Parms{};

	Parms.BoxName = BoxName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.ReceiveHitBoxEndCursorOver
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BoxName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveHitBoxEndCursorOver(const class FName BoxName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveHitBoxEndCursorOver");

	Params::HUD_ReceiveHitBoxEndCursorOver Parms{};

	Parms.BoxName = BoxName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.ReceiveHitBoxRelease
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BoxName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ReceiveHitBoxRelease(const class FName BoxName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveHitBoxRelease");

	Params::HUD_ReceiveHitBoxRelease Parms{};

	Parms.BoxName = BoxName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.RemoveAllDebugStrings
// (Final, Net, NetReliable, Native, Event, Public, NetClient)

void AHUD::RemoveAllDebugStrings()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAllDebugStrings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.HUD.RemoveDebugText
// (Final, Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           SrcActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLeaveDurationText                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::RemoveDebugText(class AActor* SrcActor, bool bLeaveDurationText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveDebugText");

	Params::HUD_RemoveDebugText Parms{};

	Parms.SrcActor = SrcActor;
	Parms.bLeaveDurationText = bLeaveDurationText;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.ShowDebug
// (Exec, Native, Public)
// Parameters:
// class FName                             DebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ShowDebug(class FName DebugType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowDebug");

	Params::HUD_ShowDebug Parms{};

	Parms.DebugType = DebugType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.ShowDebugForReticleTargetToggle
// (Final, Exec, Native, Public)
// Parameters:
// TSubclassOf<class AActor>               DesiredClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ShowDebugForReticleTargetToggle(TSubclassOf<class AActor> DesiredClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowDebugForReticleTargetToggle");

	Params::HUD_ShowDebugForReticleTargetToggle Parms{};

	Parms.DesiredClass = DesiredClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.ShowDebugToggleSubCategory
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::ShowDebugToggleSubCategory(class FName Category)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowDebugToggleSubCategory");

	Params::HUD_ShowDebugToggleSubCategory Parms{};

	Parms.Category = Category;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.HUD.ShowHUD
// (Exec, Native, Public)

void AHUD::ShowHUD()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.HUD.Deproject
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::Deproject(float ScreenX, float ScreenY, struct FVector* WorldPosition, struct FVector* WorldDirection) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Deproject");

	Params::HUD_Deproject Parms{};

	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;

	UObject::ProcessEvent(Func, &Parms);

	if (WorldPosition != nullptr)
		*WorldPosition = std::move(Parms.WorldPosition);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);
}


// Function Engine.HUD.GetOwningPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AHUD::GetOwningPawn() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningPawn");

	Params::HUD_GetOwningPawn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.HUD.GetOwningPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* AHUD::GetOwningPlayerController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningPlayerController");

	Params::HUD_GetOwningPlayerController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.HUD.GetTextSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutWidth                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutHeight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFont*                            Font                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHUD::GetTextSize(const class FString& Text, float* OutWidth, float* OutHeight, class UFont* Font, float Scale) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTextSize");

	Params::HUD_GetTextSize Parms{};

	Parms.Text = std::move(Text);
	Parms.Font = Font;
	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);

	if (OutWidth != nullptr)
		*OutWidth = Parms.OutWidth;

	if (OutHeight != nullptr)
		*OutHeight = Parms.OutHeight;
}


// Function Engine.HUD.Project
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClampToZeroPlane                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AHUD::Project(const struct FVector& Location, bool bClampToZeroPlane) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Project");

	Params::HUD_Project Parms{};

	Parms.Location = std::move(Location);
	Parms.bClampToZeroPlane = bClampToZeroPlane;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotify.GetDefaultTriggerWeightThreshold
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimNotify::GetDefaultTriggerWeightThreshold() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultTriggerWeightThreshold");

	Params::AnimNotify_GetDefaultTriggerWeightThreshold Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotify.GetNotifyName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAnimNotify::GetNotifyName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNotifyName");

	Params::AnimNotify_GetNotifyName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotify.Received_Notify
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotify::Received_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, const struct FAnimNotifyEventReference& EventReference) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Received_Notify");

	Params::AnimNotify_Received_Notify Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.EventReference = std::move(EventReference);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OptionalName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMIDCreationFlags                       CreationFlags                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UKismetMaterialLibrary::CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UMaterialInterface* Parent, class FName OptionalName, EMIDCreationFlags CreationFlags)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateDynamicMaterialInstance");

	Params::KismetMaterialLibrary_CreateDynamicMaterialInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Parent = Parent;
	Parms.OptionalName = OptionalName;
	Parms.CreationFlags = CreationFlags;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMaterialLibrary.GetScalarParameterValue
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*     Collection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMaterialLibrary::GetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetScalarParameterValue");

	Params::KismetMaterialLibrary_GetScalarParameterValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Collection = Collection;
	Parms.ParameterName = ParameterName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMaterialLibrary.GetVectorParameterValue
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*     Collection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMaterialLibrary::GetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetVectorParameterValue");

	Params::KismetMaterialLibrary_GetVectorParameterValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Collection = Collection;
	Parms.ParameterName = ParameterName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMaterialLibrary.SetScalarParameterValue
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*     Collection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParameterValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMaterialLibrary::SetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, float ParameterValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetScalarParameterValue");

	Params::KismetMaterialLibrary_SetScalarParameterValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Collection = Collection;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetMaterialLibrary.SetVectorParameterValue
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialParameterCollection*     Collection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ParameterValue                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMaterialLibrary::SetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, const struct FLinearColor& ParameterValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetVectorParameterValue");

	Params::KismetMaterialLibrary_SetVectorParameterValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Collection = Collection;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = std::move(ParameterValue);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.AnimNotifyState.GetDefaultTriggerWeightThreshold
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimNotifyState::GetDefaultTriggerWeightThreshold() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultTriggerWeightThreshold");

	Params::AnimNotifyState_GetDefaultTriggerWeightThreshold Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyState.GetNotifyName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAnimNotifyState::GetNotifyName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNotifyName");

	Params::AnimNotifyState_GetNotifyName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyState.Received_NotifyBegin
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyState::Received_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration, const struct FAnimNotifyEventReference& EventReference) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Received_NotifyBegin");

	Params::AnimNotifyState_Received_NotifyBegin Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.TotalDuration = TotalDuration;
	Parms.EventReference = std::move(EventReference);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyState.Received_NotifyEnd
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyState::Received_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, const struct FAnimNotifyEventReference& EventReference) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Received_NotifyEnd");

	Params::AnimNotifyState_Received_NotifyEnd Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.EventReference = std::move(EventReference);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyState.Received_NotifyTick
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FrameDeltaTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyState::Received_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime, const struct FAnimNotifyEventReference& EventReference) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Received_NotifyTick");

	Params::AnimNotifyState_Received_NotifyTick Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.FrameDeltaTime = FrameDeltaTime;
	Parms.EventReference = std::move(EventReference);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BoxComponent.SetBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InBoxExtent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBoxComponent::SetBoxExtent(const struct FVector& InBoxExtent, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoxExtent");

	Params::BoxComponent_SetBoxExtent Parms{};

	Parms.InBoxExtent = std::move(InBoxExtent);
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.BoxComponent.GetScaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBoxComponent::GetScaledBoxExtent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledBoxExtent");

	Params::BoxComponent_GetScaledBoxExtent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BoxComponent.GetUnscaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBoxComponent::GetUnscaledBoxExtent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnscaledBoxExtent");

	Params::BoxComponent_GetUnscaledBoxExtent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.RadialForceComponent.AddObjectTypeToAffect
// (Native, Public, BlueprintCallable)
// Parameters:
// EObjectTypeQuery                        ObjectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialForceComponent::AddObjectTypeToAffect(EObjectTypeQuery ObjectType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddObjectTypeToAffect");

	Params::RadialForceComponent_AddObjectTypeToAffect Parms{};

	Parms.ObjectType = ObjectType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.RadialForceComponent.FireImpulse
// (Native, Public, BlueprintCallable)

void URadialForceComponent::FireImpulse()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FireImpulse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.RadialForceComponent.RemoveObjectTypeToAffect
// (Native, Public, BlueprintCallable)
// Parameters:
// EObjectTypeQuery                        ObjectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URadialForceComponent::RemoveObjectTypeToAffect(EObjectTypeQuery ObjectType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveObjectTypeToAffect");

	Params::RadialForceComponent_RemoveObjectTypeToAffect Parms{};

	Parms.ObjectType = ObjectType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.ReleaseToPool
// (Native, Public, BlueprintCallable)

void UFXSystemComponent::ReleaseToPool()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReleaseToPool");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.FXSystemComponent.SetActorParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetActorParameter(class FName ParameterName, class AActor* Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActorParameter");

	Params::FXSystemComponent_SetActorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.SetAutoAttachmentParameters
// (Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         LocationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         RotationRule                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachmentRule                         ScaleRule                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetAutoAttachmentParameters(class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAutoAttachmentParameters");

	Params::FXSystemComponent_SetAutoAttachmentParameters Parms{};

	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationRule = LocationRule;
	Parms.RotationRule = RotationRule;
	Parms.ScaleRule = ScaleRule;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.SetBoolParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetBoolParameter(class FName ParameterName, bool Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoolParameter");

	Params::FXSystemComponent_SetBoolParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.SetColorParameter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetColorParameter(class FName ParameterName, const struct FLinearColor& Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColorParameter");

	Params::FXSystemComponent_SetColorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.SetEmitterEnable
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EmitterName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewEnableState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetEmitterEnable(class FName EmitterName, bool bNewEnableState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEmitterEnable");

	Params::FXSystemComponent_SetEmitterEnable Parms{};

	Parms.EmitterName = EmitterName;
	Parms.bNewEnableState = bNewEnableState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.SetFloatParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetFloatParameter(class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFloatParameter");

	Params::FXSystemComponent_SetFloatParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.SetIntParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetIntParameter(class FName ParameterName, int32 Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIntParameter");

	Params::FXSystemComponent_SetIntParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.SetUseAutoManageAttachment
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAutoManage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetUseAutoManageAttachment(bool bAutoManage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUseAutoManageAttachment");

	Params::FXSystemComponent_SetUseAutoManageAttachment Parms{};

	Parms.bAutoManage = bAutoManage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.SetVectorParameter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFXSystemComponent::SetVectorParameter(class FName ParameterName, const struct FVector& Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorParameter");

	Params::FXSystemComponent_SetVectorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.FXSystemComponent.GetFXSystemAsset
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFXSystemAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemAsset* UFXSystemComponent::GetFXSystemAsset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFXSystemAsset");

	Params::FXSystemComponent_GetFXSystemAsset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.NavMovementComponent.StopActiveMovement
// (Native, Public, BlueprintCallable)

void UNavMovementComponent::StopActiveMovement()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopActiveMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.NavMovementComponent.StopMovementKeepPathing
// (Final, Native, Public, BlueprintCallable)

void UNavMovementComponent::StopMovementKeepPathing()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopMovementKeepPathing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.NavMovementComponent.IsCrouching
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsCrouching() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsCrouching");

	Params::NavMovementComponent_IsCrouching Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.NavMovementComponent.IsFalling
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsFalling() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsFalling");

	Params::NavMovementComponent_IsFalling Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.NavMovementComponent.IsFlying
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsFlying() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsFlying");

	Params::NavMovementComponent_IsFlying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.NavMovementComponent.IsMovingOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsMovingOnGround() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsMovingOnGround");

	Params::NavMovementComponent_IsMovingOnGround Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.NavMovementComponent.IsSwimming
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNavMovementComponent::IsSwimming() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSwimming");

	Params::NavMovementComponent_IsSwimming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PawnMovementComponent.AddInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldVector                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPawnMovementComponent::AddInputVector(const struct FVector& WorldVector, bool bForce)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddInputVector");

	Params::PawnMovementComponent_AddInputVector Parms{};

	Parms.WorldVector = std::move(WorldVector);
	Parms.bForce = bForce;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PawnMovementComponent.ConsumeInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPawnMovementComponent::ConsumeInputVector()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConsumeInputVector");

	Params::PawnMovementComponent_ConsumeInputVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PawnMovementComponent.GetLastInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPawnMovementComponent::GetLastInputVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastInputVector");

	Params::PawnMovementComponent_GetLastInputVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PawnMovementComponent.GetPawnOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UPawnMovementComponent::GetPawnOwner() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPawnOwner");

	Params::PawnMovementComponent_GetPawnOwner Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PawnMovementComponent.GetPendingInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPawnMovementComponent::GetPendingInputVector() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPendingInputVector");

	Params::PawnMovementComponent_GetPendingInputVector Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PawnMovementComponent.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPawnMovementComponent::IsMoveInputIgnored() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsMoveInputIgnored");

	Params::PawnMovementComponent_IsMoveInputIgnored Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AudioVolume.OnRep_bEnabled
// (Final, Native, Private)

void AAudioVolume::OnRep_bEnabled()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AudioVolume.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAudioVolume::SetEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnabled");

	Params::AudioVolume_SetEnabled Parms{};

	Parms.bNewEnabled = bNewEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioVolume.SetInteriorSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInteriorSettings                NewInteriorSettings                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AAudioVolume::SetInteriorSettings(const struct FInteriorSettings& NewInteriorSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInteriorSettings");

	Params::AudioVolume_SetInteriorSettings Parms{};

	Parms.NewInteriorSettings = std::move(NewInteriorSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioVolume.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAudioVolume::SetPriority(float NewPriority)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPriority");

	Params::AudioVolume_SetPriority Parms{};

	Parms.NewPriority = NewPriority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioVolume.SetReverbSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FReverbSettings                  NewReverbSettings                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AAudioVolume::SetReverbSettings(const struct FReverbSettings& NewReverbSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetReverbSettings");

	Params::AudioVolume_SetReverbSettings Parms{};

	Parms.NewReverbSettings = std::move(NewReverbSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioVolume.SetSubmixOverrideSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FAudioVolumeSubmixOverrideSettings>NewSubmixOverrideSettings                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AAudioVolume::SetSubmixOverrideSettings(const TArray<struct FAudioVolumeSubmixOverrideSettings>& NewSubmixOverrideSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSubmixOverrideSettings");

	Params::AudioVolume_SetSubmixOverrideSettings Parms{};

	Parms.NewSubmixOverrideSettings = std::move(NewSubmixOverrideSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioVolume.SetSubmixSendSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FAudioVolumeSubmixSendSettings>NewSubmixSendSettings                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AAudioVolume::SetSubmixSendSettings(const TArray<struct FAudioVolumeSubmixSendSettings>& NewSubmixSendSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSubmixSendSettings");

	Params::AudioVolume_SetSubmixSendSettings Parms{};

	Parms.NewSubmixSendSettings = std::move(NewSubmixSendSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Predefined Function
// Gets a pointer to a valid UObject of type UEngine

class UEngine* UEngine::GetEngine()
{
	static UEngine* GEngine = nullptr;

	if (GEngine)
		return GEngine;
	
	/* (Re-)Initialize if GEngine is nullptr */
	for (int i = 0; i < UObject::GObjects->Num(); i++)
	{
		UObject* Obj = UObject::GObjects->GetByIndex(i);

		if (!Obj)
			continue;

		if (Obj->IsA(UEngine::StaticClass()) && !Obj->IsDefaultObject())
		{
			GEngine = static_cast<UEngine*>(Obj);
			break;
		}
	}

	return GEngine; 
}


// Function Engine.WorldSettings.OnRep_WorldGravityZ
// (Native, Public)

void AWorldSettings::OnRep_WorldGravityZ()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_WorldGravityZ");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.MeshComponent.PrestreamTextures
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrioritizeCharacterTextures                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CinematicTextureGroups                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshComponent::PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PrestreamTextures");

	Params::MeshComponent_PrestreamTextures Parms{};

	Parms.Seconds = Seconds;
	Parms.bPrioritizeCharacterTextures = bPrioritizeCharacterTextures;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MeshComponent.SetScalarParameterValueOnMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParameterValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshComponent::SetScalarParameterValueOnMaterials(const class FName ParameterName, const float ParameterValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarParameterValueOnMaterials");

	Params::MeshComponent_SetScalarParameterValueOnMaterials Parms{};

	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MeshComponent.SetVectorParameterValueOnMaterials
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ParameterValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshComponent::SetVectorParameterValueOnMaterials(const class FName ParameterName, const struct FVector& ParameterValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorParameterValueOnMaterials");

	Params::MeshComponent_SetVectorParameterValueOnMaterials Parms{};

	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = std::move(ParameterValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MeshComponent.GetMaterialIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMeshComponent::GetMaterialIndex(class FName MaterialSlotName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterialIndex");

	Params::MeshComponent_GetMaterialIndex Parms{};

	Parms.MaterialSlotName = MaterialSlotName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MeshComponent.GetMaterials
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UMaterialInterface*>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInterface*> UMeshComponent::GetMaterials() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterials");

	Params::MeshComponent_GetMaterials Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MeshComponent.GetMaterialSlotNames
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UMeshComponent::GetMaterialSlotNames() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterialSlotNames");

	Params::MeshComponent_GetMaterialSlotNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MeshComponent.IsMaterialSlotNameValid
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMeshComponent::IsMaterialSlotNameValid(class FName MaterialSlotName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsMaterialSlotNameValid");

	Params::MeshComponent_IsMaterialSlotNameValid Parms{};

	Parms.MaterialSlotName = MaterialSlotName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.ClearSkinWeightOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::ClearSkinWeightOverride(int32 LODIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearSkinWeightOverride");

	Params::SkinnedMeshComponent_ClearSkinWeightOverride Parms{};

	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.ClearSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)

void USkinnedMeshComponent::ClearSkinWeightProfile()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearSkinWeightProfile");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkinnedMeshComponent.ClearVertexColorOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::ClearVertexColorOverride(int32 LODIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearVertexColorOverride");

	Params::SkinnedMeshComponent_ClearVertexColorOverride Parms{};

	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.HideBoneByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysBodyOp                             PhysBodyOption                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::HideBoneByName(class FName BoneName, EPhysBodyOp PhysBodyOption)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HideBoneByName");

	Params::SkinnedMeshComponent_HideBoneByName Parms{};

	Parms.BoneName = BoneName;
	Parms.PhysBodyOption = PhysBodyOption;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.IsBoneHiddenByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::IsBoneHiddenByName(class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsBoneHiddenByName");

	Params::SkinnedMeshComponent_IsBoneHiddenByName Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.IsMaterialSectionShown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MaterialID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::IsMaterialSectionShown(int32 MaterialID, int32 LODIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsMaterialSectionShown");

	Params::SkinnedMeshComponent_IsMaterialSectionShown Parms{};

	Parms.MaterialID = MaterialID;
	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.SetCapsuleIndirectShadowMinVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetCapsuleIndirectShadowMinVisibility(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCapsuleIndirectShadowMinVisibility");

	Params::SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetCastCapsuleDirectShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetCastCapsuleDirectShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastCapsuleDirectShadow");

	Params::SkinnedMeshComponent_SetCastCapsuleDirectShadow Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetCastCapsuleIndirectShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetCastCapsuleIndirectShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastCapsuleIndirectShadow");

	Params::SkinnedMeshComponent_SetCastCapsuleIndirectShadow Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetForcedLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNewForcedLOD                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetForcedLOD(int32 InNewForcedLOD)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForcedLOD");

	Params::SkinnedMeshComponent_SetForcedLOD Parms{};

	Parms.InNewForcedLOD = InNewForcedLOD;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkinnedMeshComponent*            NewMasterBoneComponent                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetMasterPoseComponent(class USkinnedMeshComponent* NewMasterBoneComponent, bool bForceUpdate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMasterPoseComponent");

	Params::SkinnedMeshComponent_SetMasterPoseComponent Parms{};

	Parms.NewMasterBoneComponent = NewMasterBoneComponent;
	Parms.bForceUpdate = bForceUpdate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetMinLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNewMinLOD                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetMinLOD(int32 InNewMinLOD)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinLOD");

	Params::SkinnedMeshComponent_SetMinLOD Parms{};

	Parms.InNewMinLOD = InNewMinLOD;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetPhysicsAsset
// (Native, Public, BlueprintCallable)
// Parameters:
// class UPhysicsAsset*                    NewPhysicsAsset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReInit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPhysicsAsset");

	Params::SkinnedMeshComponent_SetPhysicsAsset Parms{};

	Parms.NewPhysicsAsset = NewPhysicsAsset;
	Parms.bForceReInit = bForceReInit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetPostSkinningOffsets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Offsets                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetPostSkinningOffsets(int32 LODIndex, const TArray<struct FVector>& Offsets)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPostSkinningOffsets");

	Params::SkinnedMeshComponent_SetPostSkinningOffsets Parms{};

	Parms.LODIndex = LODIndex;
	Parms.Offsets = std::move(Offsets);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetPreSkinningOffsets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Offsets                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetPreSkinningOffsets(int32 LODIndex, const TArray<struct FVector>& Offsets)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPreSkinningOffsets");

	Params::SkinnedMeshComponent_SetPreSkinningOffsets Parms{};

	Parms.LODIndex = LODIndex;
	Parms.Offsets = std::move(Offsets);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetRenderStatic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetRenderStatic(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRenderStatic");

	Params::SkinnedMeshComponent_SetRenderStatic Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetSkeletalMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    NewMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReinitPose                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetSkeletalMesh(class USkeletalMesh* NewMesh, bool bReinitPose)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSkeletalMesh");

	Params::SkinnedMeshComponent_SetSkeletalMesh Parms{};

	Parms.NewMesh = NewMesh;
	Parms.bReinitPose = bReinitPose;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetSkinWeightOverride
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSkelMeshSkinWeightInfo>  SkinWeights                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetSkinWeightOverride(int32 LODIndex, const TArray<struct FSkelMeshSkinWeightInfo>& SkinWeights)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSkinWeightOverride");

	Params::SkinnedMeshComponent_SetSkinWeightOverride Parms{};

	Parms.LODIndex = LODIndex;
	Parms.SkinWeights = std::move(SkinWeights);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InProfileName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::SetSkinWeightProfile(class FName InProfileName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSkinWeightProfile");

	Params::SkinnedMeshComponent_SetSkinWeightProfile Parms{};

	Parms.InProfileName = InProfileName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.SetVertexColorOverride_LinearColor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>             VertexColors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetVertexColorOverride_LinearColor(int32 LODIndex, const TArray<struct FLinearColor>& VertexColors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVertexColorOverride_LinearColor");

	Params::SkinnedMeshComponent_SetVertexColorOverride_LinearColor Parms{};

	Parms.LODIndex = LODIndex;
	Parms.VertexColors = std::move(VertexColors);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.SetVertexOffsetUsage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Usage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::SetVertexOffsetUsage(int32 LODIndex, int32 Usage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVertexOffsetUsage");

	Params::SkinnedMeshComponent_SetVertexOffsetUsage Parms{};

	Parms.LODIndex = LODIndex;
	Parms.Usage = Usage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.ShowAllMaterialSections
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::ShowAllMaterialSections(int32 LODIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowAllMaterialSections");

	Params::SkinnedMeshComponent_ShowAllMaterialSections Parms{};

	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.ShowMaterialSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MaterialID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::ShowMaterialSection(int32 MaterialID, int32 SectionIndex, bool bShow, int32 LODIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowMaterialSection");

	Params::SkinnedMeshComponent_ShowMaterialSection Parms{};

	Parms.MaterialID = MaterialID;
	Parms.SectionIndex = SectionIndex;
	Parms.bShow = bShow;
	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.TransformFromBoneSpace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::TransformFromBoneSpace(class FName BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TransformFromBoneSpace");

	Params::SkinnedMeshComponent_TransformFromBoneSpace Parms{};

	Parms.BoneName = BoneName;
	Parms.InPosition = std::move(InPosition);
	Parms.InRotation = std::move(InRotation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function Engine.SkinnedMeshComponent.UnHideBoneByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::UnHideBoneByName(class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnHideBoneByName");

	Params::SkinnedMeshComponent_UnHideBoneByName Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.UnloadSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InProfileName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::UnloadSkinWeightProfile(class FName InProfileName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnloadSkinWeightProfile");

	Params::SkinnedMeshComponent_UnloadSkinWeightProfile Parms{};

	Parms.InProfileName = InProfileName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkinnedMeshComponent.BoneIsChildOf
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParentBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::BoneIsChildOf(class FName BoneName, class FName ParentBoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BoneIsChildOf");

	Params::SkinnedMeshComponent_BoneIsChildOf Parms{};

	Parms.BoneName = BoneName;
	Parms.ParentBoneName = ParentBoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.FindClosestBone_K2
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          TestLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoneLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IgnoreScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequirePhysicsAsset                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::FindClosestBone_K2(const struct FVector& TestLocation, struct FVector* BoneLocation, float IgnoreScale, bool bRequirePhysicsAsset) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindClosestBone_K2");

	Params::SkinnedMeshComponent_FindClosestBone_K2 Parms{};

	Parms.TestLocation = std::move(TestLocation);
	Parms.IgnoreScale = IgnoreScale;
	Parms.bRequirePhysicsAsset = bRequirePhysicsAsset;

	UObject::ProcessEvent(Func, &Parms);

	if (BoneLocation != nullptr)
		*BoneLocation = std::move(Parms.BoneLocation);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetBoneIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetBoneIndex(class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneIndex");

	Params::SkinnedMeshComponent_GetBoneIndex Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   BoneIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::GetBoneName(int32 BoneIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneName");

	Params::SkinnedMeshComponent_GetBoneName Parms{};

	Parms.BoneIndex = BoneIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetCurrentSkinWeightProfileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::GetCurrentSkinWeightProfileName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentSkinWeightProfileName");

	Params::SkinnedMeshComponent_GetCurrentSkinWeightProfileName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetDeltaTransformFromRefPose
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BaseName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USkinnedMeshComponent::GetDeltaTransformFromRefPose(class FName BoneName, class FName BaseName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDeltaTransformFromRefPose");

	Params::SkinnedMeshComponent_GetDeltaTransformFromRefPose Parms{};

	Parms.BoneName = BoneName;
	Parms.BaseName = BaseName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetForcedLOD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetForcedLOD() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetForcedLOD");

	Params::SkinnedMeshComponent_GetForcedLOD Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetNumBones
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetNumBones() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumBones");

	Params::SkinnedMeshComponent_GetNumBones Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetNumLODs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetNumLODs() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumLODs");

	Params::SkinnedMeshComponent_GetNumLODs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetParentBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::GetParentBone(class FName BoneName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParentBone");

	Params::SkinnedMeshComponent_GetParentBone Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetRefPosePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   BoneIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USkinnedMeshComponent::GetRefPosePosition(int32 BoneIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRefPosePosition");

	Params::SkinnedMeshComponent_GetRefPosePosition Parms{};

	Parms.BoneIndex = BoneIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetRefPoseTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   BoneIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USkinnedMeshComponent::GetRefPoseTransform(int32 BoneIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRefPoseTransform");

	Params::SkinnedMeshComponent_GetRefPoseTransform Parms{};

	Parms.BoneIndex = BoneIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetSocketBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkinnedMeshComponent::GetSocketBoneName(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSocketBoneName");

	Params::SkinnedMeshComponent_GetSocketBoneName Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetTwistAndSwingAngleOfDeltaRotationFromRefPose
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTwistAngle                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutSwingAngle                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::GetTwistAndSwingAngleOfDeltaRotationFromRefPose(class FName BoneName, float* OutTwistAngle, float* OutSwingAngle) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTwistAndSwingAngleOfDeltaRotationFromRefPose");

	Params::SkinnedMeshComponent_GetTwistAndSwingAngleOfDeltaRotationFromRefPose Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	if (OutTwistAngle != nullptr)
		*OutTwistAngle = Parms.OutTwistAngle;

	if (OutSwingAngle != nullptr)
		*OutSwingAngle = Parms.OutSwingAngle;

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetVertexOffsetUsage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkinnedMeshComponent::GetVertexOffsetUsage(int32 LODIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVertexOffsetUsage");

	Params::SkinnedMeshComponent_GetVertexOffsetUsage Parms{};

	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.IsUsingSkinWeightProfile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkinnedMeshComponent::IsUsingSkinWeightProfile() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsUsingSkinWeightProfile");

	Params::SkinnedMeshComponent_IsUsingSkinWeightProfile Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.TransformToBoneSpace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutPosition                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void USkinnedMeshComponent::TransformToBoneSpace(class FName BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TransformToBoneSpace");

	Params::SkinnedMeshComponent_TransformToBoneSpace Parms{};

	Parms.BoneName = BoneName;
	Parms.InPosition = std::move(InPosition);
	Parms.InRotation = std::move(InRotation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutPosition != nullptr)
		*OutPosition = std::move(Parms.OutPosition);

	if (OutRotation != nullptr)
		*OutRotation = std::move(Parms.OutRotation);
}


// Function Engine.GameViewportClient.SetConsoleTarget
// (Exec, Native, Public)
// Parameters:
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameViewportClient::SetConsoleTarget(int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConsoleTarget");

	Params::GameViewportClient_SetConsoleTarget Parms{};

	Parms.PlayerIndex = PlayerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameViewportClient.ShowTitleSafeArea
// (Exec, Native, Public)

void UGameViewportClient::ShowTitleSafeArea()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowTitleSafeArea");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameViewportClient.SSSwapControllers
// (Exec, Native, Public)

void UGameViewportClient::SSSwapControllers()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SSSwapControllers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AnimInstance.BlueprintBeginPlay
// (Event, Public, BlueprintEvent)

void UAnimInstance::BlueprintBeginPlay()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AnimInstance.BlueprintInitializeAnimation
// (Event, Public, BlueprintEvent)

void UAnimInstance::BlueprintInitializeAnimation()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintInitializeAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AnimInstance.BlueprintLinkedAnimationLayersInitialized
// (Event, Public, BlueprintEvent)

void UAnimInstance::BlueprintLinkedAnimationLayersInitialized()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintLinkedAnimationLayersInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AnimInstance.BlueprintPostEvaluateAnimation
// (Event, Public, BlueprintEvent)

void UAnimInstance::BlueprintPostEvaluateAnimation()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintPostEvaluateAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AnimInstance.BlueprintThreadSafeUpdateAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::BlueprintThreadSafeUpdateAnimation(float DeltaTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintThreadSafeUpdateAnimation");

	Params::AnimInstance_BlueprintThreadSafeUpdateAnimation Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.BlueprintUpdateAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTimeX                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::BlueprintUpdateAnimation(float DeltaTimeX)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintUpdateAnimation");

	Params::AnimInstance_BlueprintUpdateAnimation Parms{};

	Parms.DeltaTimeX = DeltaTimeX;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.ClearMorphTargets
// (Final, Native, Public, BlueprintCallable)

void UAnimInstance::ClearMorphTargets()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMorphTargets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AnimInstance.GetCurrentStateName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAnimInstance::GetCurrentStateName(int32 MachineIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentStateName");

	Params::AnimInstance_GetCurrentStateName Parms{};

	Parms.MachineIndex = MachineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   AssetPlayerIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerLength(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceAssetPlayerLength");

	Params::AnimInstance_GetInstanceAssetPlayerLength Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   AssetPlayerIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerTime(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceAssetPlayerTime");

	Params::AnimInstance_GetInstanceAssetPlayerTime Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   AssetPlayerIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerTimeFraction(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceAssetPlayerTimeFraction");

	Params::AnimInstance_GetInstanceAssetPlayerTimeFraction Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   AssetPlayerIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerTimeFromEnd(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceAssetPlayerTimeFromEnd");

	Params::AnimInstance_GetInstanceAssetPlayerTimeFromEnd Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   AssetPlayerIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceAssetPlayerTimeFromEndFraction(int32 AssetPlayerIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceAssetPlayerTimeFromEndFraction");

	Params::AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction Parms{};

	Parms.AssetPlayerIndex = AssetPlayerIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceCurrentStateElapsedTime(int32 MachineIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceCurrentStateElapsedTime");

	Params::AnimInstance_GetInstanceCurrentStateElapsedTime Parms{};

	Parms.MachineIndex = MachineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceMachineWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceMachineWeight(int32 MachineIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceMachineWeight");

	Params::AnimInstance_GetInstanceMachineWeight Parms{};

	Parms.MachineIndex = MachineIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceStateWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceStateWeight(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceStateWeight");

	Params::AnimInstance_GetInstanceStateWeight Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TransitionIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceTransitionCrossfadeDuration(int32 MachineIndex, int32 TransitionIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceTransitionCrossfadeDuration");

	Params::AnimInstance_GetInstanceTransitionCrossfadeDuration Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.TransitionIndex = TransitionIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TransitionIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceTransitionTimeElapsed(int32 MachineIndex, int32 TransitionIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceTransitionTimeElapsed");

	Params::AnimInstance_GetInstanceTransitionTimeElapsed Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.TransitionIndex = TransitionIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TransitionIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetInstanceTransitionTimeElapsedFraction(int32 MachineIndex, int32 TransitionIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceTransitionTimeElapsedFraction");

	Params::AnimInstance_GetInstanceTransitionTimeElapsedFraction Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.TransitionIndex = TransitionIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimLength(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRelevantAnimLength");

	Params::AnimInstance_GetRelevantAnimLength Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimTime(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRelevantAnimTime");

	Params::AnimInstance_GetRelevantAnimTime Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimTimeFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimTimeFraction(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRelevantAnimTimeFraction");

	Params::AnimInstance_GetRelevantAnimTimeFraction Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimTimeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimTimeRemaining(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRelevantAnimTimeRemaining");

	Params::AnimInstance_GetRelevantAnimTimeRemaining Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetRelevantAnimTimeRemainingFraction(int32 MachineIndex, int32 StateIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRelevantAnimTimeRemainingFraction");

	Params::AnimInstance_GetRelevantAnimTimeRemainingFraction Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.LinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::LinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LinkAnimClassLayers");

	Params::AnimInstance_LinkAnimClassLayers Parms{};

	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.LinkAnimGraphByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InTag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::LinkAnimGraphByTag(class FName InTag, TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LinkAnimGraphByTag");

	Params::AnimInstance_LinkAnimGraphByTag Parms{};

	Parms.InTag = InTag;
	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.LockAIResources
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLockMovement                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LockAILogic                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::LockAIResources(bool bLockMovement, bool LockAILogic)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LockAIResources");

	Params::AnimInstance_LockAIResources Parms{};

	Parms.bLockMovement = bLockMovement;
	Parms.LockAILogic = LockAILogic;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_JumpToSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_JumpToSection(class FName SectionName, const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_JumpToSection");

	Params::AnimInstance_Montage_JumpToSection Parms{};

	Parms.SectionName = SectionName;
	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_JumpToSectionsEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_JumpToSectionsEnd(class FName SectionName, const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_JumpToSectionsEnd");

	Params::AnimInstance_Montage_JumpToSectionsEnd Parms{};

	Parms.SectionName = SectionName;
	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_Pause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_Pause(const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_Pause");

	Params::AnimInstance_Montage_Pause Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMontagePlayReturnType                  ReturnValueType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopAllMontages                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_Play(class UAnimMontage* MontageToPlay, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_Play");

	Params::AnimInstance_Montage_Play Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.InPlayRate = InPlayRate;
	Parms.ReturnValueType = ReturnValueType;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;
	Parms.bStopAllMontages = bStopAllMontages;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_PlayWithBlendIn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAlphaBlendArgs                  BlendIn                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMontagePlayReturnType                  ReturnValueType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopAllMontages                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_PlayWithBlendIn(class UAnimMontage* MontageToPlay, const struct FAlphaBlendArgs& BlendIn, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_PlayWithBlendIn");

	Params::AnimInstance_Montage_PlayWithBlendIn Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.BlendIn = std::move(BlendIn);
	Parms.InPlayRate = InPlayRate;
	Parms.ReturnValueType = ReturnValueType;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;
	Parms.bStopAllMontages = bStopAllMontages;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_PlayWithBlendSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMontageBlendSettings            BlendInSettings                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMontagePlayReturnType                  ReturnValueType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopAllMontages                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_PlayWithBlendSettings(class UAnimMontage* MontageToPlay, const struct FMontageBlendSettings& BlendInSettings, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_PlayWithBlendSettings");

	Params::AnimInstance_Montage_PlayWithBlendSettings Parms{};

	Parms.MontageToPlay = MontageToPlay;
	Parms.BlendInSettings = std::move(BlendInSettings);
	Parms.InPlayRate = InPlayRate;
	Parms.ReturnValueType = ReturnValueType;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;
	Parms.bStopAllMontages = bStopAllMontages;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_Resume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_Resume(const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_Resume");

	Params::AnimInstance_Montage_Resume Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_SetNextSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SectionNameToChange                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NextSection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_SetNextSection(class FName SectionNameToChange, class FName NextSection, const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_SetNextSection");

	Params::AnimInstance_Montage_SetNextSection Parms{};

	Parms.SectionNameToChange = SectionNameToChange;
	Parms.NextSection = NextSection;
	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPlayRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_SetPlayRate(const class UAnimMontage* Montage, float NewPlayRate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_SetPlayRate");

	Params::AnimInstance_Montage_SetPlayRate Parms{};

	Parms.Montage = Montage;
	Parms.NewPlayRate = NewPlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_SetPosition(const class UAnimMontage* Montage, float NewPosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_SetPosition");

	Params::AnimInstance_Montage_SetPosition Parms{};

	Parms.Montage = Montage;
	Parms.NewPosition = NewPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_Stop(float InBlendOutTime, const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_Stop");

	Params::AnimInstance_Montage_Stop Parms{};

	Parms.InBlendOutTime = InBlendOutTime;
	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_StopGroupByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_StopGroupByName(float InBlendOutTime, class FName GroupName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_StopGroupByName");

	Params::AnimInstance_Montage_StopGroupByName Parms{};

	Parms.InBlendOutTime = InBlendOutTime;
	Parms.GroupName = GroupName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_StopWithBlendOut
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAlphaBlendArgs                  BlendOut                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_StopWithBlendOut(const struct FAlphaBlendArgs& BlendOut, const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_StopWithBlendOut");

	Params::AnimInstance_Montage_StopWithBlendOut Parms{};

	Parms.BlendOut = std::move(BlendOut);
	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.Montage_StopWithBlendSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMontageBlendSettings            BlendOutSettings                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::Montage_StopWithBlendSettings(const struct FMontageBlendSettings& BlendOutSettings, const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_StopWithBlendSettings");

	Params::AnimInstance_Montage_StopWithBlendSettings Parms{};

	Parms.BlendOutSettings = std::move(BlendOutSettings);
	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTriggerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage(class UAnimSequenceBase* Asset, class FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlaySlotAnimationAsDynamicMontage");

	Params::AnimInstance_PlaySlotAnimationAsDynamicMontage Parms{};

	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage_WithBlendArgs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAlphaBlendArgs                  BlendIn                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAlphaBlendArgs                  BlendOut                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTriggerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage_WithBlendArgs(class UAnimSequenceBase* Asset, class FName SlotNodeName, const struct FAlphaBlendArgs& BlendIn, const struct FAlphaBlendArgs& BlendOut, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlaySlotAnimationAsDynamicMontage_WithBlendArgs");

	Params::AnimInstance_PlaySlotAnimationAsDynamicMontage_WithBlendArgs Parms{};

	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;
	Parms.BlendIn = std::move(BlendIn);
	Parms.BlendOut = std::move(BlendOut);
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage_WithBlendSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMontageBlendSettings            BlendInSettings                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FMontageBlendSettings            BlendOutSettings                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTriggerTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeToStartMontageAt                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UAnimInstance::PlaySlotAnimationAsDynamicMontage_WithBlendSettings(class UAnimSequenceBase* Asset, class FName SlotNodeName, const struct FMontageBlendSettings& BlendInSettings, const struct FMontageBlendSettings& BlendOutSettings, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlaySlotAnimationAsDynamicMontage_WithBlendSettings");

	Params::AnimInstance_PlaySlotAnimationAsDynamicMontage_WithBlendSettings Parms{};

	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;
	Parms.BlendInSettings = std::move(BlendInSettings);
	Parms.BlendOutSettings = std::move(BlendOutSettings);
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;
	Parms.BlendOutTriggerTime = BlendOutTriggerTime;
	Parms.InTimeToStartMontageAt = InTimeToStartMontageAt;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.RemovePoseSnapshot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SnapshotName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::RemovePoseSnapshot(class FName SnapshotName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemovePoseSnapshot");

	Params::AnimInstance_RemovePoseSnapshot Parms{};

	Parms.SnapshotName = SnapshotName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.RequestSlotGroupInertialization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InSlotGroupName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::RequestSlotGroupInertialization(class FName InSlotGroupName, float Duration)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RequestSlotGroupInertialization");

	Params::AnimInstance_RequestSlotGroupInertialization Parms{};

	Parms.InSlotGroupName = InSlotGroupName;
	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.ResetDynamics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETeleportType                           InTeleportType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::ResetDynamics(ETeleportType InTeleportType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetDynamics");

	Params::AnimInstance_ResetDynamics Parms{};

	Parms.InTeleportType = InTeleportType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.SavePoseSnapshot
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SnapshotName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SavePoseSnapshot(class FName SnapshotName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SavePoseSnapshot");

	Params::AnimInstance_SavePoseSnapshot Parms{};

	Parms.SnapshotName = SnapshotName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.SetMorphTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MorphTargetName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetMorphTarget(class FName MorphTargetName, float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMorphTarget");

	Params::AnimInstance_SetMorphTarget Parms{};

	Parms.MorphTargetName = MorphTargetName;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.SetPropagateNotifiesToLinkedInstances
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetPropagateNotifiesToLinkedInstances(bool bSet)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPropagateNotifiesToLinkedInstances");

	Params::AnimInstance_SetPropagateNotifiesToLinkedInstances Parms{};

	Parms.bSet = bSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.SetReceiveNotifiesFromLinkedInstances
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetReceiveNotifiesFromLinkedInstances(bool bSet)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetReceiveNotifiesFromLinkedInstances");

	Params::AnimInstance_SetReceiveNotifiesFromLinkedInstances Parms{};

	Parms.bSet = bSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.SetRootMotionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERootMotionMode                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetRootMotionMode(ERootMotionMode Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRootMotionMode");

	Params::AnimInstance_SetRootMotionMode Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.SetUseMainInstanceMontageEvaluationData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::SetUseMainInstanceMontageEvaluationData(bool bSet)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUseMainInstanceMontageEvaluationData");

	Params::AnimInstance_SetUseMainInstanceMontageEvaluationData Parms{};

	Parms.bSet = bSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.SnapshotPose
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseSnapshot                    Snapshot                                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAnimInstance::SnapshotPose(struct FPoseSnapshot& Snapshot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SnapshotPose");

	Params::AnimInstance_SnapshotPose Parms{};

	Parms.Snapshot = std::move(Snapshot);

	UObject::ProcessEvent(Func, &Parms);

	Snapshot = std::move(Parms.Snapshot);
}


// Function Engine.AnimInstance.StopSlotAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::StopSlotAnimation(float InBlendOutTime, class FName SlotNodeName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopSlotAnimation");

	Params::AnimInstance_StopSlotAnimation Parms{};

	Parms.InBlendOutTime = InBlendOutTime;
	Parms.SlotNodeName = SlotNodeName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.UnlinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::UnlinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnlinkAnimClassLayers");

	Params::AnimInstance_UnlinkAnimClassLayers Parms{};

	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.UnlockAIResources
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUnlockMovement                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UnlockAILogic                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimInstance::UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnlockAIResources");

	Params::AnimInstance_UnlockAIResources Parms{};

	Parms.bUnlockMovement = bUnlockMovement;
	Parms.UnlockAILogic = UnlockAILogic;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimInstance.WasAnimNotifyNameTriggeredInAnyState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyNameTriggeredInAnyState(class FName NotifyName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyNameTriggeredInAnyState");

	Params::AnimInstance_WasAnimNotifyNameTriggeredInAnyState Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.WasAnimNotifyNameTriggeredInSourceState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyNameTriggeredInSourceState(int32 MachineIndex, int32 StateIndex, class FName NotifyName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyNameTriggeredInSourceState");

	Params::AnimInstance_WasAnimNotifyNameTriggeredInSourceState Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;
	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.WasAnimNotifyNameTriggeredInStateMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyNameTriggeredInStateMachine(int32 MachineIndex, class FName NotifyName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyNameTriggeredInStateMachine");

	Params::AnimInstance_WasAnimNotifyNameTriggeredInStateMachine Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.WasAnimNotifyStateActiveInAnyState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UAnimNotifyState>     AnimNotifyStateType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyStateActiveInAnyState(TSubclassOf<class UAnimNotifyState> AnimNotifyStateType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyStateActiveInAnyState");

	Params::AnimInstance_WasAnimNotifyStateActiveInAnyState Parms{};

	Parms.AnimNotifyStateType = AnimNotifyStateType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.WasAnimNotifyStateActiveInSourceState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotifyState>     AnimNotifyStateType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyStateActiveInSourceState(int32 MachineIndex, int32 StateIndex, TSubclassOf<class UAnimNotifyState> AnimNotifyStateType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyStateActiveInSourceState");

	Params::AnimInstance_WasAnimNotifyStateActiveInSourceState Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;
	Parms.AnimNotifyStateType = AnimNotifyStateType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.WasAnimNotifyStateActiveInStateMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotifyState>     AnimNotifyStateType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyStateActiveInStateMachine(int32 MachineIndex, TSubclassOf<class UAnimNotifyState> AnimNotifyStateType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyStateActiveInStateMachine");

	Params::AnimInstance_WasAnimNotifyStateActiveInStateMachine Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.AnimNotifyStateType = AnimNotifyStateType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.WasAnimNotifyTriggeredInAnyState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UAnimNotify>          AnimNotifyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyTriggeredInAnyState(TSubclassOf<class UAnimNotify> AnimNotifyType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyTriggeredInAnyState");

	Params::AnimInstance_WasAnimNotifyTriggeredInAnyState Parms{};

	Parms.AnimNotifyType = AnimNotifyType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.WasAnimNotifyTriggeredInSourceState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StateIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotify>          AnimNotifyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyTriggeredInSourceState(int32 MachineIndex, int32 StateIndex, TSubclassOf<class UAnimNotify> AnimNotifyType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyTriggeredInSourceState");

	Params::AnimInstance_WasAnimNotifyTriggeredInSourceState Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.StateIndex = StateIndex;
	Parms.AnimNotifyType = AnimNotifyType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.WasAnimNotifyTriggeredInStateMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotify>          AnimNotifyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::WasAnimNotifyTriggeredInStateMachine(int32 MachineIndex, TSubclassOf<class UAnimNotify> AnimNotifyType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasAnimNotifyTriggeredInStateMachine");

	Params::AnimInstance_WasAnimNotifyTriggeredInStateMachine Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.AnimNotifyType = AnimNotifyType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.CalculateDirection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Velocity                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         BaseRotation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::CalculateDirection(const struct FVector& Velocity, const struct FRotator& BaseRotation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CalculateDirection");

	Params::AnimInstance_CalculateDirection Parms{};

	Parms.Velocity = std::move(Velocity);
	Parms.BaseRotation = std::move(BaseRotation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetActiveCurveNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimCurveType                          CurveType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstance::GetActiveCurveNames(EAnimCurveType CurveType, TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveCurveNames");

	Params::AnimInstance_GetActiveCurveNames Parms{};

	Parms.CurveType = CurveType;

	UObject::ProcessEvent(Func, &Parms);

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function Engine.AnimInstance.GetAllCurveNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstance::GetAllCurveNames(TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllCurveNames");

	Params::AnimInstance_GetAllCurveNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function Engine.AnimInstance.GetCurrentActiveMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UAnimInstance::GetCurrentActiveMontage() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentActiveMontage");

	Params::AnimInstance_GetCurrentActiveMontage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetCurveValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetCurveValue(class FName CurveName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurveValue");

	Params::AnimInstance_GetCurveValue Parms{};

	Parms.CurveName = CurveName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetDeltaSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::GetDeltaSeconds() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDeltaSeconds");

	Params::AnimInstance_GetDeltaSeconds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetLinkedAnimGraphInstanceByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InTag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UAnimInstance::GetLinkedAnimGraphInstanceByTag(class FName InTag) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimGraphInstanceByTag");

	Params::AnimInstance_GetLinkedAnimGraphInstanceByTag Parms{};

	Parms.InTag = InTag;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetLinkedAnimGraphInstancesByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InTag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimInstance*>            OutLinkedInstances                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstance::GetLinkedAnimGraphInstancesByTag(class FName InTag, TArray<class UAnimInstance*>* OutLinkedInstances) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimGraphInstancesByTag");

	Params::AnimInstance_GetLinkedAnimGraphInstancesByTag Parms{};

	Parms.InTag = InTag;

	UObject::ProcessEvent(Func, &Parms);

	if (OutLinkedInstances != nullptr)
		*OutLinkedInstances = std::move(Parms.OutLinkedInstances);
}


// Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UAnimInstance::GetLinkedAnimLayerInstanceByClass(TSubclassOf<class UAnimInstance> InClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimLayerInstanceByClass");

	Params::AnimInstance_GetLinkedAnimLayerInstanceByClass Parms{};

	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UAnimInstance::GetLinkedAnimLayerInstanceByGroup(class FName InGroup) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimLayerInstanceByGroup");

	Params::AnimInstance_GetLinkedAnimLayerInstanceByGroup Parms{};

	Parms.InGroup = InGroup;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByGroupAndClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UAnimInstance::GetLinkedAnimLayerInstanceByGroupAndClass(class FName InGroup, TSubclassOf<class UAnimInstance> InClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimLayerInstanceByGroupAndClass");

	Params::AnimInstance_GetLinkedAnimLayerInstanceByGroupAndClass Parms{};

	Parms.InGroup = InGroup;
	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetLinkedAnimLayerInstancesByGroup
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimInstance*>            OutLinkedInstances                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimInstance::GetLinkedAnimLayerInstancesByGroup(class FName InGroup, TArray<class UAnimInstance*>* OutLinkedInstances) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimLayerInstancesByGroup");

	Params::AnimInstance_GetLinkedAnimLayerInstancesByGroup Parms{};

	Parms.InGroup = InGroup;

	UObject::ProcessEvent(Func, &Parms);

	if (OutLinkedInstances != nullptr)
		*OutLinkedInstances = std::move(Parms.OutLinkedInstances);
}


// Function Engine.AnimInstance.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAnimInstance::GetOwningActor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningActor");

	Params::AnimInstance_GetOwningActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetOwningComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UAnimInstance::GetOwningComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningComponent");

	Params::AnimInstance_GetOwningComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetPropagateNotifiesToLinkedInstances
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::GetPropagateNotifiesToLinkedInstances() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPropagateNotifiesToLinkedInstances");

	Params::AnimInstance_GetPropagateNotifiesToLinkedInstances Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetReceiveNotifiesFromLinkedInstances
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::GetReceiveNotifiesFromLinkedInstances() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetReceiveNotifiesFromLinkedInstances");

	Params::AnimInstance_GetReceiveNotifiesFromLinkedInstances Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetSyncGroupPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSyncGroupName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMarkerSyncAnimPosition          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMarkerSyncAnimPosition UAnimInstance::GetSyncGroupPosition(class FName InSyncGroupName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSyncGroupPosition");

	Params::AnimInstance_GetSyncGroupPosition Parms{};

	Parms.InSyncGroupName = InSyncGroupName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.GetTimeToClosestMarker
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SyncGroup                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MarkerName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutMarkerTime                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::GetTimeToClosestMarker(class FName SyncGroup, class FName MarkerName, float* OutMarkerTime) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTimeToClosestMarker");

	Params::AnimInstance_GetTimeToClosestMarker Parms{};

	Parms.SyncGroup = SyncGroup;
	Parms.MarkerName = MarkerName;

	UObject::ProcessEvent(Func, &Parms);

	if (OutMarkerTime != nullptr)
		*OutMarkerTime = Parms.OutMarkerTime;

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.HasMarkerBeenHitThisFrame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SyncGroup                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MarkerName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::HasMarkerBeenHitThisFrame(class FName SyncGroup, class FName MarkerName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasMarkerBeenHitThisFrame");

	Params::AnimInstance_HasMarkerBeenHitThisFrame Parms{};

	Parms.SyncGroup = SyncGroup;
	Parms.MarkerName = MarkerName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.IsAnyMontagePlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::IsAnyMontagePlaying() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsAnyMontagePlaying");

	Params::AnimInstance_IsAnyMontagePlaying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.IsPlayingSlotAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*                Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::IsPlayingSlotAnimation(const class UAnimSequenceBase* Asset, class FName SlotNodeName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlayingSlotAnimation");

	Params::AnimInstance_IsPlayingSlotAnimation Parms{};

	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.IsSyncGroupBetweenMarkers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSyncGroupName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PreviousMarker                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NextMarker                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRespectMarkerOrder                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::IsSyncGroupBetweenMarkers(class FName InSyncGroupName, class FName PreviousMarker, class FName NextMarker, bool bRespectMarkerOrder) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSyncGroupBetweenMarkers");

	Params::AnimInstance_IsSyncGroupBetweenMarkers Parms{};

	Parms.InSyncGroupName = InSyncGroupName;
	Parms.PreviousMarker = PreviousMarker;
	Parms.NextMarker = NextMarker;
	Parms.bRespectMarkerOrder = bRespectMarkerOrder;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.IsUsingMainInstanceMontageEvaluationData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::IsUsingMainInstanceMontageEvaluationData() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsUsingMainInstanceMontageEvaluationData");

	Params::AnimInstance_IsUsingMainInstanceMontageEvaluationData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetBlendTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_GetBlendTime(const class UAnimMontage* Montage) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_GetBlendTime");

	Params::AnimInstance_Montage_GetBlendTime Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetCurrentSection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAnimInstance::Montage_GetCurrentSection(const class UAnimMontage* Montage) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_GetCurrentSection");

	Params::AnimInstance_Montage_GetCurrentSection Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetIsStopped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::Montage_GetIsStopped(const class UAnimMontage* Montage) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_GetIsStopped");

	Params::AnimInstance_Montage_GetIsStopped Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_GetPlayRate(const class UAnimMontage* Montage) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_GetPlayRate");

	Params::AnimInstance_Montage_GetPlayRate Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimInstance::Montage_GetPosition(const class UAnimMontage* Montage) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_GetPosition");

	Params::AnimInstance_Montage_GetPosition Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::Montage_IsActive(const class UAnimMontage* Montage) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_IsActive");

	Params::AnimInstance_Montage_IsActive Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.Montage_IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimInstance::Montage_IsPlaying(const class UAnimMontage* Montage) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Montage_IsPlaying");

	Params::AnimInstance_Montage_IsPlaying Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimInstance.TryGetPawnOwner
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UAnimInstance::TryGetPawnOwner() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TryGetPawnOwner");

	Params::AnimInstance_TryGetPawnOwner Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LightComponentBase.SetAffectGlobalIllumination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetAffectGlobalIllumination(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAffectGlobalIllumination");

	Params::LightComponentBase_SetAffectGlobalIllumination Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponentBase.SetAffectReflection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetAffectReflection(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAffectReflection");

	Params::LightComponentBase_SetAffectReflection Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponentBase.SetCastDeepShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetCastDeepShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastDeepShadow");

	Params::LightComponentBase_SetCastDeepShadow Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponentBase.SetCastRaytracedShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetCastRaytracedShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastRaytracedShadow");

	Params::LightComponentBase_SetCastRaytracedShadow Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponentBase.SetCastRaytracedShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECastRayTracedShadow                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetCastRaytracedShadows(ECastRayTracedShadow bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastRaytracedShadows");

	Params::LightComponentBase_SetCastRaytracedShadows Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponentBase.SetCastShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetCastShadows(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastShadows");

	Params::LightComponentBase_SetCastShadows Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponentBase.SetCastVolumetricShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetCastVolumetricShadow(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastVolumetricShadow");

	Params::LightComponentBase_SetCastVolumetricShadow Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponentBase.SetSamplesPerPixel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponentBase::SetSamplesPerPixel(int32 NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSamplesPerPixel");

	Params::LightComponentBase_SetSamplesPerPixel Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponentBase.GetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ULightComponentBase::GetLightColor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLightColor");

	Params::LightComponentBase_GetLightColor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LightComponent.SetAffectDynamicIndirectLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetAffectDynamicIndirectLighting(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAffectDynamicIndirectLighting");

	Params::LightComponent_SetAffectDynamicIndirectLighting Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetAffectTranslucentLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetAffectTranslucentLighting(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAffectTranslucentLighting");

	Params::LightComponent_SetAffectTranslucentLighting Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetBloomMaxBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetBloomMaxBrightness(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBloomMaxBrightness");

	Params::LightComponent_SetBloomMaxBrightness Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetBloomScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetBloomScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBloomScale");

	Params::LightComponent_SetBloomScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetBloomThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetBloomThreshold(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBloomThreshold");

	Params::LightComponent_SetBloomThreshold Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetBloomTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                           NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetBloomTint(const struct FColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBloomTint");

	Params::LightComponent_SetBloomTint Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetEnableLightShaftBloom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetEnableLightShaftBloom(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnableLightShaftBloom");

	Params::LightComponent_SetEnableLightShaftBloom Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetForceCachedShadowsForMovablePrimitives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetForceCachedShadowsForMovablePrimitives(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForceCachedShadowsForMovablePrimitives");

	Params::LightComponent_SetForceCachedShadowsForMovablePrimitives Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetIESBrightnessScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetIESBrightnessScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIESBrightnessScale");

	Params::LightComponent_SetIESBrightnessScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetIESTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureLightProfile*             NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetIESTexture(class UTextureLightProfile* NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIESTexture");

	Params::LightComponent_SetIESTexture Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetIndirectLightingIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetIndirectLightingIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIndirectLightingIntensity");

	Params::LightComponent_SetIndirectLightingIntensity Parms{};

	Parms.NewIntensity = NewIntensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIntensity");

	Params::LightComponent_SetIntensity Parms{};

	Parms.NewIntensity = NewIntensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewLightColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSRGB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightColor(const struct FLinearColor& NewLightColor, bool bSRGB)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightColor");

	Params::LightComponent_SetLightColor Parms{};

	Parms.NewLightColor = std::move(NewLightColor);
	Parms.bSRGB = bSRGB;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetLightFunctionDisabledBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightFunctionDisabledBrightness(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFunctionDisabledBrightness");

	Params::LightComponent_SetLightFunctionDisabledBrightness Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetLightFunctionFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLightFunctionFadeDistance                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFunctionFadeDistance");

	Params::LightComponent_SetLightFunctionFadeDistance Parms{};

	Parms.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetLightFunctionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               NewLightFunctionMaterial                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFunctionMaterial");

	Params::LightComponent_SetLightFunctionMaterial Parms{};

	Parms.NewLightFunctionMaterial = NewLightFunctionMaterial;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetLightFunctionScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLightFunctionScale                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFunctionScale");

	Params::LightComponent_SetLightFunctionScale Parms{};

	Parms.NewLightFunctionScale = std::move(NewLightFunctionScale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetLightingChannels
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bChannel0                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChannel1                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChannel2                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightingChannels");

	Params::LightComponent_SetLightingChannels Parms{};

	Parms.bChannel0 = bChannel0;
	Parms.bChannel1 = bChannel1;
	Parms.bChannel2 = bChannel2;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetShadowBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetShadowBias(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowBias");

	Params::LightComponent_SetShadowBias Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetShadowSlopeBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetShadowSlopeBias(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowSlopeBias");

	Params::LightComponent_SetShadowSlopeBias Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetSpecularScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetSpecularScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSpecularScale");

	Params::LightComponent_SetSpecularScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetTemperature
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTemperature                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetTemperature(float NewTemperature)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTemperature");

	Params::LightComponent_SetTemperature Parms{};

	Parms.NewTemperature = NewTemperature;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetTransmission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetTransmission(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTransmission");

	Params::LightComponent_SetTransmission Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetUseIESBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetUseIESBrightness(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUseIESBrightness");

	Params::LightComponent_SetUseIESBrightness Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetUseTemperature
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetUseTemperature(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUseTemperature");

	Params::LightComponent_SetUseTemperature Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LightComponent.SetVolumetricScatteringIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightComponent::SetVolumetricScatteringIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumetricScatteringIntensity");

	Params::LightComponent_SetVolumetricScatteringIntensity Parms{};

	Parms.NewIntensity = NewIntensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LocalLightComponent.GetUnitsConversionFactor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ELightUnits                             SrcUnits                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELightUnits                             TargetUnits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CosHalfConeAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULocalLightComponent::GetUnitsConversionFactor(ELightUnits SrcUnits, ELightUnits TargetUnits, float CosHalfConeAngle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetUnitsConversionFactor");

	Params::LocalLightComponent_GetUnitsConversionFactor Parms{};

	Parms.SrcUnits = SrcUnits;
	Parms.TargetUnits = TargetUnits;
	Parms.CosHalfConeAngle = CosHalfConeAngle;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LocalLightComponent.SetAttenuationRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalLightComponent::SetAttenuationRadius(float NewRadius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAttenuationRadius");

	Params::LocalLightComponent_SetAttenuationRadius Parms{};

	Parms.NewRadius = NewRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LocalLightComponent.SetIntensityUnits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELightUnits                             NewIntensityUnits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalLightComponent::SetIntensityUnits(ELightUnits NewIntensityUnits)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIntensityUnits");

	Params::LocalLightComponent_SetIntensityUnits Parms{};

	Parms.NewIntensityUnits = NewIntensityUnits;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimDataModel.GetAnimationSequence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequence*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequence* UAnimDataModel::GetAnimationSequence() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnimationSequence");

	Params::AnimDataModel_GetAnimationSequence Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetBoneAnimationTracks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FBoneAnimationTrack>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FBoneAnimationTrack> UAnimDataModel::GetBoneAnimationTracks() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneAnimationTracks");

	Params::AnimDataModel_GetBoneAnimationTracks Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetBoneTrackByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TrackIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBoneAnimationTrack        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBoneAnimationTrack UAnimDataModel::GetBoneTrackByIndex(int32 TrackIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneTrackByIndex");

	Params::AnimDataModel_GetBoneTrackByIndex Parms{};

	Parms.TrackIndex = TrackIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetBoneTrackByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrackName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBoneAnimationTrack        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBoneAnimationTrack UAnimDataModel::GetBoneTrackByName(class FName TrackName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneTrackByName");

	Params::AnimDataModel_GetBoneTrackByName Parms{};

	Parms.TrackName = TrackName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetBoneTrackIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoneAnimationTrack              Track                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimDataModel::GetBoneTrackIndex(const struct FBoneAnimationTrack& Track) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneTrackIndex");

	Params::AnimDataModel_GetBoneTrackIndex Parms{};

	Parms.Track = std::move(Track);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetBoneTrackIndexByName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TrackName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimDataModel::GetBoneTrackIndexByName(class FName TrackName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneTrackIndexByName");

	Params::AnimDataModel_GetBoneTrackIndexByName Parms{};

	Parms.TrackName = TrackName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetBoneTrackNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAnimDataModel::GetBoneTrackNames(TArray<class FName>* OutNames) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneTrackNames");

	Params::AnimDataModel_GetBoneTrackNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function Engine.AnimDataModel.GetFrameRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FFrameRate                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FFrameRate UAnimDataModel::GetFrameRate() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFrameRate");

	Params::AnimDataModel_GetFrameRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetNumberOfFloatCurves
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimDataModel::GetNumberOfFloatCurves() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumberOfFloatCurves");

	Params::AnimDataModel_GetNumberOfFloatCurves Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetNumberOfFrames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimDataModel::GetNumberOfFrames() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumberOfFrames");

	Params::AnimDataModel_GetNumberOfFrames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetNumberOfKeys
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimDataModel::GetNumberOfKeys() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumberOfKeys");

	Params::AnimDataModel_GetNumberOfKeys Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetNumberOfTransformCurves
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAnimDataModel::GetNumberOfTransformCurves() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumberOfTransformCurves");

	Params::AnimDataModel_GetNumberOfTransformCurves Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetNumBoneTracks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UAnimDataModel::GetNumBoneTracks() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumBoneTracks");

	Params::AnimDataModel_GetNumBoneTracks Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.GetPlayLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimDataModel::GetPlayLength() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayLength");

	Params::AnimDataModel_GetPlayLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimDataModel.IsValidBoneTrackIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   TrackIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimDataModel::IsValidBoneTrackIndex(int32 TrackIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsValidBoneTrackIndex");

	Params::AnimDataModel_IsValidBoneTrackIndex Parms{};

	Parms.TrackIndex = TrackIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CheatManager.BugIt
// (Exec, Native, Public)
// Parameters:
// class FString                           ScreenShotDescription                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::BugIt(const class FString& ScreenShotDescription)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BugIt");

	Params::CheatManager_BugIt Parms{};

	Parms.ScreenShotDescription = std::move(ScreenShotDescription);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.BugItGo
// (Exec, Native, Public)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BugItGo");

	Params::CheatManager_BugItGo Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.BugItStringCreator
// (Exec, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          ViewLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ViewRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           GoString                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LocString                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::BugItStringCreator(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, class FString* GoString, class FString* LocString)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BugItStringCreator");

	Params::CheatManager_BugItStringCreator Parms{};

	Parms.ViewLocation = std::move(ViewLocation);
	Parms.ViewRotation = std::move(ViewRotation);

	UObject::ProcessEvent(Func, &Parms);

	if (GoString != nullptr)
		*GoString = std::move(Parms.GoString);

	if (LocString != nullptr)
		*LocString = std::move(Parms.LocString);
}


// Function Engine.CheatManager.ChangeSize
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   F                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::ChangeSize(float F)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChangeSize");

	Params::CheatManager_ChangeSize Parms{};

	Parms.F = F;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.CheatScript
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ScriptName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::CheatScript(const class FString& ScriptName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CheatScript");

	Params::CheatManager_CheatScript Parms{};

	Parms.ScriptName = std::move(ScriptName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.DamageTarget
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DamageTarget(float DamageAmount)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DamageTarget");

	Params::CheatManager_DamageTarget Parms{};

	Parms.DamageAmount = DamageAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.DebugCapsuleSweep
// (Exec, Native, Public)

void UCheatManager::DebugCapsuleSweep()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugCapsuleSweep");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DebugCapsuleSweepCapture
// (Exec, Native, Public)

void UCheatManager::DebugCapsuleSweepCapture()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugCapsuleSweepCapture");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DebugCapsuleSweepChannel
// (Exec, Native, Public)
// Parameters:
// ECollisionChannel                       Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DebugCapsuleSweepChannel(ECollisionChannel Channel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugCapsuleSweepChannel");

	Params::CheatManager_DebugCapsuleSweepChannel Parms{};

	Parms.Channel = Channel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.DebugCapsuleSweepClear
// (Exec, Native, Public)

void UCheatManager::DebugCapsuleSweepClear()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugCapsuleSweepClear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DebugCapsuleSweepComplex
// (Exec, Native, Public)
// Parameters:
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DebugCapsuleSweepComplex(bool bTraceComplex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugCapsuleSweepComplex");

	Params::CheatManager_DebugCapsuleSweepComplex Parms{};

	Parms.bTraceComplex = bTraceComplex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.DebugCapsuleSweepPawn
// (Exec, Native, Public)

void UCheatManager::DebugCapsuleSweepPawn()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugCapsuleSweepPawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DebugCapsuleSweepSize
// (Exec, Native, Public)
// Parameters:
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DebugCapsuleSweepSize(float HalfHeight, float Radius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DebugCapsuleSweepSize");

	Params::CheatManager_DebugCapsuleSweepSize Parms{};

	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.DestroyAll
// (Exec, Native, Public)
// Parameters:
// TSubclassOf<class AActor>               aClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DestroyAll(TSubclassOf<class AActor> aClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DestroyAll");

	Params::CheatManager_DestroyAll Parms{};

	Parms.aClass = aClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.DestroyAllPawnsExceptTarget
// (Exec, Native, Public)

void UCheatManager::DestroyAllPawnsExceptTarget()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DestroyAllPawnsExceptTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DestroyPawns
// (Exec, Native, Public)
// Parameters:
// TSubclassOf<class APawn>                aClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::DestroyPawns(TSubclassOf<class APawn> aClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DestroyPawns");

	Params::CheatManager_DestroyPawns Parms{};

	Parms.aClass = aClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.DestroyServerStatReplicator
// (Final, Exec, Native, Public)

void UCheatManager::DestroyServerStatReplicator()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DestroyServerStatReplicator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DestroyTarget
// (Exec, Native, Public, BlueprintCallable)

void UCheatManager::DestroyTarget()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DestroyTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DisableDebugCamera
// (Native, Protected, BlueprintCallable)

void UCheatManager::DisableDebugCamera()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableDebugCamera");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DumpChatState
// (Exec, Native, Public)

void UCheatManager::DumpChatState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DumpChatState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DumpOnlineSessionState
// (Exec, Native, Public)

void UCheatManager::DumpOnlineSessionState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DumpOnlineSessionState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DumpPartyState
// (Exec, Native, Public)

void UCheatManager::DumpPartyState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DumpPartyState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.DumpVoiceMutingState
// (Exec, Native, Public)

void UCheatManager::DumpVoiceMutingState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DumpVoiceMutingState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.EnableDebugCamera
// (Native, Protected, BlueprintCallable)

void UCheatManager::EnableDebugCamera()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableDebugCamera");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.FlushLog
// (Exec, Native, Public)

void UCheatManager::FlushLog()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FlushLog");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.Fly
// (Exec, Native, Public, BlueprintCallable)

void UCheatManager::Fly()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Fly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.FreezeFrame
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::FreezeFrame(float Delay)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FreezeFrame");

	Params::CheatManager_FreezeFrame Parms{};

	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.Ghost
// (Exec, Native, Public, BlueprintCallable)

void UCheatManager::Ghost()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Ghost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.God
// (Exec, Native, Public, BlueprintCallable)

void UCheatManager::God()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("God");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.InvertMouse
// (Exec, Native, Public)

void UCheatManager::InvertMouse()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InvertMouse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.LogLoc
// (Exec, Native, Public)

void UCheatManager::LogLoc()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LogLoc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.OnlyLoadLevel
// (Exec, Native, Public)
// Parameters:
// class FName                             PackageName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::OnlyLoadLevel(class FName PackageName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnlyLoadLevel");

	Params::CheatManager_OnlyLoadLevel Parms{};

	Parms.PackageName = PackageName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.PlayersOnly
// (Exec, Native, Public, BlueprintCallable)

void UCheatManager::PlayersOnly()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayersOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.ReceiveEndPlay
// (Event, Public, BlueprintEvent)

void UCheatManager::ReceiveEndPlay()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveEndPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.ReceiveInitCheatManager
// (Event, Public, BlueprintEvent)

void UCheatManager::ReceiveInitCheatManager()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveInitCheatManager");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.ServerToggleAILogging
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatManager::ServerToggleAILogging()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerToggleAILogging");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.SetMouseSensitivityToDefault
// (Exec, Native, Public)

void UCheatManager::SetMouseSensitivityToDefault()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMouseSensitivityToDefault");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.SetWorldOrigin
// (Final, Exec, Native, Public)

void UCheatManager::SetWorldOrigin()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWorldOrigin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.Slomo
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTimeDilation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::Slomo(float NewTimeDilation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Slomo");

	Params::CheatManager_Slomo Parms{};

	Parms.NewTimeDilation = NewTimeDilation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.SpawnServerStatReplicator
// (Final, Exec, Native, Public)

void UCheatManager::SpawnServerStatReplicator()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SpawnServerStatReplicator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.StreamLevelIn
// (Exec, Native, Public)
// Parameters:
// class FName                             PackageName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::StreamLevelIn(class FName PackageName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StreamLevelIn");

	Params::CheatManager_StreamLevelIn Parms{};

	Parms.PackageName = PackageName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.StreamLevelOut
// (Exec, Native, Public)
// Parameters:
// class FName                             PackageName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::StreamLevelOut(class FName PackageName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StreamLevelOut");

	Params::CheatManager_StreamLevelOut Parms{};

	Parms.PackageName = PackageName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.Summon
// (Exec, Native, Public)
// Parameters:
// class FString                           ClassName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::Summon(const class FString& ClassName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Summon");

	Params::CheatManager_Summon Parms{};

	Parms.ClassName = std::move(ClassName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.Teleport
// (Exec, Native, Public, BlueprintCallable)

void UCheatManager::Teleport()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Teleport");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.TestCollisionDistance
// (Exec, Native, Public)

void UCheatManager::TestCollisionDistance()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TestCollisionDistance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.ToggleAILogging
// (Exec, Native, Public)

void UCheatManager::ToggleAILogging()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleAILogging");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.ToggleDebugCamera
// (Exec, Native, Public)

void UCheatManager::ToggleDebugCamera()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleDebugCamera");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.ToggleServerStatReplicatorClientOverwrite
// (Final, Exec, Native, Public)

void UCheatManager::ToggleServerStatReplicatorClientOverwrite()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleServerStatReplicatorClientOverwrite");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.ToggleServerStatReplicatorUpdateStatNet
// (Final, Exec, Native, Public)

void UCheatManager::ToggleServerStatReplicatorUpdateStatNet()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleServerStatReplicatorUpdateStatNet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.UpdateSafeArea
// (Final, Exec, Native, Public)

void UCheatManager::UpdateSafeArea()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateSafeArea");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.ViewActor
// (Exec, Native, Public)
// Parameters:
// class FName                             ActorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::ViewActor(class FName ActorName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ViewActor");

	Params::CheatManager_ViewActor Parms{};

	Parms.ActorName = ActorName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.ViewClass
// (Exec, Native, Public)
// Parameters:
// TSubclassOf<class AActor>               DesiredClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::ViewClass(TSubclassOf<class AActor> DesiredClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ViewClass");

	Params::CheatManager_ViewClass Parms{};

	Parms.DesiredClass = DesiredClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.ViewPlayer
// (Exec, Native, Public)
// Parameters:
// class FString                           S                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatManager::ViewPlayer(const class FString& S)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ViewPlayer");

	Params::CheatManager_ViewPlayer Parms{};

	Parms.S = std::move(S);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CheatManager.ViewSelf
// (Exec, Native, Public)

void UCheatManager::ViewSelf()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ViewSelf");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.Walk
// (Exec, Native, Public, BlueprintCallable)

void UCheatManager::Walk()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Walk");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CheatManager.GetPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UCheatManager::GetPlayerController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayerController");

	Params::CheatManager_GetPlayerController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InBoneName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AddPhysicsBlendWeight                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipCustomPhysicsType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::AccumulateAllBodiesBelowPhysicsBlendWeight(const class FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AccumulateAllBodiesBelowPhysicsBlendWeight");

	Params::SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight Parms{};

	Parms.InBoneName = InBoneName;
	Parms.AddPhysicsBlendWeight = AddPhysicsBlendWeight;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.AddForceToAllBodiesBelow
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAccelChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::AddForceToAllBodiesBelow(const struct FVector& Force, class FName BoneName, bool bAccelChange, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddForceToAllBodiesBelow");

	Params::SkeletalMeshComponent_AddForceToAllBodiesBelow Parms{};

	Parms.Force = std::move(Force);
	Parms.BoneName = BoneName;
	Parms.bAccelChange = bAccelChange;
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.AddImpulseToAllBodiesBelow
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::AddImpulseToAllBodiesBelow(const struct FVector& Impulse, class FName BoneName, bool bVelChange, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddImpulseToAllBodiesBelow");

	Params::SkeletalMeshComponent_AddImpulseToAllBodiesBelow Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.BoneName = BoneName;
	Parms.bVelChange = bVelChange;
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.AllowAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NameOfCurve                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::AllowAnimCurveEvaluation(class FName NameOfCurve, bool bAllow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AllowAnimCurveEvaluation");

	Params::SkeletalMeshComponent_AllowAnimCurveEvaluation Parms{};

	Parms.NameOfCurve = NameOfCurve;
	Parms.bAllow = bAllow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.BindClothToMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::BindClothToMasterPoseComponent()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BindClothToMasterPoseComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.BreakConstraint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, class FName InBoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BreakConstraint");

	Params::SkeletalMeshComponent_BreakConstraint Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.HitLocation = std::move(HitLocation);
	Parms.InBoneName = InBoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.ClearMorphTargets
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::ClearMorphTargets()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearMorphTargets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.FindConstraintBoneName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConstraintIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USkeletalMeshComponent::FindConstraintBoneName(int32 ConstraintIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindConstraintBoneName");

	Params::SkeletalMeshComponent_FindConstraintBoneName Parms{};

	Parms.ConstraintIndex = ConstraintIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::ForceClothNextUpdateTeleport()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceClothNextUpdateTeleport");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::ForceClothNextUpdateTeleportAndReset()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceClothNextUpdateTeleportAndReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.GetAnimClass
// (Final, Native, Public)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* USkeletalMeshComponent::GetAnimClass()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnimClass");

	Params::SkeletalMeshComponent_GetAnimClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetBoneLinearVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InBoneName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USkeletalMeshComponent::GetBoneLinearVelocity(const class FName& InBoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneLinearVelocity");

	Params::SkeletalMeshComponent_GetBoneLinearVelocity Parms{};

	Parms.InBoneName = InBoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetConstraintByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ConstraintName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludesTerminated                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FConstraintInstanceAccessor      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FConstraintInstanceAccessor USkeletalMeshComponent::GetConstraintByName(class FName ConstraintName, bool bIncludesTerminated)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConstraintByName");

	Params::SkeletalMeshComponent_GetConstraintByName Parms{};

	Parms.ConstraintName = ConstraintName;
	Parms.bIncludesTerminated = bIncludesTerminated;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetConstraints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bIncludesTerminated                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FConstraintInstanceAccessor>OutConstraints                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::GetConstraints(bool bIncludesTerminated, TArray<struct FConstraintInstanceAccessor>* OutConstraints)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConstraints");

	Params::SkeletalMeshComponent_GetConstraints Parms{};

	Parms.bIncludesTerminated = bIncludesTerminated;

	UObject::ProcessEvent(Func, &Parms);

	if (OutConstraints != nullptr)
		*OutConstraints = std::move(Parms.OutConstraints);
}


// Function Engine.SkeletalMeshComponent.GetConstraintsFromBody
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bParentConstraints                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChildConstraints                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludesTerminated                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FConstraintInstanceAccessor>OutConstraints                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::GetConstraintsFromBody(class FName BodyName, bool bParentConstraints, bool bChildConstraints, bool bIncludesTerminated, TArray<struct FConstraintInstanceAccessor>* OutConstraints)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConstraintsFromBody");

	Params::SkeletalMeshComponent_GetConstraintsFromBody Parms{};

	Parms.BodyName = BodyName;
	Parms.bParentConstraints = bParentConstraints;
	Parms.bChildConstraints = bChildConstraints;
	Parms.bIncludesTerminated = bIncludesTerminated;

	UObject::ProcessEvent(Func, &Parms);

	if (OutConstraints != nullptr)
		*OutConstraints = std::move(Parms.OutConstraints);
}


// Function Engine.SkeletalMeshComponent.GetCurrentJointAngles
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing1Angle                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistAngle                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing2Angle                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::GetCurrentJointAngles(class FName InBoneName, float* Swing1Angle, float* TwistAngle, float* Swing2Angle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentJointAngles");

	Params::SkeletalMeshComponent_GetCurrentJointAngles Parms{};

	Parms.InBoneName = InBoneName;

	UObject::ProcessEvent(Func, &Parms);

	if (Swing1Angle != nullptr)
		*Swing1Angle = Parms.Swing1Angle;

	if (TwistAngle != nullptr)
		*TwistAngle = Parms.TwistAngle;

	if (Swing2Angle != nullptr)
		*Swing2Angle = Parms.Swing2Angle;
}


// Function Engine.SkeletalMeshComponent.GetFloatAttribute
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECustomBoneAttributeLookup              LookupType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetFloatAttribute(const class FName& BoneName, const class FName& AttributeName, float DefaultValue, float* OutValue, ECustomBoneAttributeLookup LookupType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFloatAttribute");

	Params::SkeletalMeshComponent_GetFloatAttribute Parms{};

	Parms.BoneName = BoneName;
	Parms.AttributeName = AttributeName;
	Parms.DefaultValue = DefaultValue;
	Parms.LookupType = LookupType;

	UObject::ProcessEvent(Func, &Parms);

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetFloatAttribute_Ref
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutValue                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECustomBoneAttributeLookup              LookupType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetFloatAttribute_Ref(const class FName& BoneName, const class FName& AttributeName, float& OutValue, ECustomBoneAttributeLookup LookupType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFloatAttribute_Ref");

	Params::SkeletalMeshComponent_GetFloatAttribute_Ref Parms{};

	Parms.BoneName = BoneName;
	Parms.AttributeName = AttributeName;
	Parms.OutValue = OutValue;
	Parms.LookupType = LookupType;

	UObject::ProcessEvent(Func, &Parms);

	OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetIntegerAttribute
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECustomBoneAttributeLookup              LookupType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetIntegerAttribute(const class FName& BoneName, const class FName& AttributeName, int32 DefaultValue, int32* OutValue, ECustomBoneAttributeLookup LookupType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIntegerAttribute");

	Params::SkeletalMeshComponent_GetIntegerAttribute Parms{};

	Parms.BoneName = BoneName;
	Parms.AttributeName = AttributeName;
	Parms.DefaultValue = DefaultValue;
	Parms.LookupType = LookupType;

	UObject::ProcessEvent(Func, &Parms);

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetIntegerAttribute_Ref
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutValue                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECustomBoneAttributeLookup              LookupType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetIntegerAttribute_Ref(const class FName& BoneName, const class FName& AttributeName, int32& OutValue, ECustomBoneAttributeLookup LookupType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIntegerAttribute_Ref");

	Params::SkeletalMeshComponent_GetIntegerAttribute_Ref Parms{};

	Parms.BoneName = BoneName;
	Parms.AttributeName = AttributeName;
	Parms.OutValue = OutValue;
	Parms.LookupType = LookupType;

	UObject::ProcessEvent(Func, &Parms);

	OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetStringAttribute
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DefaultValue                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutValue                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECustomBoneAttributeLookup              LookupType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetStringAttribute(const class FName& BoneName, const class FName& AttributeName, const class FString& DefaultValue, class FString* OutValue, ECustomBoneAttributeLookup LookupType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStringAttribute");

	Params::SkeletalMeshComponent_GetStringAttribute Parms{};

	Parms.BoneName = BoneName;
	Parms.AttributeName = AttributeName;
	Parms.DefaultValue = std::move(DefaultValue);
	Parms.LookupType = LookupType;

	UObject::ProcessEvent(Func, &Parms);

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetStringAttribute_Ref
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutValue                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECustomBoneAttributeLookup              LookupType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetStringAttribute_Ref(const class FName& BoneName, const class FName& AttributeName, class FString& OutValue, ECustomBoneAttributeLookup LookupType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStringAttribute_Ref");

	Params::SkeletalMeshComponent_GetStringAttribute_Ref Parms{};

	Parms.BoneName = BoneName;
	Parms.AttributeName = AttributeName;
	Parms.OutValue = std::move(OutValue);
	Parms.LookupType = LookupType;

	UObject::ProcessEvent(Func, &Parms);

	OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetTransformAttribute
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       DefaultValue                                           (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       OutValue                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ECustomBoneAttributeLookup              LookupType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetTransformAttribute(const class FName& BoneName, const class FName& AttributeName, const struct FTransform& DefaultValue, struct FTransform* OutValue, ECustomBoneAttributeLookup LookupType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransformAttribute");

	Params::SkeletalMeshComponent_GetTransformAttribute Parms{};

	Parms.BoneName = BoneName;
	Parms.AttributeName = AttributeName;
	Parms.DefaultValue = std::move(DefaultValue);
	Parms.LookupType = LookupType;

	UObject::ProcessEvent(Func, &Parms);

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetTransformAttribute_Ref
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttributeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutValue                                               (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ECustomBoneAttributeLookup              LookupType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetTransformAttribute_Ref(const class FName& BoneName, const class FName& AttributeName, struct FTransform& OutValue, ECustomBoneAttributeLookup LookupType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransformAttribute_Ref");

	Params::SkeletalMeshComponent_GetTransformAttribute_Ref Parms{};

	Parms.BoneName = BoneName;
	Parms.AttributeName = AttributeName;
	Parms.OutValue = std::move(OutValue);
	Parms.LookupType = LookupType;

	UObject::ProcessEvent(Func, &Parms);

	OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.IsBodyGravityEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::IsBodyGravityEnabled(class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsBodyGravityEnabled");

	Params::SkeletalMeshComponent_IsBodyGravityEnabled Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.LinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::LinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LinkAnimClassLayers");

	Params::SkeletalMeshComponent_LinkAnimClassLayers Parms{};

	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.LinkAnimGraphByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InTag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::LinkAnimGraphByTag(class FName InTag, TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LinkAnimGraphByTag");

	Params::SkeletalMeshComponent_LinkAnimGraphByTag Parms{};

	Parms.InTag = InTag;
	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.OverrideAnimationData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  InAnimToPlay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLooping                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPlaying                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::OverrideAnimationData(class UAnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OverrideAnimationData");

	Params::SkeletalMeshComponent_OverrideAnimationData Parms{};

	Parms.InAnimToPlay = InAnimToPlay;
	Parms.bIsLooping = bIsLooping;
	Parms.bIsPlaying = bIsPlaying;
	Parms.Position = Position;
	Parms.PlayRate = PlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::Play(bool bLooping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Play");

	Params::SkeletalMeshComponent_Play Parms{};

	Parms.bLooping = bLooping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.PlayAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  NewAnimToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::PlayAnimation(class UAnimationAsset* NewAnimToPlay, bool bLooping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayAnimation");

	Params::SkeletalMeshComponent_PlayAnimation Parms{};

	Parms.NewAnimToPlay = NewAnimToPlay;
	Parms.bLooping = bLooping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::ResetAllBodiesSimulatePhysics()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetAllBodiesSimulatePhysics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.ResetAllowedAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::ResetAllowedAnimCurveEvaluation()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetAllowedAnimCurveEvaluation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.ResetAnimInstanceDynamics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETeleportType                           InTeleportType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::ResetAnimInstanceDynamics(ETeleportType InTeleportType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetAnimInstanceDynamics");

	Params::SkeletalMeshComponent_ResetAnimInstanceDynamics Parms{};

	Parms.InTeleportType = InTeleportType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.ResetClothTeleportMode
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::ResetClothTeleportMode()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetClothTeleportMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.ResumeClothingSimulation
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::ResumeClothingSimulation()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResumeClothingSimulation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowLinearVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InBoneName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LinearVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesBelowLinearVelocity(const class FName& InBoneName, const struct FVector& LinearVelocity, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllBodiesBelowLinearVelocity");

	Params::SkeletalMeshComponent_SetAllBodiesBelowLinearVelocity Parms{};

	Parms.InBoneName = InBoneName;
	Parms.LinearVelocity = std::move(LinearVelocity);
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InBoneName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PhysicsBlendWeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipCustomPhysicsType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesBelowPhysicsBlendWeight(const class FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllBodiesBelowPhysicsBlendWeight");

	Params::SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight Parms{};

	Parms.InBoneName = InBoneName;
	Parms.PhysicsBlendWeight = PhysicsBlendWeight;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsDisabled
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InBoneName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesBelowPhysicsDisabled(const class FName& InBoneName, bool bDisabled, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllBodiesBelowPhysicsDisabled");

	Params::SkeletalMeshComponent_SetAllBodiesBelowPhysicsDisabled Parms{};

	Parms.InBoneName = InBoneName;
	Parms.bDisabled = bDisabled;
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InBoneName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewSimulate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesBelowSimulatePhysics(const class FName& InBoneName, bool bNewSimulate, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllBodiesBelowSimulatePhysics");

	Params::SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics Parms{};

	Parms.InBoneName = InBoneName;
	Parms.bNewSimulate = bNewSimulate;
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PhysicsBlendWeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipCustomPhysicsType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllBodiesPhysicsBlendWeight");

	Params::SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight Parms{};

	Parms.PhysicsBlendWeight = PhysicsBlendWeight;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewSimulate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllBodiesSimulatePhysics(bool bNewSimulate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllBodiesSimulatePhysics");

	Params::SkeletalMeshComponent_SetAllBodiesSimulatePhysics Parms{};

	Parms.bNewSimulate = bNewSimulate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSpring                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDamping                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForceLimit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipCustomPhysicsType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllMotorsAngularDriveParams");

	Params::SkeletalMeshComponent_SetAllMotorsAngularDriveParams Parms{};

	Parms.InSpring = InSpring;
	Parms.InDamping = InDamping;
	Parms.InForceLimit = InForceLimit;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableSwingDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableTwistDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipCustomPhysicsType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllMotorsAngularPositionDrive");

	Params::SkeletalMeshComponent_SetAllMotorsAngularPositionDrive Parms{};

	Parms.bEnableSwingDrive = bEnableSwingDrive;
	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableSwingDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableTwistDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipCustomPhysicsType                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllMotorsAngularVelocityDrive");

	Params::SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive Parms{};

	Parms.bEnableSwingDrive = bEnableSwingDrive;
	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllowAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllowAnimCurveEvaluation(bool bInAllow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllowAnimCurveEvaluation");

	Params::SkeletalMeshComponent_SetAllowAnimCurveEvaluation Parms{};

	Parms.bInAllow = bInAllow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllowClothActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllowClothActors(bool bInAllow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllowClothActors");

	Params::SkeletalMeshComponent_SetAllowClothActors Parms{};

	Parms.bInAllow = bInAllow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllowedAnimCurvesEvaluation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     List                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllowedAnimCurvesEvaluation(const TArray<class FName>& List, bool bAllow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllowedAnimCurvesEvaluation");

	Params::SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation Parms{};

	Parms.List = std::move(List);
	Parms.bAllow = bAllow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAllowRigidBodyAnimNode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReinitAnim                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAllowRigidBodyAnimNode(bool bInAllow, bool bReinitAnim)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAllowRigidBodyAnimNode");

	Params::SkeletalMeshComponent_SetAllowRigidBodyAnimNode Parms{};

	Parms.bInAllow = bInAllow;
	Parms.bReinitAnim = bReinitAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAngularLimits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing1LimitAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitAngle                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing2LimitAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAngularLimits(class FName InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularLimits");

	Params::SkeletalMeshComponent_SetAngularLimits Parms{};

	Parms.InBoneName = InBoneName;
	Parms.Swing1LimitAngle = Swing1LimitAngle;
	Parms.TwistLimitAngle = TwistLimitAngle;
	Parms.Swing2LimitAngle = Swing2LimitAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  NewAnimToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAnimation(class UAnimationAsset* NewAnimToPlay)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimation");

	Params::SkeletalMeshComponent_SetAnimation Parms{};

	Parms.NewAnimToPlay = NewAnimToPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAnimationMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimationMode                          InAnimationMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAnimationMode(EAnimationMode InAnimationMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimationMode");

	Params::SkeletalMeshComponent_SetAnimationMode Parms{};

	Parms.InAnimationMode = InAnimationMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetAnimClass
// (Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           NewClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetAnimClass(class UClass* NewClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimClass");

	Params::SkeletalMeshComponent_SetAnimClass Parms{};

	Parms.NewClass = NewClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetBodyNotifyRigidBodyCollision
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewNotifyRigidBodyCollision                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBodyNotifyRigidBodyCollision");

	Params::SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision Parms{};

	Parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetClothMaxDistanceScale(float Scale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetClothMaxDistanceScale");

	Params::SkeletalMeshComponent_SetClothMaxDistanceScale Parms{};

	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetConstraintProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             JointName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefaultIfNotFound                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetConstraintProfile(class FName JointName, class FName ProfileName, bool bDefaultIfNotFound)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConstraintProfile");

	Params::SkeletalMeshComponent_SetConstraintProfile Parms{};

	Parms.JointName = JointName;
	Parms.ProfileName = ProfileName;
	Parms.bDefaultIfNotFound = bDefaultIfNotFound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetConstraintProfileForAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefaultIfNotFound                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetConstraintProfileForAll(class FName ProfileName, bool bDefaultIfNotFound)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConstraintProfileForAll");

	Params::SkeletalMeshComponent_SetConstraintProfileForAll Parms{};

	Parms.ProfileName = ProfileName;
	Parms.bDefaultIfNotFound = bDefaultIfNotFound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetDisableAnimCurves
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInDisableAnimCurves                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetDisableAnimCurves(bool bInDisableAnimCurves)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDisableAnimCurves");

	Params::SkeletalMeshComponent_SetDisableAnimCurves Parms{};

	Parms.bInDisableAnimCurves = bInDisableAnimCurves;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInDisablePostProcess                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetDisablePostProcessBlueprint(bool bInDisablePostProcess)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDisablePostProcessBlueprint");

	Params::SkeletalMeshComponent_SetDisablePostProcessBlueprint Parms{};

	Parms.bInDisablePostProcess = bInDisablePostProcess;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetEnableBodyGravity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableGravity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetEnableBodyGravity(bool bEnableGravity, class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnableBodyGravity");

	Params::SkeletalMeshComponent_SetEnableBodyGravity Parms{};

	Parms.bEnableGravity = bEnableGravity;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetEnableGravityOnAllBodiesBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableGravity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, class FName BoneName, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnableGravityOnAllBodiesBelow");

	Params::SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow Parms{};

	Parms.bEnableGravity = bEnableGravity;
	Parms.BoneName = BoneName;
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewBlendPhysics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetEnablePhysicsBlending(bool bNewBlendPhysics)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnablePhysicsBlending");

	Params::SkeletalMeshComponent_SetEnablePhysicsBlending Parms{};

	Parms.bNewBlendPhysics = bNewBlendPhysics;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetMorphTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MorphTargetName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveZeroWeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetMorphTarget(class FName MorphTargetName, float Value, bool bRemoveZeroWeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMorphTarget");

	Params::SkeletalMeshComponent_SetMorphTarget Parms{};

	Parms.MorphTargetName = MorphTargetName;
	Parms.Value = Value;
	Parms.bRemoveZeroWeight = bRemoveZeroWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetNotifyRigidBodyCollisionBelow
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewNotifyRigidBodyCollision                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, class FName BoneName, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNotifyRigidBodyCollisionBelow");

	Params::SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow Parms{};

	Parms.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
	Parms.BoneName = BoneName;
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PhysicsBlendWeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetPhysicsBlendWeight(float PhysicsBlendWeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPhysicsBlendWeight");

	Params::SkeletalMeshComponent_SetPhysicsBlendWeight Parms{};

	Parms.PhysicsBlendWeight = PhysicsBlendWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetPlayRate(float Rate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlayRate");

	Params::SkeletalMeshComponent_SetPlayRate Parms{};

	Parms.Rate = Rate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPos                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireNotifies                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetPosition(float InPos, bool bFireNotifies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPosition");

	Params::SkeletalMeshComponent_SetPosition Parms{};

	Parms.InPos = InPos;
	Parms.bFireNotifies = bFireNotifies;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetTeleportDistanceThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetTeleportDistanceThreshold(float Threshold)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTeleportDistanceThreshold");

	Params::SkeletalMeshComponent_SetTeleportDistanceThreshold Parms{};

	Parms.Threshold = Threshold;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetTeleportRotationThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetTeleportRotationThreshold(float Threshold)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTeleportRotationThreshold");

	Params::SkeletalMeshComponent_SetTeleportRotationThreshold Parms{};

	Parms.Threshold = Threshold;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetUpdateAnimationInEditor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewUpdateState                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetUpdateAnimationInEditor(const bool NewUpdateState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUpdateAnimationInEditor");

	Params::SkeletalMeshComponent_SetUpdateAnimationInEditor Parms{};

	Parms.NewUpdateState = NewUpdateState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SetUpdateClothInEditor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewUpdateState                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SetUpdateClothInEditor(const bool NewUpdateState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUpdateClothInEditor");

	Params::SkeletalMeshComponent_SetUpdateClothInEditor Parms{};

	Parms.NewUpdateState = NewUpdateState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.SnapshotPose
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPoseSnapshot                    Snapshot                                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::SnapshotPose(struct FPoseSnapshot& Snapshot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SnapshotPose");

	Params::SkeletalMeshComponent_SnapshotPose Parms{};

	Parms.Snapshot = std::move(Snapshot);

	UObject::ProcessEvent(Func, &Parms);

	Snapshot = std::move(Parms.Snapshot);
}


// Function Engine.SkeletalMeshComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::Stop()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Stop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.SuspendClothingSimulation
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::SuspendClothingSimulation()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SuspendClothingSimulation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.TermBodiesBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParentBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::TermBodiesBelow(class FName ParentBoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TermBodiesBelow");

	Params::SkeletalMeshComponent_TermBodiesBelow Parms{};

	Parms.ParentBoneName = ParentBoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.ToggleDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable)

void USkeletalMeshComponent::ToggleDisablePostProcessBlueprint()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleDisablePostProcessBlueprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRestoreSimulationSpace                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::UnbindClothFromMasterPoseComponent(bool bRestoreSimulationSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnbindClothFromMasterPoseComponent");

	Params::SkeletalMeshComponent_UnbindClothFromMasterPoseComponent Parms{};

	Parms.bRestoreSimulationSpace = bRestoreSimulationSpace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.UnlinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::UnlinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnlinkAnimClassLayers");

	Params::SkeletalMeshComponent_UnlinkAnimClassLayers Parms{};

	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshComponent.GetAllowClothActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetAllowClothActors() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllowClothActors");

	Params::SkeletalMeshComponent_GetAllowClothActors Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAllowedAnimCurveEvaluate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetAllowedAnimCurveEvaluate() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllowedAnimCurveEvaluate");

	Params::SkeletalMeshComponent_GetAllowedAnimCurveEvaluate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAllowRigidBodyAnimNode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetAllowRigidBodyAnimNode() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAllowRigidBodyAnimNode");

	Params::SkeletalMeshComponent_GetAllowRigidBodyAnimNode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAnimationMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimationMode                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimationMode USkeletalMeshComponent::GetAnimationMode() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnimationMode");

	Params::SkeletalMeshComponent_GetAnimationMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetAnimInstance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnimInstance");

	Params::SkeletalMeshComponent_GetAnimInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetBoneMass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScaleMass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetBoneMass(class FName BoneName, bool bScaleMass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneMass");

	Params::SkeletalMeshComponent_GetBoneMass Parms{};

	Parms.BoneName = BoneName;
	Parms.bScaleMass = bScaleMass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothingSimulationInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClothingSimulationInteractor*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClothingSimulationInteractor* USkeletalMeshComponent::GetClothingSimulationInteractor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClothingSimulationInteractor");

	Params::SkeletalMeshComponent_GetClothingSimulationInteractor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetClothMaxDistanceScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClothMaxDistanceScale");

	Params::SkeletalMeshComponent_GetClothMaxDistanceScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetDisableAnimCurves
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetDisableAnimCurves() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDisableAnimCurves");

	Params::SkeletalMeshComponent_GetDisableAnimCurves Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::GetDisablePostProcessBlueprint() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDisablePostProcessBlueprint");

	Params::SkeletalMeshComponent_GetDisablePostProcessBlueprint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstanceByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InTag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetLinkedAnimGraphInstanceByTag(class FName InTag) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimGraphInstanceByTag");

	Params::SkeletalMeshComponent_GetLinkedAnimGraphInstanceByTag Parms{};

	Parms.InTag = InTag;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstancesByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InTag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimInstance*>            OutLinkedInstances                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USkeletalMeshComponent::GetLinkedAnimGraphInstancesByTag(class FName InTag, TArray<class UAnimInstance*>* OutLinkedInstances) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimGraphInstancesByTag");

	Params::SkeletalMeshComponent_GetLinkedAnimGraphInstancesByTag Parms{};

	Parms.InTag = InTag;

	UObject::ProcessEvent(Func, &Parms);

	if (OutLinkedInstances != nullptr)
		*OutLinkedInstances = std::move(Parms.OutLinkedInstances);
}


// Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimInstance>        InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetLinkedAnimLayerInstanceByClass(TSubclassOf<class UAnimInstance> InClass) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimLayerInstanceByClass");

	Params::SkeletalMeshComponent_GetLinkedAnimLayerInstanceByClass Parms{};

	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InGroup                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetLinkedAnimLayerInstanceByGroup(class FName InGroup) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinkedAnimLayerInstanceByGroup");

	Params::SkeletalMeshComponent_GetLinkedAnimLayerInstanceByGroup Parms{};

	Parms.InGroup = InGroup;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetMorphTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MorphTargetName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetMorphTarget(class FName MorphTargetName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMorphTarget");

	Params::SkeletalMeshComponent_GetMorphTarget Parms{};

	Parms.MorphTargetName = MorphTargetName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetPlayRate() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayRate");

	Params::SkeletalMeshComponent_GetPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPosition");

	Params::SkeletalMeshComponent_GetPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetPostProcessInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* USkeletalMeshComponent::GetPostProcessInstance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPostProcessInstance");

	Params::SkeletalMeshComponent_GetPostProcessInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetSkeletalCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USkeletalMeshComponent::GetSkeletalCenterOfMass() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSkeletalCenterOfMass");

	Params::SkeletalMeshComponent_GetSkeletalCenterOfMass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetTeleportDistanceThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetTeleportDistanceThreshold() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTeleportDistanceThreshold");

	Params::SkeletalMeshComponent_GetTeleportDistanceThreshold Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetTeleportRotationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USkeletalMeshComponent::GetTeleportRotationThreshold() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTeleportRotationThreshold");

	Params::SkeletalMeshComponent_GetTeleportRotationThreshold Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.HasValidAnimationInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::HasValidAnimationInstance() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasValidAnimationInstance");

	Params::SkeletalMeshComponent_HasValidAnimationInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.IsClothingSimulationSuspended
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::IsClothingSimulationSuspended() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsClothingSimulationSuspended");

	Params::SkeletalMeshComponent_IsClothingSimulationSuspended Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::IsPlaying() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlaying");

	Params::SkeletalMeshComponent_IsPlaying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.K2_GetClosestPointOnPhysicsAsset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldPosition                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ClosestWorldPosition                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMeshComponent::K2_GetClosestPointOnPhysicsAsset(const struct FVector& WorldPosition, struct FVector* ClosestWorldPosition, struct FVector* Normal, class FName* BoneName, float* Distance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetClosestPointOnPhysicsAsset");

	Params::SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset Parms{};

	Parms.WorldPosition = std::move(WorldPosition);

	UObject::ProcessEvent(Func, &Parms);

	if (ClosestWorldPosition != nullptr)
		*ClosestWorldPosition = std::move(Parms.ClosestWorldPosition);

	if (Normal != nullptr)
		*Normal = std::move(Parms.Normal);

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	return Parms.ReturnValue;
}


// Function Engine.Controller.ClientSetLocation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, NetValidate)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AController::ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetLocation");

	Params::Controller_ClientSetLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.ClientSetRotation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, NetValidate)
// Parameters:
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bResetCamera                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetRotation");

	Params::Controller_ClientSetRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);
	Parms.bResetCamera = bResetCamera;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.OnRep_Pawn
// (Native, Public)

void AController::OnRep_Pawn()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Pawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Controller.OnRep_PlayerState
// (Native, Public)

void AController::OnRep_PlayerState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_PlayerState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Controller.Possess
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::Possess(class APawn* InPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Possess");

	Params::Controller_Possess Parms{};

	Parms.InPawn = InPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.ReceiveInstigatedAnyDamage
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::ReceiveInstigatedAnyDamage(float Damage, const class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveInstigatedAnyDamage");

	Params::Controller_ReceiveInstigatedAnyDamage Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;
	Parms.DamagedActor = DamagedActor;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.ReceivePossess
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            PossessedPawn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::ReceivePossess(class APawn* PossessedPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceivePossess");

	Params::Controller_ReceivePossess Parms{};

	Parms.PossessedPawn = PossessedPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.ReceiveUnPossess
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            UnpossessedPawn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::ReceiveUnPossess(class APawn* UnpossessedPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveUnPossess");

	Params::Controller_ReceiveUnPossess Parms{};

	Parms.UnpossessedPawn = UnpossessedPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.ResetIgnoreInputFlags
// (Native, Public, BlueprintCallable)

void AController::ResetIgnoreInputFlags()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetIgnoreInputFlags");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Controller.ResetIgnoreLookInput
// (Native, Public, BlueprintCallable)

void AController::ResetIgnoreLookInput()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetIgnoreLookInput");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Controller.ResetIgnoreMoveInput
// (Native, Public, BlueprintCallable)

void AController::ResetIgnoreMoveInput()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetIgnoreMoveInput");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Controller.SetControlRotation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         NewRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AController::SetControlRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetControlRotation");

	Params::Controller_SetControlRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.SetIgnoreLookInput
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewLookInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::SetIgnoreLookInput(bool bNewLookInput)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIgnoreLookInput");

	Params::Controller_SetIgnoreLookInput Parms{};

	Parms.bNewLookInput = bNewLookInput;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.SetIgnoreMoveInput
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewMoveInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AController::SetIgnoreMoveInput(bool bNewMoveInput)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIgnoreMoveInput");

	Params::Controller_SetIgnoreMoveInput Parms{};

	Parms.bNewMoveInput = bNewMoveInput;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.SetInitialLocationAndRotation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AController::SetInitialLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInitialLocationAndRotation");

	Params::Controller_SetInitialLocationAndRotation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Controller.StopMovement
// (Native, Public, BlueprintCallable)

void AController::StopMovement()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Controller.UnPossess
// (Final, Native, Public, BlueprintCallable)

void AController::UnPossess()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnPossess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Controller.GetControlRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AController::GetControlRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetControlRotation");

	Params::Controller_GetControlRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.GetDesiredRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AController::GetDesiredRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDesiredRotation");

	Params::Controller_GetDesiredRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.GetPlayerViewPoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AController::GetPlayerViewPoint(struct FVector* Location, struct FRotator* Rotation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayerViewPoint");

	Params::Controller_GetPlayerViewPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function Engine.Controller.GetViewTarget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AController::GetViewTarget() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetViewTarget");

	Params::Controller_GetViewTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.IsLocalController
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsLocalController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsLocalController");

	Params::Controller_IsLocalController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.IsLocalPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsLocalPlayerController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsLocalPlayerController");

	Params::Controller_IsLocalPlayerController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.IsLookInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsLookInputIgnored() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsLookInputIgnored");

	Params::Controller_IsLookInputIgnored Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsMoveInputIgnored() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsMoveInputIgnored");

	Params::Controller_IsMoveInputIgnored Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.IsPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::IsPlayerController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlayerController");

	Params::Controller_IsPlayerController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.K2_GetPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AController::K2_GetPawn() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetPawn");

	Params::Controller_K2_GetPawn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Controller.LineOfSightTo
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Other                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ViewPoint                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlternateChecks                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AController::LineOfSightTo(const class AActor* Other, const struct FVector& ViewPoint, bool bAlternateChecks) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LineOfSightTo");

	Params::Controller_LineOfSightTo Parms{};

	Parms.Other = Other;
	Parms.ViewPoint = std::move(ViewPoint);
	Parms.bAlternateChecks = bAlternateChecks;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ForceFeedbackComponent.AdjustAttenuation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FForceFeedbackAttenuationSettingsInAttenuationSettings                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UForceFeedbackComponent::AdjustAttenuation(const struct FForceFeedbackAttenuationSettings& InAttenuationSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AdjustAttenuation");

	Params::ForceFeedbackComponent_AdjustAttenuation Parms{};

	Parms.InAttenuationSettings = std::move(InAttenuationSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ForceFeedbackComponent.Play
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForceFeedbackComponent::Play(float StartTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Play");

	Params::ForceFeedbackComponent_Play Parms{};

	Parms.StartTime = StartTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ForceFeedbackComponent.SetForceFeedbackEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*             NewForceFeedbackEffect                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForceFeedbackComponent::SetForceFeedbackEffect(class UForceFeedbackEffect* NewForceFeedbackEffect)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForceFeedbackEffect");

	Params::ForceFeedbackComponent_SetForceFeedbackEffect Parms{};

	Parms.NewForceFeedbackEffect = NewForceFeedbackEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ForceFeedbackComponent.SetIntensityMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewIntensityMultiplier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForceFeedbackComponent::SetIntensityMultiplier(float NewIntensityMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIntensityMultiplier");

	Params::ForceFeedbackComponent_SetIntensityMultiplier Parms{};

	Parms.NewIntensityMultiplier = NewIntensityMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ForceFeedbackComponent.Stop
// (Native, Public, BlueprintCallable)

void UForceFeedbackComponent::Stop()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Stop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ForceFeedbackComponent.BP_GetAttenuationSettingsToApply
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FForceFeedbackAttenuationSettingsOutAttenuationSettings                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UForceFeedbackComponent::BP_GetAttenuationSettingsToApply(struct FForceFeedbackAttenuationSettings* OutAttenuationSettings) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_GetAttenuationSettingsToApply");

	Params::ForceFeedbackComponent_BP_GetAttenuationSettingsToApply Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutAttenuationSettings != nullptr)
		*OutAttenuationSettings = std::move(Parms.OutAttenuationSettings);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.ActivateTouchInterface
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTouchInterface*                  NewTouchInterface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ActivateTouchInterface(class UTouchInterface* NewTouchInterface)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ActivateTouchInterface");

	Params::PlayerController_ActivateTouchInterface Parms{};

	Parms.NewTouchInterface = NewTouchInterface;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.AddPitchInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::AddPitchInput(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddPitchInput");

	Params::PlayerController_AddPitchInput Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.AddRollInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::AddRollInput(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddRollInput");

	Params::PlayerController_AddRollInput Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.AddYawInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::AddYawInput(float Val)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddYawInput");

	Params::PlayerController_AddYawInput Parms{};

	Parms.Val = Val;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.Camera
// (Exec, Native, Public)
// Parameters:
// class FName                             NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::Camera(class FName NewMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Camera");

	Params::PlayerController_Camera Parms{};

	Parms.NewMode = NewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.CanRestartPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::CanRestartPlayer()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanRestartPlayer");

	Params::PlayerController_CanRestartPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.ClearAudioListenerAttenuationOverride
// (Final, Native, Public, BlueprintCallable)

void APlayerController::ClearAudioListenerAttenuationOverride()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearAudioListenerAttenuationOverride");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClearAudioListenerOverride
// (Final, Native, Public, BlueprintCallable)

void APlayerController::ClearAudioListenerOverride()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearAudioListenerOverride");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientAddTextureStreamingLoc
// (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          InLoc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientAddTextureStreamingLoc");

	Params::PlayerController_ClientAddTextureStreamingLoc Parms{};

	Parms.InLoc = std::move(InLoc);
	Parms.Duration = Duration;
	Parms.bOverrideLocation = bOverrideLocation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientCancelPendingMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientCancelPendingMapChange()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientCancelPendingMapChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientCapBandwidth
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int32                                   Cap                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientCapBandwidth(int32 Cap)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientCapBandwidth");

	Params::PlayerController_ClientCapBandwidth Parms{};

	Parms.Cap = Cap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientClearCameraLensEffects
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void APlayerController::ClientClearCameraLensEffects()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientClearCameraLensEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientCommitMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientCommitMapChange()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientCommitMapChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientEnableNetworkVoice
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientEnableNetworkVoice(bool bEnable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientEnableNetworkVoice");

	Params::PlayerController_ClientEnableNetworkVoice Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientEndOnlineSession
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientEndOnlineSession()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientEndOnlineSession");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientFlushLevelStreaming
// (Final, Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientFlushLevelStreaming()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientFlushLevelStreaming");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientForceGarbageCollection
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientForceGarbageCollection()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientForceGarbageCollection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientGameEnded
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           EndGameFocus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsWinner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientGameEnded");

	Params::PlayerController_ClientGameEnded Parms{};

	Parms.EndGameFocus = EndGameFocus;
	Parms.bIsWinner = bIsWinner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientGotoState
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientGotoState(class FName NewState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientGotoState");

	Params::PlayerController_ClientGotoState Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientIgnoreLookInput
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bIgnore                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientIgnoreLookInput(bool bIgnore)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientIgnoreLookInput");

	Params::PlayerController_ClientIgnoreLookInput Parms{};

	Parms.bIgnore = bIgnore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientIgnoreMoveInput
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bIgnore                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientIgnoreMoveInput(bool bIgnore)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientIgnoreMoveInput");

	Params::PlayerController_ClientIgnoreMoveInput Parms{};

	Parms.bIgnore = bIgnore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           S                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MsgLifeTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientMessage(const class FString& S, class FName Type, float MsgLifeTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientMessage");

	Params::PlayerController_ClientMessage Parms{};

	Parms.S = std::move(S);
	Parms.Type = Type;
	Parms.MsgLifeTime = MsgLifeTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientMutePlayer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FUniqueNetIdRepl                 PlayerId                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientMutePlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientMutePlayer");

	Params::PlayerController_ClientMutePlayer Parms{};

	Parms.PlayerId = std::move(PlayerId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientPlayCameraAnim
// (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// class UCameraAnim*                      AnimToPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRandomStartTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraShakePlaySpace                   Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         CustomPlaySpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, ECameraShakePlaySpace Space, const struct FRotator& CustomPlaySpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientPlayCameraAnim");

	Params::PlayerController_ClientPlayCameraAnim Parms{};

	Parms.AnimToPlay = AnimToPlay;
	Parms.Scale = Scale;
	Parms.Rate = Rate;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.bLoop = bLoop;
	Parms.bRandomStartTime = bRandomStartTime;
	Parms.Space = Space;
	Parms.CustomPlaySpace = std::move(CustomPlaySpace);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientPlayForceFeedback_Internal
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FForceFeedbackParameters         Params_0                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ClientPlayForceFeedback_Internal(class UForceFeedbackEffect* ForceFeedbackEffect, const struct FForceFeedbackParameters& Params_0)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientPlayForceFeedback_Internal");

	Params::PlayerController_ClientPlayForceFeedback_Internal Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientPlaySound
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientPlaySound");

	Params::PlayerController_ClientPlaySound Parms{};

	Parms.Sound = Sound;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientPlaySoundAtLocation
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientPlaySoundAtLocation(class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientPlaySoundAtLocation");

	Params::PlayerController_ClientPlaySoundAtLocation Parms{};

	Parms.Sound = Sound;
	Parms.Location = std::move(Location);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientPrepareMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             LevelName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFirst                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLast                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientPrepareMapChange(class FName LevelName, bool bFirst, bool bLast)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientPrepareMapChange");

	Params::PlayerController_ClientPrepareMapChange Parms{};

	Parms.LevelName = LevelName;
	Parms.bFirst = bFirst;
	Parms.bLast = bLast;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientPrestreamTextures
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           ForcedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForceDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableStreaming                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CinematicTextureGroups                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientPrestreamTextures");

	Params::PlayerController_ClientPrestreamTextures Parms{};

	Parms.ForcedActor = ForcedActor;
	Parms.ForceDuration = ForceDuration;
	Parms.bEnableStreaming = bEnableStreaming;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientReceiveLocalizedMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TSubclassOf<class ULocalMessage>        Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Switch                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     RelatedPlayerState_1                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     RelatedPlayerState_2                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OptionalObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientReceiveLocalizedMessage(TSubclassOf<class ULocalMessage> Message, int32 Switch, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientReceiveLocalizedMessage");

	Params::PlayerController_ClientReceiveLocalizedMessage Parms{};

	Parms.Message = Message;
	Parms.Switch = Switch;
	Parms.RelatedPlayerState_1 = RelatedPlayerState_1;
	Parms.RelatedPlayerState_2 = RelatedPlayerState_2;
	Parms.OptionalObject = OptionalObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientRecvServerAckFrame
// (Net, Native, Event, Public, NetClient)
// Parameters:
// int32                                   LastProcessedInputFrame                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RecvServerFrameNumber                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    TimeDilation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientRecvServerAckFrame(int32 LastProcessedInputFrame, int32 RecvServerFrameNumber, int8 TimeDilation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientRecvServerAckFrame");

	Params::PlayerController_ClientRecvServerAckFrame Parms{};

	Parms.LastProcessedInputFrame = LastProcessedInputFrame;
	Parms.RecvServerFrameNumber = RecvServerFrameNumber;
	Parms.TimeDilation = TimeDilation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientRecvServerAckFrameDebug
// (Net, Native, Event, Public, NetClient)
// Parameters:
// uint8                                   NumBuffered                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetNumBufferedCmds                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientRecvServerAckFrameDebug(uint8 NumBuffered, float TargetNumBufferedCmds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientRecvServerAckFrameDebug");

	Params::PlayerController_ClientRecvServerAckFrameDebug Parms{};

	Parms.NumBuffered = NumBuffered;
	Parms.TargetNumBufferedCmds = TargetNumBufferedCmds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientRepObjRef
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientRepObjRef(class UObject* Object)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientRepObjRef");

	Params::PlayerController_ClientRepObjRef Parms{};

	Parms.Object = Object;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientReset
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientReset()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientRestart
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientRestart(class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientRestart");

	Params::PlayerController_ClientRestart Parms{};

	Parms.NewPawn = NewPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientRetryClientRestart
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientRetryClientRestart(class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientRetryClientRestart");

	Params::PlayerController_ClientRetryClientRestart Parms{};

	Parms.NewPawn = NewPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientReturnToMainMenu
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           ReturnReason                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientReturnToMainMenu(const class FString& ReturnReason)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientReturnToMainMenu");

	Params::PlayerController_ClientReturnToMainMenu Parms{};

	Parms.ReturnReason = std::move(ReturnReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientReturnToMainMenuWithTextReason
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FText                             ReturnReason                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ClientReturnToMainMenuWithTextReason(const class FText& ReturnReason)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientReturnToMainMenuWithTextReason");

	Params::PlayerController_ClientReturnToMainMenuWithTextReason Parms{};

	Parms.ReturnReason = std::move(ReturnReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSetBlockOnAsyncLoading
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientSetBlockOnAsyncLoading()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetBlockOnAsyncLoading");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientSetCameraFade
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// bool                                    bEnableFading                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        FadeAlpha                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFadeAudio                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHoldWhenFinished                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio, bool bHoldWhenFinished)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetCameraFade");

	Params::PlayerController_ClientSetCameraFade Parms{};

	Parms.bEnableFading = bEnableFading;
	Parms.FadeColor = std::move(FadeColor);
	Parms.FadeAlpha = std::move(FadeAlpha);
	Parms.FadeTime = FadeTime;
	Parms.bFadeAudio = bFadeAudio;
	Parms.bHoldWhenFinished = bHoldWhenFinished;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSetCameraMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             NewCamMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetCameraMode(class FName NewCamMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetCameraMode");

	Params::PlayerController_ClientSetCameraMode Parms{};

	Parms.NewCamMode = NewCamMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSetCinematicMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bInCinematicMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsMovement                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsTurning                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsHUD                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetCinematicMode");

	Params::PlayerController_ClientSetCinematicMode Parms{};

	Parms.bInCinematicMode = bInCinematicMode;
	Parms.bAffectsMovement = bAffectsMovement;
	Parms.bAffectsTurning = bAffectsTurning;
	Parms.bAffectsHUD = bAffectsHUD;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForceDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CinematicTextureGroups                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, int32 CinematicTextureGroups)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetForceMipLevelsToBeResident");

	Params::PlayerController_ClientSetForceMipLevelsToBeResident Parms{};

	Parms.Material = Material;
	Parms.ForceDuration = ForceDuration;
	Parms.CinematicTextureGroups = CinematicTextureGroups;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSetHUD
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// TSubclassOf<class AHUD>                 NewHUDClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetHUD(TSubclassOf<class AHUD> NewHUDClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetHUD");

	Params::PlayerController_ClientSetHUD Parms{};

	Parms.NewHUDClass = NewHUDClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSetSpectatorWaiting
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bWaiting                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSetSpectatorWaiting(bool bWaiting)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetSpectatorWaiting");

	Params::PlayerController_ClientSetSpectatorWaiting Parms{};

	Parms.bWaiting = bWaiting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSetViewTarget
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FViewTargetTransitionParams      TransitionParams                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ClientSetViewTarget(class AActor* A, const struct FViewTargetTransitionParams& TransitionParams)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSetViewTarget");

	Params::PlayerController_ClientSetViewTarget Parms{};

	Parms.A = A;
	Parms.TransitionParams = std::move(TransitionParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSpawnCameraLensEffect
// (Net, Native, Event, Public, NetClient)
// Parameters:
// TSubclassOf<class AEmitterCameraLensEffectBase>LensEffectEmitterClass                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSpawnCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSpawnCameraLensEffect");

	Params::PlayerController_ClientSpawnCameraLensEffect Parms{};

	Parms.LensEffectEmitterClass = LensEffectEmitterClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientSpawnGenericCameraLensEffect
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               LensEffectEmitterClass                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientSpawnGenericCameraLensEffect(TSubclassOf<class AActor> LensEffectEmitterClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientSpawnGenericCameraLensEffect");

	Params::PlayerController_ClientSpawnGenericCameraLensEffect Parms{};

	Parms.LensEffectEmitterClass = LensEffectEmitterClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientStartCameraShake
// (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     Shake                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraShakePlaySpace                   Playspace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         UserPlaySpaceRot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ClientStartCameraShake(TSubclassOf<class UCameraShakeBase> Shake, float Scale, ECameraShakePlaySpace Playspace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStartCameraShake");

	Params::PlayerController_ClientStartCameraShake Parms{};

	Parms.Shake = Shake;
	Parms.Scale = Scale;
	Parms.Playspace = Playspace;
	Parms.UserPlaySpaceRot = std::move(UserPlaySpaceRot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientStartCameraShakeFromSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     Shake                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraShakeSourceComponent*      SourceComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientStartCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> Shake, class UCameraShakeSourceComponent* SourceComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStartCameraShakeFromSource");

	Params::PlayerController_ClientStartCameraShakeFromSource Parms{};

	Parms.Shake = Shake;
	Parms.SourceComponent = SourceComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientStartOnlineSession
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientStartOnlineSession()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStartOnlineSession");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientStopCameraAnim
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UCameraAnim*                      AnimToStop                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientStopCameraAnim(class UCameraAnim* AnimToStop)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStopCameraAnim");

	Params::PlayerController_ClientStopCameraAnim Parms{};

	Parms.AnimToStop = AnimToStop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientStopCameraShake
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     Shake                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientStopCameraShake(TSubclassOf<class UCameraShakeBase> Shake, bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStopCameraShake");

	Params::PlayerController_ClientStopCameraShake Parms{};

	Parms.Shake = Shake;
	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientStopCameraShakesFromSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCameraShakeSourceComponent*      SourceComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientStopCameraShakesFromSource(class UCameraShakeSourceComponent* SourceComponent, bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStopCameraShakesFromSource");

	Params::PlayerController_ClientStopCameraShakesFromSource Parms{};

	Parms.SourceComponent = SourceComponent;
	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientStopForceFeedback
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientStopForceFeedback");

	Params::PlayerController_ClientStopForceFeedback Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Tag = Tag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientTeamMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APlayerState*                     SenderPlayerState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           S                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MsgLifeTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientTeamMessage(class APlayerState* SenderPlayerState, const class FString& S, class FName Type, float MsgLifeTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientTeamMessage");

	Params::PlayerController_ClientTeamMessage Parms{};

	Parms.SenderPlayerState = SenderPlayerState;
	Parms.S = std::move(S);
	Parms.Type = Type;
	Parms.MsgLifeTime = MsgLifeTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientTravel
// (Final, Native, Public, HasDefaults)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETravelType                             TravelType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSeamless                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            MapPackageGuid                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientTravel(const class FString& URL, ETravelType TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientTravel");

	Params::PlayerController_ClientTravel Parms{};

	Parms.URL = std::move(URL);
	Parms.TravelType = TravelType;
	Parms.bSeamless = bSeamless;
	Parms.MapPackageGuid = std::move(MapPackageGuid);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientTravelInternal
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETravelType                             TravelType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSeamless                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            MapPackageGuid                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientTravelInternal(const class FString& URL, ETravelType TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientTravelInternal");

	Params::PlayerController_ClientTravelInternal Parms{};

	Parms.URL = std::move(URL);
	Parms.TravelType = TravelType;
	Parms.bSeamless = bSeamless;
	Parms.MapPackageGuid = std::move(MapPackageGuid);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientUnmutePlayer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FUniqueNetIdRepl                 PlayerId                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientUnmutePlayer");

	Params::PlayerController_ClientUnmutePlayer Parms{};

	Parms.PlayerId = std::move(PlayerId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientUnmutePlayers
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FUniqueNetIdRepl>         PlayerIds                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ClientUnmutePlayers(const TArray<struct FUniqueNetIdRepl>& PlayerIds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientUnmutePlayers");

	Params::PlayerController_ClientUnmutePlayers Parms{};

	Parms.PlayerIds = std::move(PlayerIds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientUpdateLevelStreamingStatus
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             PackageName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewShouldBeLoaded                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewShouldBeVisible                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewShouldBlockOnLoad                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ClientUpdateLevelStreamingStatus(class FName PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int32 LODIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientUpdateLevelStreamingStatus");

	Params::PlayerController_ClientUpdateLevelStreamingStatus Parms{};

	Parms.PackageName = PackageName;
	Parms.bNewShouldBeLoaded = bNewShouldBeLoaded;
	Parms.bNewShouldBeVisible = bNewShouldBeVisible;
	Parms.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;
	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientUpdateMultipleLevelsStreamingStatus
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FUpdateLevelStreamingLevelStatus>LevelStatuses                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ClientUpdateMultipleLevelsStreamingStatus(const TArray<struct FUpdateLevelStreamingLevelStatus>& LevelStatuses)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientUpdateMultipleLevelsStreamingStatus");

	Params::PlayerController_ClientUpdateMultipleLevelsStreamingStatus Parms{};

	Parms.LevelStatuses = std::move(LevelStatuses);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ClientVoiceHandshakeComplete
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerController::ClientVoiceHandshakeComplete()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientVoiceHandshakeComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ClientWasKicked
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FText                             KickReason                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ClientWasKicked(const class FText& KickReason)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientWasKicked");

	Params::PlayerController_ClientWasKicked Parms{};

	Parms.KickReason = std::move(KickReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ConsoleKey
// (Exec, Native, Public)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ConsoleKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConsoleKey");

	Params::PlayerController_ConsoleKey Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.EnableCheats
// (Exec, Native, Public)

void APlayerController::EnableCheats()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableCheats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.FOV
// (Exec, Native, Public)
// Parameters:
// float                                   NewFOV                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::FOV(float NewFOV)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FOV");

	Params::PlayerController_FOV Parms{};

	Parms.NewFOV = NewFOV;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.K2_ClientPlayForceFeedback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreTimeDilation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayWhilePaused                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::K2_ClientPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_ClientPlayForceFeedback");

	Params::PlayerController_K2_ClientPlayForceFeedback Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Tag = Tag;
	Parms.bLooping = bLooping;
	Parms.bIgnoreTimeDilation = bIgnoreTimeDilation;
	Parms.bPlayWhilePaused = bPlayWhilePaused;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.LocalTravel
// (Exec, Native, Public)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::LocalTravel(const class FString& URL)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LocalTravel");

	Params::PlayerController_LocalTravel Parms{};

	Parms.URL = std::move(URL);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.OnServerStartedVisualLogger
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bIsLogging                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::OnServerStartedVisualLogger(bool bIsLogging)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnServerStartedVisualLogger");

	Params::PlayerController_OnServerStartedVisualLogger Parms{};

	Parms.bIsLogging = bIsLogging;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.Pause
// (Exec, Native, Public)

void APlayerController::Pause()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Pause");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.PlayDynamicForceFeedback
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsLeftLarge                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsLeftSmall                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsRightLarge                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsRightSmall                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDynamicForceFeedbackAction             Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, EDynamicForceFeedbackAction Action, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayDynamicForceFeedback");

	Params::PlayerController_PlayDynamicForceFeedback Parms{};

	Parms.Intensity = Intensity;
	Parms.Duration = Duration;
	Parms.bAffectsLeftLarge = bAffectsLeftLarge;
	Parms.bAffectsLeftSmall = bAffectsLeftSmall;
	Parms.bAffectsRightLarge = bAffectsRightLarge;
	Parms.bAffectsRightSmall = bAffectsRightSmall;
	Parms.Action = Action;
	Parms.LatentInfo = std::move(LatentInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.PlayHapticEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHapticFeedbackEffect_Base*       HapticEffect                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EControllerHand                         Hand                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::PlayHapticEffect(class UHapticFeedbackEffect_Base* HapticEffect, EControllerHand Hand, float Scale, bool bLoop)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayHapticEffect");

	Params::PlayerController_PlayHapticEffect Parms{};

	Parms.HapticEffect = HapticEffect;
	Parms.Hand = Hand;
	Parms.Scale = Scale;
	Parms.bLoop = bLoop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ResetControllerLightColor
// (Final, Native, Public, BlueprintCallable)

void APlayerController::ResetControllerLightColor()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetControllerLightColor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.RestartLevel
// (Exec, Native, Public)

void APlayerController::RestartLevel()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RestartLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.SendToConsole
// (Exec, Native, Public)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SendToConsole(const class FString& Command)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SendToConsole");

	Params::PlayerController_SendToConsole Parms{};

	Parms.Command = std::move(Command);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerAcknowledgePossession
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class APawn*                            P                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerAcknowledgePossession(class APawn* P)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerAcknowledgePossession");

	Params::PlayerController_ServerAcknowledgePossession Parms{};

	Parms.P = P;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerBlockPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl                 PlayerId                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerBlockPlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerBlockPlayer");

	Params::PlayerController_ServerBlockPlayer Parms{};

	Parms.PlayerId = std::move(PlayerId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerCamera
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerCamera(class FName NewMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerCamera");

	Params::PlayerController_ServerCamera Parms{};

	Parms.NewMode = NewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerChangeName
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           S                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerChangeName(const class FString& S)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerChangeName");

	Params::PlayerController_ServerChangeName Parms{};

	Parms.S = std::move(S);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerCheckClientPossession
// (Net, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerCheckClientPossession()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerCheckClientPossession");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerCheckClientPossessionReliable
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerCheckClientPossessionReliable()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerCheckClientPossessionReliable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerExec
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerExec(const class FString& Msg)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerExec");

	Params::PlayerController_ServerExec Parms{};

	Parms.Msg = std::move(Msg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerExecRPC
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerExecRPC(const class FString& Msg)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerExecRPC");

	Params::PlayerController_ServerExecRPC Parms{};

	Parms.Msg = std::move(Msg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerMutePlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl                 PlayerId                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerMutePlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMutePlayer");

	Params::PlayerController_ServerMutePlayer Parms{};

	Parms.PlayerId = std::move(PlayerId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerNotifyLoadedWorld
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             WorldPackageName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerNotifyLoadedWorld(class FName WorldPackageName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerNotifyLoadedWorld");

	Params::PlayerController_ServerNotifyLoadedWorld Parms{};

	Parms.WorldPackageName = WorldPackageName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerPause
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerPause()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerPause");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerRecvClientInputFrame
// (Net, Native, Event, Public, NetServer)
// Parameters:
// int32                                   RecvClientInputFrame                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           Data                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ServerRecvClientInputFrame(int32 RecvClientInputFrame, const TArray<uint8>& Data)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerRecvClientInputFrame");

	Params::PlayerController_ServerRecvClientInputFrame Parms{};

	Parms.RecvClientInputFrame = RecvClientInputFrame;
	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerRestartPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerRestartPlayer()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerRestartPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerSetSpectatorLocation
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          NewLoc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ServerSetSpectatorLocation(const struct FVector& NewLoc, const struct FRotator& NewRot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerSetSpectatorLocation");

	Params::PlayerController_ServerSetSpectatorLocation Parms{};

	Parms.NewLoc = std::move(NewLoc);
	Parms.NewRot = std::move(NewRot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerSetSpectatorWaiting
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bWaiting                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerSetSpectatorWaiting(bool bWaiting)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerSetSpectatorWaiting");

	Params::PlayerController_ServerSetSpectatorWaiting Parms{};

	Parms.bWaiting = bWaiting;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerShortTimeout
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerShortTimeout()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerShortTimeout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerToggleAILogging
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerToggleAILogging()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerToggleAILogging");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerUnblockPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl                 PlayerId                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerUnblockPlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerUnblockPlayer");

	Params::PlayerController_ServerUnblockPlayer Parms{};

	Parms.PlayerId = std::move(PlayerId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerUnmutePlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUniqueNetIdRepl                 PlayerId                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerUnmutePlayer");

	Params::PlayerController_ServerUnmutePlayer Parms{};

	Parms.PlayerId = std::move(PlayerId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerUpdateCamera
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantize              CamLoc                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CamPitchAndYaw                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ServerUpdateCamera(const struct FVector_NetQuantize& CamLoc, int32 CamPitchAndYaw)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerUpdateCamera");

	Params::PlayerController_ServerUpdateCamera Parms{};

	Parms.CamLoc = std::move(CamLoc);
	Parms.CamPitchAndYaw = CamPitchAndYaw;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerUpdateLevelVisibility
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FUpdateLevelVisibilityLevelInfo  LevelVisibility                                        (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ServerUpdateLevelVisibility(const struct FUpdateLevelVisibilityLevelInfo& LevelVisibility)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerUpdateLevelVisibility");

	Params::PlayerController_ServerUpdateLevelVisibility Parms{};

	Parms.LevelVisibility = std::move(LevelVisibility);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerUpdateMultipleLevelsVisibility
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<struct FUpdateLevelVisibilityLevelInfo>LevelVisibilities                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerController::ServerUpdateMultipleLevelsVisibility(const TArray<struct FUpdateLevelVisibilityLevelInfo>& LevelVisibilities)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerUpdateMultipleLevelsVisibility");

	Params::PlayerController_ServerUpdateMultipleLevelsVisibility Parms{};

	Parms.LevelVisibilities = std::move(LevelVisibilities);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ServerVerifyViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerVerifyViewTarget()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerVerifyViewTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerViewNextPlayer
// (Net, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerViewNextPlayer()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerViewNextPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerViewPrevPlayer
// (Net, Native, Event, Public, NetServer, NetValidate)

void APlayerController::ServerViewPrevPlayer()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerViewPrevPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerController.ServerViewSelf
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FViewTargetTransitionParams      TransitionParams                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerViewSelf");

	Params::PlayerController_ServerViewSelf Parms{};

	Parms.TransitionParams = std::move(TransitionParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetAudioListenerAttenuationOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AttenuationLocationOVerride                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetAudioListenerAttenuationOverride(class USceneComponent* AttachToComponent, const struct FVector& AttenuationLocationOVerride)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAudioListenerAttenuationOverride");

	Params::PlayerController_SetAudioListenerAttenuationOverride Parms{};

	Parms.AttachToComponent = AttachToComponent;
	Parms.AttenuationLocationOVerride = std::move(AttenuationLocationOVerride);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetAudioListenerOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APlayerController::SetAudioListenerOverride(class USceneComponent* AttachToComponent, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAudioListenerOverride");

	Params::PlayerController_SetAudioListenerOverride Parms{};

	Parms.AttachToComponent = AttachToComponent;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetCinematicMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCinematicMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidePlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsHUD                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsMovement                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsTurning                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCinematicMode");

	Params::PlayerController_SetCinematicMode Parms{};

	Parms.bInCinematicMode = bInCinematicMode;
	Parms.bHidePlayer = bHidePlayer;
	Parms.bAffectsHUD = bAffectsHUD;
	Parms.bAffectsMovement = bAffectsMovement;
	Parms.bAffectsTurning = bAffectsTurning;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetControllerLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetControllerLightColor(const struct FColor& Color)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetControllerLightColor");

	Params::PlayerController_SetControllerLightColor Parms{};

	Parms.Color = std::move(Color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetDeprecatedInputPitchScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetDeprecatedInputPitchScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDeprecatedInputPitchScale");

	Params::PlayerController_SetDeprecatedInputPitchScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetDeprecatedInputRollScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetDeprecatedInputRollScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDeprecatedInputRollScale");

	Params::PlayerController_SetDeprecatedInputRollScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetDeprecatedInputYawScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetDeprecatedInputYawScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDeprecatedInputYawScale");

	Params::PlayerController_SetDeprecatedInputYawScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetDisableHaptics
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewDisabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetDisableHaptics(bool bNewDisabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDisableHaptics");

	Params::PlayerController_SetDisableHaptics Parms{};

	Parms.bNewDisabled = bNewDisabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetHapticsByValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Frequency                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amplitude                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EControllerHand                         Hand                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetHapticsByValue(const float Frequency, const float Amplitude, EControllerHand Hand)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHapticsByValue");

	Params::PlayerController_SetHapticsByValue Parms{};

	Parms.Frequency = Frequency;
	Parms.Amplitude = Amplitude;
	Parms.Hand = Hand;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetMouseCursorWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMouseCursor                            Cursor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      CursorWidget                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetMouseCursorWidget(EMouseCursor Cursor, class UUserWidget* CursorWidget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMouseCursorWidget");

	Params::PlayerController_SetMouseCursorWidget Parms{};

	Parms.Cursor = Cursor;
	Parms.CursorWidget = CursorWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetMouseLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetMouseLocation(const int32 X, const int32 Y)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMouseLocation");

	Params::PlayerController_SetMouseLocation Parms{};

	Parms.X = X;
	Parms.Y = Y;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetName
// (Exec, Native, Public)
// Parameters:
// class FString                           S                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetName(const class FString& S)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetName");

	Params::PlayerController_SetName Parms{};

	Parms.S = std::move(S);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetViewTargetWithBlend
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EViewTargetBlendFunction                BlendFunc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockOutgoing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetViewTargetWithBlend");

	Params::PlayerController_SetViewTargetWithBlend Parms{};

	Parms.NewViewTarget = NewViewTarget;
	Parms.BlendTime = BlendTime;
	Parms.BlendFunc = BlendFunc;
	Parms.BlendExp = BlendExp;
	Parms.bLockOutgoing = bLockOutgoing;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SetVirtualJoystickVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SetVirtualJoystickVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVirtualJoystickVisibility");

	Params::PlayerController_SetVirtualJoystickVisibility Parms{};

	Parms.bVisible = bVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.StartFire
// (Exec, Native, Public)
// Parameters:
// uint8                                   FireModeNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::StartFire(uint8 FireModeNum)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartFire");

	Params::PlayerController_StartFire Parms{};

	Parms.FireModeNum = FireModeNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.StopHapticEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EControllerHand                         Hand                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::StopHapticEffect(EControllerHand Hand)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopHapticEffect");

	Params::PlayerController_StopHapticEffect Parms{};

	Parms.Hand = Hand;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.SwitchLevel
// (Exec, Native, Public)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::SwitchLevel(const class FString& URL)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SwitchLevel");

	Params::PlayerController_SwitchLevel Parms{};

	Parms.URL = std::move(URL);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.TestServerLevelVisibilityChange
// (Final, Exec, Native, Private)
// Parameters:
// class FName                             PackageName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Filename                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::TestServerLevelVisibilityChange(const class FName PackageName, const class FName Filename)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TestServerLevelVisibilityChange");

	Params::PlayerController_TestServerLevelVisibilityChange Parms{};

	Parms.PackageName = PackageName;
	Parms.Filename = Filename;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.ToggleSpeaking
// (Exec, Native, Public)
// Parameters:
// bool                                    bInSpeaking                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::ToggleSpeaking(bool bInSpeaking)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleSpeaking");

	Params::PlayerController_ToggleSpeaking Parms{};

	Parms.bInSpeaking = bInSpeaking;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerController.DeprojectMousePositionToWorld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::DeprojectMousePositionToWorld(struct FVector* WorldLocation, struct FVector* WorldDirection) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DeprojectMousePositionToWorld");

	Params::PlayerController_DeprojectMousePositionToWorld Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (WorldLocation != nullptr)
		*WorldLocation = std::move(Parms.WorldLocation);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.DeprojectScreenPositionToWorld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ScreenX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScreenY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, struct FVector* WorldLocation, struct FVector* WorldDirection) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DeprojectScreenPositionToWorld");

	Params::PlayerController_DeprojectScreenPositionToWorld Parms{};

	Parms.ScreenX = ScreenX;
	Parms.ScreenY = ScreenY;

	UObject::ProcessEvent(Func, &Parms);

	if (WorldLocation != nullptr)
		*WorldLocation = std::move(Parms.WorldLocation);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetDeprecatedInputPitchScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerController::GetDeprecatedInputPitchScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDeprecatedInputPitchScale");

	Params::PlayerController_GetDeprecatedInputPitchScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetDeprecatedInputRollScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerController::GetDeprecatedInputRollScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDeprecatedInputRollScale");

	Params::PlayerController_GetDeprecatedInputRollScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetDeprecatedInputYawScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerController::GetDeprecatedInputYawScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDeprecatedInputYawScale");

	Params::PlayerController_GetDeprecatedInputYawScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetFocalLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APlayerController::GetFocalLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFocalLocation");

	Params::PlayerController_GetFocalLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderCursor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderCursor(ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHitResultUnderCursor");

	Params::PlayerController_GetHitResultUnderCursor Parms{};

	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;

	UObject::ProcessEvent(Func, &Parms);

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderCursorByChannel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderCursorByChannel(ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHitResultUnderCursorByChannel");

	Params::PlayerController_GetHitResultUnderCursorByChannel Parms{};

	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;

	UObject::ProcessEvent(Func, &Parms);

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderCursorForObjects
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderCursorForObjects(const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHitResultUnderCursorForObjects");

	Params::PlayerController_GetHitResultUnderCursorForObjects Parms{};

	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;

	UObject::ProcessEvent(Func, &Parms);

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderFinger
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETouchIndex                             FingerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderFinger(ETouchIndex FingerIndex, ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHitResultUnderFinger");

	Params::PlayerController_GetHitResultUnderFinger Parms{};

	Parms.FingerIndex = FingerIndex;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;

	UObject::ProcessEvent(Func, &Parms);

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderFingerByChannel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETouchIndex                             FingerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderFingerByChannel(ETouchIndex FingerIndex, ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult* HitResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHitResultUnderFingerByChannel");

	Params::PlayerController_GetHitResultUnderFingerByChannel Parms{};

	Parms.FingerIndex = FingerIndex;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;

	UObject::ProcessEvent(Func, &Parms);

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderFingerForObjects
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETouchIndex                             FingerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetHitResultUnderFingerForObjects(ETouchIndex FingerIndex, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHitResultUnderFingerForObjects");

	Params::PlayerController_GetHitResultUnderFingerForObjects Parms{};

	Parms.FingerIndex = FingerIndex;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;

	UObject::ProcessEvent(Func, &Parms);

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHUD*                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHUD* APlayerController::GetHUD() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHUD");

	Params::PlayerController_GetHUD Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetInputAnalogKeyState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerController::GetInputAnalogKeyState(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputAnalogKeyState");

	Params::PlayerController_GetInputAnalogKeyState Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetInputAnalogStickState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EControllerAnalogStick                  WhichStick                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StickX                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StickY                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetInputAnalogStickState(EControllerAnalogStick WhichStick, float* StickX, float* StickY) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputAnalogStickState");

	Params::PlayerController_GetInputAnalogStickState Parms{};

	Parms.WhichStick = WhichStick;

	UObject::ProcessEvent(Func, &Parms);

	if (StickX != nullptr)
		*StickX = Parms.StickX;

	if (StickY != nullptr)
		*StickY = Parms.StickY;
}


// Function Engine.PlayerController.GetInputKeyTimeDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerController::GetInputKeyTimeDown(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputKeyTimeDown");

	Params::PlayerController_GetInputKeyTimeDown Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetInputMotionState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Tilt                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RotationRate                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Gravity                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Acceleration                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetInputMotionState(struct FVector* Tilt, struct FVector* RotationRate, struct FVector* Gravity, struct FVector* Acceleration) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputMotionState");

	Params::PlayerController_GetInputMotionState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Tilt != nullptr)
		*Tilt = std::move(Parms.Tilt);

	if (RotationRate != nullptr)
		*RotationRate = std::move(Parms.RotationRate);

	if (Gravity != nullptr)
		*Gravity = std::move(Parms.Gravity);

	if (Acceleration != nullptr)
		*Acceleration = std::move(Parms.Acceleration);
}


// Function Engine.PlayerController.GetInputMouseDelta
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DeltaX                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaY                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetInputMouseDelta(float* DeltaX, float* DeltaY) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputMouseDelta");

	Params::PlayerController_GetInputMouseDelta Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DeltaX != nullptr)
		*DeltaX = Parms.DeltaX;

	if (DeltaY != nullptr)
		*DeltaY = Parms.DeltaY;
}


// Function Engine.PlayerController.GetInputTouchState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETouchIndex                             FingerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocationX                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocationY                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCurrentlyPressed                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetInputTouchState(ETouchIndex FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputTouchState");

	Params::PlayerController_GetInputTouchState Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (LocationX != nullptr)
		*LocationX = Parms.LocationX;

	if (LocationY != nullptr)
		*LocationY = Parms.LocationY;

	if (bIsCurrentlyPressed != nullptr)
		*bIsCurrentlyPressed = Parms.bIsCurrentlyPressed;
}


// Function Engine.PlayerController.GetInputVectorKeyState
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APlayerController::GetInputVectorKeyState(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputVectorKeyState");

	Params::PlayerController_GetInputVectorKeyState Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetMousePosition
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   LocationX                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocationY                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::GetMousePosition(float* LocationX, float* LocationY) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMousePosition");

	Params::PlayerController_GetMousePosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LocationX != nullptr)
		*LocationX = Parms.LocationX;

	if (LocationY != nullptr)
		*LocationY = Parms.LocationY;

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetSpectatorPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASpectatorPawn*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASpectatorPawn* APlayerController::GetSpectatorPawn() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSpectatorPawn");

	Params::PlayerController_GetSpectatorPawn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.GetViewportSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SizeX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerController::GetViewportSize(int32* SizeX, int32* SizeY) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetViewportSize");

	Params::PlayerController_GetViewportSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SizeX != nullptr)
		*SizeX = Parms.SizeX;

	if (SizeY != nullptr)
		*SizeY = Parms.SizeY;
}


// Function Engine.PlayerController.IsInputKeyDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::IsInputKeyDown(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInputKeyDown");

	Params::PlayerController_IsInputKeyDown Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.IsStreamingSourceEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::IsStreamingSourceEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsStreamingSourceEnabled");

	Params::PlayerController_IsStreamingSourceEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.ProjectWorldLocationToScreen
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerViewportRelative                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::ProjectWorldLocationToScreen(const struct FVector& WorldLocation, struct FVector2D* ScreenLocation, bool bPlayerViewportRelative) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ProjectWorldLocationToScreen");

	Params::PlayerController_ProjectWorldLocationToScreen Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.bPlayerViewportRelative = bPlayerViewportRelative;

	UObject::ProcessEvent(Func, &Parms);

	if (ScreenLocation != nullptr)
		*ScreenLocation = std::move(Parms.ScreenLocation);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.WasInputKeyJustPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::WasInputKeyJustPressed(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasInputKeyJustPressed");

	Params::PlayerController_WasInputKeyJustPressed Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerController.WasInputKeyJustReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerController::WasInputKeyJustReleased(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasInputKeyJustReleased");

	Params::PlayerController_WasInputKeyJustReleased Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CheatManagerExtension.GetPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UCheatManagerExtension::GetPlayerController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayerController");

	Params::CheatManagerExtension_GetPlayerController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.SetDefaultAnimatingRig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObject>           InAnimatingRig                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMesh::SetDefaultAnimatingRig(TSoftObjectPtr<class UObject> InAnimatingRig)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultAnimatingRig");

	Params::SkeletalMesh_SetDefaultAnimatingRig Parms{};

	Parms.InAnimatingRig = InAnimatingRig;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMesh.SetLODSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshLODSettings*         InLODSettings                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMesh::SetLODSettings(class USkeletalMeshLODSettings* InLODSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLODSettings");

	Params::SkeletalMesh_SetLODSettings Parms{};

	Parms.InLODSettings = InLODSettings;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMesh.SetMaterials
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSkeletalMaterial>        InMaterials                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkeletalMesh::SetMaterials(const TArray<struct FSkeletalMaterial>& InMaterials)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaterials");

	Params::SkeletalMesh_SetMaterials Parms{};

	Parms.InMaterials = std::move(InMaterials);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMesh.SetMeshClothingAssets
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UClothingAssetBase*>       InMeshClothingAssets                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkeletalMesh::SetMeshClothingAssets(const TArray<class UClothingAssetBase*>& InMeshClothingAssets)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMeshClothingAssets");

	Params::SkeletalMesh_SetMeshClothingAssets Parms{};

	Parms.InMeshClothingAssets = std::move(InMeshClothingAssets);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMesh.SetMorphTargets
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UMorphTarget*>             InMorphTargets                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USkeletalMesh::SetMorphTargets(const TArray<class UMorphTarget*>& InMorphTargets)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMorphTargets");

	Params::SkeletalMesh_SetMorphTargets Parms{};

	Parms.InMorphTargets = std::move(InMorphTargets);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMesh.FindSocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshSocket*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshSocket* USkeletalMesh::FindSocket(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindSocket");

	Params::SkeletalMesh_FindSocket Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.FindSocketAndIndex
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshSocket*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshSocket* USkeletalMesh::FindSocketAndIndex(class FName InSocketName, int32* OutIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindSocketAndIndex");

	Params::SkeletalMesh_FindSocketAndIndex Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.FindSocketInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   OutBoneIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshSocket*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshSocket* USkeletalMesh::FindSocketInfo(class FName InSocketName, struct FTransform* OutTransform, int32* OutBoneIndex, int32* OutIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindSocketInfo");

	Params::SkeletalMesh_FindSocketInfo Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	if (OutBoneIndex != nullptr)
		*OutBoneIndex = Parms.OutBoneIndex;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds USkeletalMesh::GetBounds() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBounds");

	Params::SkeletalMesh_GetBounds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetDefaultAnimatingRig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> USkeletalMesh::GetDefaultAnimatingRig() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultAnimatingRig");

	Params::SkeletalMesh_GetDefaultAnimatingRig Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetImportedBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds USkeletalMesh::GetImportedBounds() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetImportedBounds");

	Params::SkeletalMesh_GetImportedBounds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetLODSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class USkeletalMeshLODSettings*   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USkeletalMeshLODSettings* USkeletalMesh::GetLODSettings() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLODSettings");

	Params::SkeletalMesh_GetLODSettings Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetMaterials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FSkeletalMaterial>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FSkeletalMaterial> USkeletalMesh::GetMaterials() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterials");

	Params::SkeletalMesh_GetMaterials Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetMeshClothingAssets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UClothingAssetBase*> ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class UClothingAssetBase*> USkeletalMesh::GetMeshClothingAssets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMeshClothingAssets");

	Params::SkeletalMesh_GetMeshClothingAssets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetMorphTargets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UMorphTarget*>       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class UMorphTarget*> USkeletalMesh::GetMorphTargets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMorphTargets");

	Params::SkeletalMesh_GetMorphTargets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetNodeMappingContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlueprint*                       SourceAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNodeMappingContainer*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNodeMappingContainer* USkeletalMesh::GetNodeMappingContainer(class UBlueprint* SourceAsset) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNodeMappingContainer");

	Params::SkeletalMesh_GetNodeMappingContainer Parms{};

	Parms.SourceAsset = SourceAsset;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetNodeMappingData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UNodeMappingContainer*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class UNodeMappingContainer*> USkeletalMesh::GetNodeMappingData() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNodeMappingData");

	Params::SkeletalMesh_GetNodeMappingData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetPhysicsAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPhysicsAsset*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicsAsset* USkeletalMesh::GetPhysicsAsset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicsAsset");

	Params::SkeletalMesh_GetPhysicsAsset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetShadowPhysicsAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPhysicsAsset*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicsAsset* USkeletalMesh::GetShadowPhysicsAsset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShadowPhysicsAsset");

	Params::SkeletalMesh_GetShadowPhysicsAsset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetSkeleton
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class USkeleton*                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USkeleton* USkeletalMesh::GetSkeleton() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSkeleton");

	Params::SkeletalMesh_GetSkeleton Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.GetSocketByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshSocket*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshSocket* USkeletalMesh::GetSocketByIndex(int32 Index_0) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSocketByIndex");

	Params::SkeletalMesh_GetSocketByIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.IsSectionUsingCloth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSectionIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckCorrespondingSections                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkeletalMesh::IsSectionUsingCloth(int32 InSectionIndex, bool bCheckCorrespondingSections) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsSectionUsingCloth");

	Params::SkeletalMesh_IsSectionUsingCloth Parms{};

	Parms.InSectionIndex = InSectionIndex;
	Parms.bCheckCorrespondingSections = bCheckCorrespondingSections;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.K2_GetAllMorphTargetNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> USkeletalMesh::K2_GetAllMorphTargetNames() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetAllMorphTargetNames");

	Params::SkeletalMesh_K2_GetAllMorphTargetNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMesh.NumSockets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USkeletalMesh::NumSockets() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NumSockets");

	Params::SkeletalMesh_NumSockets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.AddPoint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSplinePoint                     Point                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddPoint(const struct FSplinePoint& Point, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddPoint");

	Params::SplineComponent_AddPoint Parms{};

	Parms.Point = std::move(Point);
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.AddPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSplinePoint>             Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddPoints(const TArray<struct FSplinePoint>& Points, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddPoints");

	Params::SplineComponent_AddPoints Parms{};

	Parms.Points = std::move(Points);
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.AddSplineLocalPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddSplineLocalPoint(const struct FVector& Position)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddSplineLocalPoint");

	Params::SplineComponent_AddSplineLocalPoint Parms{};

	Parms.Position = std::move(Position);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.AddSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddSplinePoint(const struct FVector& Position, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddSplinePoint");

	Params::SplineComponent_AddSplinePoint Parms{};

	Parms.Position = std::move(Position);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.AddSplinePointAtIndex
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddSplinePointAtIndex(const struct FVector& Position, int32 Index_0, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddSplinePointAtIndex");

	Params::SplineComponent_AddSplinePointAtIndex Parms{};

	Parms.Position = std::move(Position);
	Parms.Index_0 = Index_0;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.AddSplineWorldPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::AddSplineWorldPoint(const struct FVector& Position)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddSplineWorldPoint");

	Params::SplineComponent_AddSplineWorldPoint Parms{};

	Parms.Position = std::move(Position);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.ClearSplinePoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::ClearSplinePoints(bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearSplinePoints");

	Params::SplineComponent_ClearSplinePoints Parms{};

	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.RemoveSplinePoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::RemoveSplinePoint(int32 Index_0, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveSplinePoint");

	Params::SplineComponent_RemoveSplinePoint Parms{};

	Parms.Index_0 = Index_0;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetClosedLoop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInClosedLoop                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetClosedLoop");

	Params::SplineComponent_SetClosedLoop Parms{};

	Parms.bInClosedLoop = bInClosedLoop;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetClosedLoopAtPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInClosedLoop                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetClosedLoopAtPosition");

	Params::SplineComponent_SetClosedLoopAtPosition Parms{};

	Parms.bInClosedLoop = bInClosedLoop;
	Parms.Key = Key;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetDefaultUpVector
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          UpVector                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetDefaultUpVector(const struct FVector& UpVector, ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultUpVector");

	Params::SplineComponent_SetDefaultUpVector Parms{};

	Parms.UpVector = std::move(UpVector);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetDrawDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetDrawDebug(bool bShow)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDrawDebug");

	Params::SplineComponent_SetDrawDebug Parms{};

	Parms.bShow = bShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetLocationAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetLocationAtSplinePoint(int32 PointIndex, const struct FVector& InLocation, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLocationAtSplinePoint");

	Params::SplineComponent_SetLocationAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InLocation = std::move(InLocation);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetRotationAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRotation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetRotationAtSplinePoint(int32 PointIndex, const struct FRotator& InRotation, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRotationAtSplinePoint");

	Params::SplineComponent_SetRotationAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InRotation = std::move(InRotation);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetScaleAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InScaleVector                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetScaleAtSplinePoint(int32 PointIndex, const struct FVector& InScaleVector, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScaleAtSplinePoint");

	Params::SplineComponent_SetScaleAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InScaleVector = std::move(InScaleVector);
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetSelectedSplineSegmentColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     SegmentColor                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetSelectedSplineSegmentColor(const struct FLinearColor& SegmentColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSelectedSplineSegmentColor");

	Params::SplineComponent_SetSelectedSplineSegmentColor Parms{};

	Parms.SegmentColor = std::move(SegmentColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetSplineLocalPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USplineComponent::SetSplineLocalPoints(const TArray<struct FVector>& Points)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSplineLocalPoints");

	Params::SplineComponent_SetSplineLocalPoints Parms{};

	Parms.Points = std::move(Points);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetSplinePoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetSplinePoints(const TArray<struct FVector>& Points, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSplinePoints");

	Params::SplineComponent_SetSplinePoints Parms{};

	Parms.Points = std::move(Points);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetSplinePointType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplinePointType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetSplinePointType(int32 PointIndex, ESplinePointType Type, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSplinePointType");

	Params::SplineComponent_SetSplinePointType Parms{};

	Parms.PointIndex = PointIndex;
	Parms.Type = Type;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetSplineWorldPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USplineComponent::SetSplineWorldPoints(const TArray<struct FVector>& Points)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSplineWorldPoints");

	Params::SplineComponent_SetSplineWorldPoints Parms{};

	Parms.Points = std::move(Points);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetTangentAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InTangent                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetTangentAtSplinePoint(int32 PointIndex, const struct FVector& InTangent, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTangentAtSplinePoint");

	Params::SplineComponent_SetTangentAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InTangent = std::move(InTangent);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetTangentColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     TangentColor                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetTangentColor(const struct FLinearColor& TangentColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTangentColor");

	Params::SplineComponent_SetTangentColor Parms{};

	Parms.TangentColor = std::move(TangentColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetTangentsAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InArriveTangent                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLeaveTangent                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetTangentsAtSplinePoint(int32 PointIndex, const struct FVector& InArriveTangent, const struct FVector& InLeaveTangent, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTangentsAtSplinePoint");

	Params::SplineComponent_SetTangentsAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InArriveTangent = std::move(InArriveTangent);
	Parms.InLeaveTangent = std::move(InLeaveTangent);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetUnselectedSplineSegmentColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     SegmentColor                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetUnselectedSplineSegmentColor(const struct FLinearColor& SegmentColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUnselectedSplineSegmentColor");

	Params::SplineComponent_SetUnselectedSplineSegmentColor Parms{};

	Parms.SegmentColor = std::move(SegmentColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetUpVectorAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InUpVector                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetUpVectorAtSplinePoint(int32 PointIndex, const struct FVector& InUpVector, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUpVectorAtSplinePoint");

	Params::SplineComponent_SetUpVectorAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InUpVector = std::move(InUpVector);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.SetWorldLocationAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::SetWorldLocationAtSplinePoint(int32 PointIndex, const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWorldLocationAtSplinePoint");

	Params::SplineComponent_SetWorldLocationAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.InLocation = std::move(InLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineComponent.UpdateSpline
// (Native, Public, BlueprintCallable)

void USplineComponent::UpdateSpline()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateSpline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SplineComponent.ConvertSplineSegmentToPolyLine
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplinePointStartIndex                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSquareDistanceFromSpline                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USplineComponent::ConvertSplineSegmentToPolyLine(int32 SplinePointStartIndex, ESplineCoordinateSpace CoordinateSpace, const float MaxSquareDistanceFromSpline, TArray<struct FVector>* OutPoints) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConvertSplineSegmentToPolyLine");

	Params::SplineComponent_ConvertSplineSegmentToPolyLine Parms{};

	Parms.SplinePointStartIndex = SplinePointStartIndex;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.MaxSquareDistanceFromSpline = MaxSquareDistanceFromSpline;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.ConvertSplineToPolyLine
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSquareDistanceFromSpline                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USplineComponent::ConvertSplineToPolyLine(ESplineCoordinateSpace CoordinateSpace, const float MaxSquareDistanceFromSpline, TArray<struct FVector>* OutPoints) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConvertSplineToPolyLine");

	Params::SplineComponent_ConvertSplineToPolyLine Parms{};

	Parms.CoordinateSpace = CoordinateSpace;
	Parms.MaxSquareDistanceFromSpline = MaxSquareDistanceFromSpline;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.DivideSplineIntoPolylineRecursive
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   StartDistanceAlongSpline                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistanceAlongSpline                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSquareDistanceFromSpline                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutPoints                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USplineComponent::DivideSplineIntoPolylineRecursive(float StartDistanceAlongSpline, float EndDistanceAlongSpline, ESplineCoordinateSpace CoordinateSpace, const float MaxSquareDistanceFromSpline, TArray<struct FVector>* OutPoints) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DivideSplineIntoPolylineRecursive");

	Params::SplineComponent_DivideSplineIntoPolylineRecursive Parms{};

	Parms.StartDistanceAlongSpline = StartDistanceAlongSpline;
	Parms.EndDistanceAlongSpline = EndDistanceAlongSpline;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.MaxSquareDistanceFromSpline = MaxSquareDistanceFromSpline;

	UObject::ProcessEvent(Func, &Parms);

	if (OutPoints != nullptr)
		*OutPoints = std::move(Parms.OutPoints);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindDirectionClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindDirectionClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindDirectionClosestToWorldLocation");

	Params::SplineComponent_FindDirectionClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::FindInputKeyClosestToWorldLocation(const struct FVector& WorldLocation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindInputKeyClosestToWorldLocation");

	Params::SplineComponent_FindInputKeyClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindLocationClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindLocationClosestToWorldLocation");

	Params::SplineComponent_FindLocationClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindRightVectorClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindRightVectorClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindRightVectorClosestToWorldLocation");

	Params::SplineComponent_FindRightVectorClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindRollClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::FindRollClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindRollClosestToWorldLocation");

	Params::SplineComponent_FindRollClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindRotationClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::FindRotationClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindRotationClosestToWorldLocation");

	Params::SplineComponent_FindRotationClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindScaleClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindScaleClosestToWorldLocation(const struct FVector& WorldLocation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindScaleClosestToWorldLocation");

	Params::SplineComponent_FindScaleClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindTangentClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindTangentClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindTangentClosestToWorldLocation");

	Params::SplineComponent_FindTangentClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindTransformClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::FindTransformClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindTransformClosestToWorldLocation");

	Params::SplineComponent_FindTransformClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.FindUpVectorClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::FindUpVectorClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindUpVectorClosestToWorldLocation");

	Params::SplineComponent_FindUpVectorClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetArriveTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetArriveTangentAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetArriveTangentAtSplinePoint");

	Params::SplineComponent_GetArriveTangentAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetDefaultUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDefaultUpVector(ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultUpVector");

	Params::SplineComponent_GetDefaultUpVector Parms{};

	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDirectionAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDirectionAtDistanceAlongSpline");

	Params::SplineComponent_GetDirectionAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetDirectionAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDirectionAtSplineInputKey(float InKey, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDirectionAtSplineInputKey");

	Params::SplineComponent_GetDirectionAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetDirectionAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDirectionAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDirectionAtSplinePoint");

	Params::SplineComponent_GetDirectionAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetDirectionAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetDirectionAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDirectionAtTime");

	Params::SplineComponent_GetDirectionAtTime Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetDistanceAlongSplineAtSplineInputKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetDistanceAlongSplineAtSplineInputKey(float InKey) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDistanceAlongSplineAtSplineInputKey");

	Params::SplineComponent_GetDistanceAlongSplineAtSplineInputKey Parms{};

	Parms.InKey = InKey;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetDistanceAlongSplineAtSplinePoint(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDistanceAlongSplineAtSplinePoint");

	Params::SplineComponent_GetDistanceAlongSplineAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetFloatPropertyAtSplineInputKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetFloatPropertyAtSplineInputKey(float InKey, class FName PropertyName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFloatPropertyAtSplineInputKey");

	Params::SplineComponent_GetFloatPropertyAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.PropertyName = PropertyName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetFloatPropertyAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetFloatPropertyAtSplinePoint(int32 Index_0, class FName PropertyName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFloatPropertyAtSplinePoint");

	Params::SplineComponent_GetFloatPropertyAtSplinePoint Parms{};

	Parms.Index_0 = Index_0;
	Parms.PropertyName = PropertyName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetInputKeyAtDistanceAlongSpline(float Distance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInputKeyAtDistanceAlongSpline");

	Params::SplineComponent_GetInputKeyAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetLeaveTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLeaveTangentAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLeaveTangentAtSplinePoint");

	Params::SplineComponent_GetLeaveTangentAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalTangent                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::GetLocalLocationAndTangentAtSplinePoint(int32 PointIndex, struct FVector* LocalLocation, struct FVector* LocalTangent) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocalLocationAndTangentAtSplinePoint");

	Params::SplineComponent_GetLocalLocationAndTangentAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (LocalLocation != nullptr)
		*LocalLocation = std::move(Parms.LocalLocation);

	if (LocalTangent != nullptr)
		*LocalTangent = std::move(Parms.LocalTangent);
}


// Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Tangent                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineComponent::GetLocationAndTangentAtSplinePoint(int32 PointIndex, struct FVector* Location, struct FVector* Tangent, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocationAndTangentAtSplinePoint");

	Params::SplineComponent_GetLocationAndTangentAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Tangent != nullptr)
		*Tangent = std::move(Parms.Tangent);
}


// Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLocationAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocationAtDistanceAlongSpline");

	Params::SplineComponent_GetLocationAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLocationAtSplineInputKey(float InKey, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocationAtSplineInputKey");

	Params::SplineComponent_GetLocationAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLocationAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocationAtSplinePoint");

	Params::SplineComponent_GetLocationAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetLocationAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocationAtTime");

	Params::SplineComponent_GetLocationAtTime Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetNumberOfSplinePoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USplineComponent::GetNumberOfSplinePoints() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumberOfSplinePoints");

	Params::SplineComponent_GetNumberOfSplinePoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetNumberOfSplineSegments
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USplineComponent::GetNumberOfSplineSegments() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumberOfSplineSegments");

	Params::SplineComponent_GetNumberOfSplineSegments Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetRightVectorAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRightVectorAtDistanceAlongSpline");

	Params::SplineComponent_GetRightVectorAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRightVectorAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetRightVectorAtSplineInputKey(float InKey, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRightVectorAtSplineInputKey");

	Params::SplineComponent_GetRightVectorAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRightVectorAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetRightVectorAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRightVectorAtSplinePoint");

	Params::SplineComponent_GetRightVectorAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRightVectorAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetRightVectorAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRightVectorAtTime");

	Params::SplineComponent_GetRightVectorAtTime Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRollAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetRollAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRollAtDistanceAlongSpline");

	Params::SplineComponent_GetRollAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRollAtSplineInputKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetRollAtSplineInputKey(float InKey, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRollAtSplineInputKey");

	Params::SplineComponent_GetRollAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRollAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetRollAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRollAtSplinePoint");

	Params::SplineComponent_GetRollAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRollAtTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetRollAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRollAtTime");

	Params::SplineComponent_GetRollAtTime Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetRotationAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationAtDistanceAlongSpline");

	Params::SplineComponent_GetRotationAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRotationAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetRotationAtSplineInputKey(float InKey, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationAtSplineInputKey");

	Params::SplineComponent_GetRotationAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRotationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetRotationAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationAtSplinePoint");

	Params::SplineComponent_GetRotationAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetRotationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetRotationAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRotationAtTime");

	Params::SplineComponent_GetRotationAtTime Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetScaleAtDistanceAlongSpline(float Distance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaleAtDistanceAlongSpline");

	Params::SplineComponent_GetScaleAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetScaleAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetScaleAtSplineInputKey(float InKey) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaleAtSplineInputKey");

	Params::SplineComponent_GetScaleAtSplineInputKey Parms{};

	Parms.InKey = InKey;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetScaleAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetScaleAtSplinePoint(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaleAtSplinePoint");

	Params::SplineComponent_GetScaleAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetScaleAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetScaleAtTime(float Time, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaleAtTime");

	Params::SplineComponent_GetScaleAtTime Parms{};

	Parms.Time = Time;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetSplineLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineComponent::GetSplineLength() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplineLength");

	Params::SplineComponent_GetSplineLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetSplinePointType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplinePointType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESplinePointType USplineComponent::GetSplinePointType(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplinePointType");

	Params::SplineComponent_GetSplinePointType Parms{};

	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetTangentAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTangentAtDistanceAlongSpline");

	Params::SplineComponent_GetTangentAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetTangentAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetTangentAtSplineInputKey(float InKey, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTangentAtSplineInputKey");

	Params::SplineComponent_GetTangentAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetTangentAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTangentAtSplinePoint");

	Params::SplineComponent_GetTangentAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetTangentAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetTangentAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTangentAtTime");

	Params::SplineComponent_GetTangentAtTime Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::GetTransformAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransformAtDistanceAlongSpline");

	Params::SplineComponent_GetTransformAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetTransformAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::GetTransformAtSplineInputKey(float InKey, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransformAtSplineInputKey");

	Params::SplineComponent_GetTransformAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetTransformAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::GetTransformAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace, bool bUseScale) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransformAtSplinePoint");

	Params::SplineComponent_GetTransformAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseScale = bUseScale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetTransformAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform USplineComponent::GetTransformAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity, bool bUseScale) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTransformAtTime");

	Params::SplineComponent_GetTransformAtTime Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;
	Parms.bUseScale = bUseScale;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetUpVectorAtDistanceAlongSpline(float Distance, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUpVectorAtDistanceAlongSpline");

	Params::SplineComponent_GetUpVectorAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetUpVectorAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetUpVectorAtSplineInputKey(float InKey, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUpVectorAtSplineInputKey");

	Params::SplineComponent_GetUpVectorAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetUpVectorAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetUpVectorAtSplinePoint(int32 PointIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUpVectorAtSplinePoint");

	Params::SplineComponent_GetUpVectorAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetUpVectorAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetUpVectorAtTime(float Time, ESplineCoordinateSpace CoordinateSpace, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUpVectorAtTime");

	Params::SplineComponent_GetUpVectorAtTime Parms{};

	Parms.Time = Time;
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetVectorPropertyAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetVectorPropertyAtSplineInputKey(float InKey, class FName PropertyName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVectorPropertyAtSplineInputKey");

	Params::SplineComponent_GetVectorPropertyAtSplineInputKey Parms{};

	Parms.InKey = InKey;
	Parms.PropertyName = PropertyName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetVectorPropertyAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetVectorPropertyAtSplinePoint(int32 Index_0, class FName PropertyName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVectorPropertyAtSplinePoint");

	Params::SplineComponent_GetVectorPropertyAtSplinePoint Parms{};

	Parms.Index_0 = Index_0;
	Parms.PropertyName = PropertyName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldDirectionAtDistanceAlongSpline(float Distance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldDirectionAtDistanceAlongSpline");

	Params::SplineComponent_GetWorldDirectionAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldDirectionAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldDirectionAtTime");

	Params::SplineComponent_GetWorldDirectionAtTime Parms{};

	Parms.Time = Time;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldLocationAtDistanceAlongSpline(float Distance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldLocationAtDistanceAlongSpline");

	Params::SplineComponent_GetWorldLocationAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldLocationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldLocationAtSplinePoint(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldLocationAtSplinePoint");

	Params::SplineComponent_GetWorldLocationAtSplinePoint Parms{};

	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldLocationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldLocationAtTime(float Time, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldLocationAtTime");

	Params::SplineComponent_GetWorldLocationAtTime Parms{};

	Parms.Time = Time;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetWorldRotationAtDistanceAlongSpline(float Distance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldRotationAtDistanceAlongSpline");

	Params::SplineComponent_GetWorldRotationAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldRotationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseConstantVelocity                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USplineComponent::GetWorldRotationAtTime(float Time, bool bUseConstantVelocity) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldRotationAtTime");

	Params::SplineComponent_GetWorldRotationAtTime Parms{};

	Parms.Time = Time;
	Parms.bUseConstantVelocity = bUseConstantVelocity;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineComponent::GetWorldTangentAtDistanceAlongSpline(float Distance) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldTangentAtDistanceAlongSpline");

	Params::SplineComponent_GetWorldTangentAtDistanceAlongSpline Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineComponent.IsClosedLoop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USplineComponent::IsClosedLoop() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsClosedLoop");

	Params::SplineComponent_IsClosedLoop Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DecalComponent.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UDecalComponent::CreateDynamicMaterialInstance()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreateDynamicMaterialInstance");

	Params::DecalComponent_CreateDynamicMaterialInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DecalComponent.SetDecalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               NewDecalMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDecalMaterial");

	Params::DecalComponent_SetDecalMaterial Parms{};

	Parms.NewDecalMaterial = NewDecalMaterial;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DecalComponent.SetFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duaration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetFadeIn(float StartDelay, float Duaration)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFadeIn");

	Params::DecalComponent_SetFadeIn Parms{};

	Parms.StartDelay = StartDelay;
	Parms.Duaration = Duaration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DecalComponent.SetFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DestroyOwnerAfterFade                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFadeOut");

	Params::DecalComponent_SetFadeOut Parms{};

	Parms.StartDelay = StartDelay;
	Parms.Duration = Duration;
	Parms.DestroyOwnerAfterFade = DestroyOwnerAfterFade;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DecalComponent.SetFadeScreenSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewFadeScreenSize                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetFadeScreenSize(float NewFadeScreenSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFadeScreenSize");

	Params::DecalComponent_SetFadeScreenSize Parms{};

	Parms.NewFadeScreenSize = NewFadeScreenSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DecalComponent.SetSortOrder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalComponent::SetSortOrder(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSortOrder");

	Params::DecalComponent_SetSortOrder Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DecalComponent.GetDecalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UDecalComponent::GetDecalMaterial() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDecalMaterial");

	Params::DecalComponent_GetDecalMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DecalComponent.GetFadeDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDecalComponent::GetFadeDuration() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFadeDuration");

	Params::DecalComponent_GetFadeDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DecalComponent.GetFadeInDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDecalComponent::GetFadeInDuration() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFadeInDuration");

	Params::DecalComponent_GetFadeInDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DecalComponent.GetFadeInStartDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDecalComponent::GetFadeInStartDelay() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFadeInStartDelay");

	Params::DecalComponent_GetFadeInStartDelay Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DecalComponent.GetFadeStartDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDecalComponent::GetFadeStartDelay() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFadeStartDelay");

	Params::DecalComponent_GetFadeStartDelay Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMeshComponent.OnRep_StaticMesh
// (Final, Native, Public)
// Parameters:
// class UStaticMesh*                      OldStaticMesh                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::OnRep_StaticMesh(class UStaticMesh* OldStaticMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_StaticMesh");

	Params::StaticMeshComponent_OnRep_StaticMesh Parms{};

	Parms.OldStaticMesh = OldStaticMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMeshComponent.SetDistanceFieldSelfShadowBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::SetDistanceFieldSelfShadowBias(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDistanceFieldSelfShadowBias");

	Params::StaticMeshComponent_SetDistanceFieldSelfShadowBias Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMeshComponent.SetEvaluateWorldPositionOffsetInRayTracing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::SetEvaluateWorldPositionOffsetInRayTracing(bool NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEvaluateWorldPositionOffsetInRayTracing");

	Params::StaticMeshComponent_SetEvaluateWorldPositionOffsetInRayTracing Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMeshComponent.SetForcedLodModel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewForcedLodModel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::SetForcedLodModel(int32 NewForcedLodModel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForcedLodModel");

	Params::StaticMeshComponent_SetForcedLodModel Parms{};

	Parms.NewForcedLodModel = NewForcedLodModel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMeshComponent.SetReverseCulling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReverseCulling                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::SetReverseCulling(bool ReverseCulling)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetReverseCulling");

	Params::StaticMeshComponent_SetReverseCulling Parms{};

	Parms.ReverseCulling = ReverseCulling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMeshComponent.SetStaticMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      NewMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStaticMeshComponent::SetStaticMesh(class UStaticMesh* NewMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStaticMesh");

	Params::StaticMeshComponent_SetStaticMesh Parms{};

	Parms.NewMesh = NewMesh;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMeshComponent.GetLocalBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMeshComponent::GetLocalBounds(struct FVector* Min, struct FVector* Max) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLocalBounds");

	Params::StaticMeshComponent_GetLocalBounds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Min != nullptr)
		*Min = std::move(Parms.Min);

	if (Max != nullptr)
		*Max = std::move(Parms.Max);
}


// Function Engine.GameMode.AbortMatch
// (Native, Public, BlueprintCallable)

void AGameMode::AbortMatch()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AbortMatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameMode.EndMatch
// (Native, Public, BlueprintCallable)

void AGameMode::EndMatch()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EndMatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameMode.K2_OnSetMatchState
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameMode::K2_OnSetMatchState(class FName NewState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnSetMatchState");

	Params::GameMode_K2_OnSetMatchState Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameMode.ReadyToEndMatch
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameMode::ReadyToEndMatch()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReadyToEndMatch");

	Params::GameMode_ReadyToEndMatch Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameMode.ReadyToStartMatch
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameMode::ReadyToStartMatch()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReadyToStartMatch");

	Params::GameMode_ReadyToStartMatch Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameMode.RestartGame
// (Native, Public, BlueprintCallable)

void AGameMode::RestartGame()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RestartGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameMode.Say
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameMode::Say(const class FString& Msg)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Say");

	Params::GameMode_Say Parms{};

	Parms.Msg = std::move(Msg);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameMode.StartMatch
// (Native, Public, BlueprintCallable)

void AGameMode::StartMatch()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartMatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameMode.GetMatchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AGameMode::GetMatchState() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMatchState");

	Params::GameMode_GetMatchState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameMode.IsMatchInProgress
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameMode::IsMatchInProgress() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsMatchInProgress");

	Params::GameMode_IsMatchInProgress Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameState.OnRep_ElapsedTime
// (Native, Public)

void AGameState::OnRep_ElapsedTime()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ElapsedTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameState.OnRep_MatchState
// (Native, Public)

void AGameState::OnRep_MatchState()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_MatchState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CameraModifier.BlueprintModifyCamera
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ViewLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ViewRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   FOV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewViewLocation                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewViewRotation                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   NewFOV                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModifier::BlueprintModifyCamera(float DeltaTime, const struct FVector& ViewLocation, const struct FRotator& ViewRotation, float FOV, struct FVector* NewViewLocation, struct FRotator* NewViewRotation, float* NewFOV)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintModifyCamera");

	Params::CameraModifier_BlueprintModifyCamera Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.ViewLocation = std::move(ViewLocation);
	Parms.ViewRotation = std::move(ViewRotation);
	Parms.FOV = FOV;

	UObject::ProcessEvent(Func, &Parms);

	if (NewViewLocation != nullptr)
		*NewViewLocation = std::move(Parms.NewViewLocation);

	if (NewViewRotation != nullptr)
		*NewViewRotation = std::move(Parms.NewViewRotation);

	if (NewFOV != nullptr)
		*NewFOV = Parms.NewFOV;
}


// Function Engine.CameraModifier.BlueprintModifyPostProcess
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PostProcessBlendWeight                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPostProcessSettings             PostProcessSettings                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void UCameraModifier::BlueprintModifyPostProcess(float DeltaTime, float* PostProcessBlendWeight, struct FPostProcessSettings* PostProcessSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintModifyPostProcess");

	Params::CameraModifier_BlueprintModifyPostProcess Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	if (PostProcessBlendWeight != nullptr)
		*PostProcessBlendWeight = Parms.PostProcessBlendWeight;

	if (PostProcessSettings != nullptr)
		*PostProcessSettings = std::move(Parms.PostProcessSettings);
}


// Function Engine.CameraModifier.DisableModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraModifier::DisableModifier(bool bImmediate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableModifier");

	Params::CameraModifier_DisableModifier Parms{};

	Parms.bImmediate = bImmediate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraModifier.EnableModifier
// (Native, Public, BlueprintCallable)

void UCameraModifier::EnableModifier()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableModifier");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CameraModifier.GetViewTarget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCameraModifier::GetViewTarget() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetViewTarget");

	Params::CameraModifier_GetViewTarget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CameraModifier.IsDisabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraModifier::IsDisabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDisabled");

	Params::CameraModifier_IsDisabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CameraShakeBase.SetRootShakePattern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCameraShakePattern*              InPattern                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraShakeBase::SetRootShakePattern(class UCameraShakePattern* InPattern)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRootShakePattern");

	Params::CameraShakeBase_SetRootShakePattern Parms{};

	Parms.InPattern = InPattern;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraShakeBase.GetRootShakePattern
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraShakePattern*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraShakePattern* UCameraShakeBase::GetRootShakePattern() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRootShakePattern");

	Params::CameraShakeBase_GetRootShakePattern Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CameraActor.GetAutoActivatePlayerIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACameraActor::GetAutoActivatePlayerIndex() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAutoActivatePlayerIndex");

	Params::CameraActor_GetAutoActivatePlayerIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.CacheInitialMeshOffset
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          MeshRelativeLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         MeshRelativeRotation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACharacter::CacheInitialMeshOffset(const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CacheInitialMeshOffset");

	Params::Character_CacheInitialMeshOffset Parms{};

	Parms.MeshRelativeLocation = std::move(MeshRelativeLocation);
	Parms.MeshRelativeRotation = std::move(MeshRelativeRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ClientAckGoodMove
// (Net, Native, Event, Public, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientAckGoodMove(float Timestamp)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientAckGoodMove");

	Params::Character_ClientAckGoodMove Parms{};

	Parms.Timestamp = Timestamp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ClientAdjustPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewLoc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewVel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              NewBase                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewBaseBoneName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientAdjustPosition(float Timestamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientAdjustPosition");

	Params::Character_ClientAdjustPosition Parms{};

	Parms.Timestamp = Timestamp;
	Parms.NewLoc = std::move(NewLoc);
	Parms.NewVel = std::move(NewVel);
	Parms.NewBase = NewBase;
	Parms.NewBaseBoneName = NewBaseBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ClientAdjustRootMotionPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerMontageTrackPosition                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerLoc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ServerRotation                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerVelZ                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ServerBase                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ServerBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientAdjustRootMotionPosition(float Timestamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientAdjustRootMotionPosition");

	Params::Character_ClientAdjustRootMotionPosition Parms{};

	Parms.Timestamp = Timestamp;
	Parms.ServerMontageTrackPosition = ServerMontageTrackPosition;
	Parms.ServerLoc = std::move(ServerLoc);
	Parms.ServerRotation = std::move(ServerRotation);
	Parms.ServerVelZ = ServerVelZ;
	Parms.ServerBase = ServerBase;
	Parms.ServerBoneName = ServerBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ClientAdjustRootMotionSourcePosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRootMotionSourceGroup           ServerRootMotion                                       (Parm, NativeAccessSpecifierPublic)
// bool                                    bHasAnimRootMotion                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerMontageTrackPosition                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ServerLoc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ServerRotation                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ServerVelZ                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ServerBase                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ServerBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientAdjustRootMotionSourcePosition(float Timestamp, const struct FRootMotionSourceGroup& ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, class FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientAdjustRootMotionSourcePosition");

	Params::Character_ClientAdjustRootMotionSourcePosition Parms{};

	Parms.Timestamp = Timestamp;
	Parms.ServerRootMotion = std::move(ServerRootMotion);
	Parms.bHasAnimRootMotion = bHasAnimRootMotion;
	Parms.ServerMontageTrackPosition = ServerMontageTrackPosition;
	Parms.ServerLoc = std::move(ServerLoc);
	Parms.ServerRotation = std::move(ServerRotation);
	Parms.ServerVelZ = ServerVelZ;
	Parms.ServerBase = ServerBase;
	Parms.ServerBoneName = ServerBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ClientCheatFly
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACharacter::ClientCheatFly()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientCheatFly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.ClientCheatGhost
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACharacter::ClientCheatGhost()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientCheatGhost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.ClientCheatWalk
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACharacter::ClientCheatWalk()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientCheatWalk");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.ClientMoveResponsePacked
// (Net, Native, Event, Public, NetClient, NetValidate)
// Parameters:
// struct FCharacterMoveResponsePackedBits PackedBits                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ACharacter::ClientMoveResponsePacked(const struct FCharacterMoveResponsePackedBits& PackedBits)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientMoveResponsePacked");

	Params::Character_ClientMoveResponsePacked Parms{};

	Parms.PackedBits = std::move(PackedBits);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ClientVeryShortAdjustPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewLoc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              NewBase                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NewBaseBoneName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBaseRelativePosition                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ServerMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ClientVeryShortAdjustPosition(float Timestamp, const struct FVector& NewLoc, class UPrimitiveComponent* NewBase, class FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClientVeryShortAdjustPosition");

	Params::Character_ClientVeryShortAdjustPosition Parms{};

	Parms.Timestamp = Timestamp;
	Parms.NewLoc = std::move(NewLoc);
	Parms.NewBase = NewBase;
	Parms.NewBaseBoneName = NewBaseBoneName;
	Parms.bHasBase = bHasBase;
	Parms.bBaseRelativePosition = bBaseRelativePosition;
	Parms.ServerMovementMode = ServerMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.Crouch
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::Crouch(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Crouch");

	Params::Character_Crouch Parms{};

	Parms.bClientSimulation = bClientSimulation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.Jump
// (Native, Public, BlueprintCallable)

void ACharacter::Jump()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Jump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.K2_OnEndCrouch
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   HalfHeightAdjust                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaledHalfHeightAdjust                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnEndCrouch");

	Params::Character_K2_OnEndCrouch Parms{};

	Parms.HalfHeightAdjust = HalfHeightAdjust;
	Parms.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.K2_OnMovementModeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           NewMovementMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PrevCustomMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewCustomMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::K2_OnMovementModeChanged(EMovementMode PrevMovementMode, EMovementMode NewMovementMode, uint8 PrevCustomMode, uint8 NewCustomMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnMovementModeChanged");

	Params::Character_K2_OnMovementModeChanged Parms{};

	Parms.PrevMovementMode = PrevMovementMode;
	Parms.NewMovementMode = NewMovementMode;
	Parms.PrevCustomMode = PrevCustomMode;
	Parms.NewCustomMode = NewCustomMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.K2_OnStartCrouch
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   HalfHeightAdjust                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaledHalfHeightAdjust                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_OnStartCrouch");

	Params::Character_K2_OnStartCrouch Parms{};

	Parms.HalfHeightAdjust = HalfHeightAdjust;
	Parms.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.K2_UpdateCustomMovement
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::K2_UpdateCustomMovement(float DeltaTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_UpdateCustomMovement");

	Params::Character_K2_UpdateCustomMovement Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.LaunchCharacter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bXYOverride                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bZOverride                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LaunchCharacter");

	Params::Character_LaunchCharacter Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.bXYOverride = bXYOverride;
	Parms.bZOverride = bZOverride;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.OnJumped
// (Native, Event, Public, BlueprintEvent)

void ACharacter::OnJumped()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnJumped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.OnLanded
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACharacter::OnLanded(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnLanded");

	Params::Character_OnLanded Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.OnLaunched
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bXYOverride                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bZOverride                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::OnLaunched(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnLaunched");

	Params::Character_OnLaunched Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.bXYOverride = bXYOverride;
	Parms.bZOverride = bZOverride;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.OnRep_IsCrouched
// (Native, Public)

void ACharacter::OnRep_IsCrouched()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_IsCrouched");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.OnRep_ReplayLastTransformUpdateTimeStamp
// (Final, Native, Public)

void ACharacter::OnRep_ReplayLastTransformUpdateTimeStamp()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplayLastTransformUpdateTimeStamp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.OnRep_ReplicatedBasedMovement
// (Native, Public)

void ACharacter::OnRep_ReplicatedBasedMovement()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedBasedMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.OnRep_RootMotion
// (Final, Native, Public)

void ACharacter::OnRep_RootMotion()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_RootMotion");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.OnWalkingOffLedge
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          PreviousFloorImpactNormal                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PreviousFloorContactNormal                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PreviousLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeDelta                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::OnWalkingOffLedge(const struct FVector& PreviousFloorImpactNormal, const struct FVector& PreviousFloorContactNormal, const struct FVector& PreviousLocation, float TimeDelta)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnWalkingOffLedge");

	Params::Character_OnWalkingOffLedge Parms{};

	Parms.PreviousFloorImpactNormal = std::move(PreviousFloorImpactNormal);
	Parms.PreviousFloorContactNormal = std::move(PreviousFloorContactNormal);
	Parms.PreviousLocation = std::move(PreviousLocation);
	Parms.TimeDelta = TimeDelta;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.PlayAnimMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSectionName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacter::PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, class FName StartSectionName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayAnimMontage");

	Params::Character_PlayAnimMontage Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.InPlayRate = InPlayRate;
	Parms.StartSectionName = StartSectionName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.RootMotionDebugClientPrintOnScreen
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::RootMotionDebugClientPrintOnScreen(const class FString& InString)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RootMotionDebugClientPrintOnScreen");

	Params::Character_RootMotionDebugClientPrintOnScreen Parms{};

	Parms.InString = std::move(InString);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ServerMove
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLoc                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   CompressedMoveFlags                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ClientMovementBase                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ClientBaseBoneName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMove(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMove");

	Params::Character_ServerMove Parms{};

	Parms.Timestamp = Timestamp;
	Parms.InAccel = std::move(InAccel);
	Parms.ClientLoc = std::move(ClientLoc);
	Parms.CompressedMoveFlags = CompressedMoveFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ServerMoveDual
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   TimeStamp0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel0                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PendingFlags                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLoc                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ClientMovementBase                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ClientBaseBoneName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMoveDual");

	Params::Character_ServerMoveDual Parms{};

	Parms.TimeStamp0 = TimeStamp0;
	Parms.InAccel0 = std::move(InAccel0);
	Parms.PendingFlags = PendingFlags;
	Parms.View0 = View0;
	Parms.Timestamp = Timestamp;
	Parms.InAccel = std::move(InAccel);
	Parms.ClientLoc = std::move(ClientLoc);
	Parms.NewFlags = NewFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ServerMoveDualHybridRootMotion
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   TimeStamp0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel0                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PendingFlags                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLoc                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ClientMovementBase                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ClientBaseBoneName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveDualHybridRootMotion(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, class FName ClientBaseBoneName, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMoveDualHybridRootMotion");

	Params::Character_ServerMoveDualHybridRootMotion Parms{};

	Parms.TimeStamp0 = TimeStamp0;
	Parms.InAccel0 = std::move(InAccel0);
	Parms.PendingFlags = PendingFlags;
	Parms.View0 = View0;
	Parms.Timestamp = Timestamp;
	Parms.InAccel = std::move(InAccel);
	Parms.ClientLoc = std::move(ClientLoc);
	Parms.NewFlags = NewFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementBase = ClientMovementBase;
	Parms.ClientBaseBoneName = ClientBaseBoneName;
	Parms.ClientMovementMode = ClientMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ServerMoveDualNoBase
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   TimeStamp0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel0                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PendingFlags                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLoc                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveDualNoBase(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMoveDualNoBase");

	Params::Character_ServerMoveDualNoBase Parms{};

	Parms.TimeStamp0 = TimeStamp0;
	Parms.InAccel0 = std::move(InAccel0);
	Parms.PendingFlags = PendingFlags;
	Parms.View0 = View0;
	Parms.Timestamp = Timestamp;
	Parms.InAccel = std::move(InAccel);
	Parms.ClientLoc = std::move(ClientLoc);
	Parms.NewFlags = NewFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementMode = ClientMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ServerMoveNoBase
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            InAccel                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLoc                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   CompressedMoveFlags                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  View                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ClientMovementMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveNoBase(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, uint8 ClientMovementMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMoveNoBase");

	Params::Character_ServerMoveNoBase Parms{};

	Parms.Timestamp = Timestamp;
	Parms.InAccel = std::move(InAccel);
	Parms.ClientLoc = std::move(ClientLoc);
	Parms.CompressedMoveFlags = CompressedMoveFlags;
	Parms.ClientRoll = ClientRoll;
	Parms.View = View;
	Parms.ClientMovementMode = ClientMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ServerMoveOld
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   OldTimeStamp                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            OldAccel                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OldMoveFlags                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::ServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, uint8 OldMoveFlags)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMoveOld");

	Params::Character_ServerMoveOld Parms{};

	Parms.OldTimeStamp = OldTimeStamp;
	Parms.OldAccel = std::move(OldAccel);
	Parms.OldMoveFlags = OldMoveFlags;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.ServerMovePacked
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FCharacterServerMovePackedBits   PackedBits                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ACharacter::ServerMovePacked(const struct FCharacterServerMovePackedBits& PackedBits)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ServerMovePacked");

	Params::Character_ServerMovePacked Parms{};

	Parms.PackedBits = std::move(PackedBits);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.StopAnimMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::StopAnimMontage(class UAnimMontage* AnimMontage)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAnimMontage");

	Params::Character_StopAnimMontage Parms{};

	Parms.AnimMontage = AnimMontage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.StopJumping
// (Native, Public, BlueprintCallable)

void ACharacter::StopJumping()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopJumping");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Character.UnCrouch
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClientSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacter::UnCrouch(bool bClientSimulation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UnCrouch");

	Params::Character_UnCrouch Parms{};

	Parms.bClientSimulation = bClientSimulation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Character.CanCrouch
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::CanCrouch() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanCrouch");

	Params::Character_CanCrouch Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.CanJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::CanJump() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanJump");

	Params::Character_CanJump Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.CanJumpInternal
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::CanJumpInternal() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanJumpInternal");

	Params::Character_CanJumpInternal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.GetAnimRootMotionTranslationScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACharacter::GetAnimRootMotionTranslationScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnimRootMotionTranslationScale");

	Params::Character_GetAnimRootMotionTranslationScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.GetBaseRotationOffsetRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ACharacter::GetBaseRotationOffsetRotator() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBaseRotationOffsetRotator");

	Params::Character_GetBaseRotationOffsetRotator Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.GetBaseTranslationOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACharacter::GetBaseTranslationOffset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBaseTranslationOffset");

	Params::Character_GetBaseTranslationOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.GetCurrentMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ACharacter::GetCurrentMontage() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentMontage");

	Params::Character_GetCurrentMontage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.HasAnyRootMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::HasAnyRootMotion() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasAnyRootMotion");

	Params::Character_HasAnyRootMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.IsJumpProvidingForce
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::IsJumpProvidingForce() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsJumpProvidingForce");

	Params::Character_IsJumpProvidingForce Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.IsPlayingNetworkedRootMotionMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::IsPlayingNetworkedRootMotionMontage() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlayingNetworkedRootMotionMontage");

	Params::Character_IsPlayingNetworkedRootMotionMontage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Character.IsPlayingRootMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacter::IsPlayingRootMotion() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlayingRootMotion");

	Params::Character_IsPlayingRootMotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0
// (Native, Public)

void ASkeletalMeshActor::OnRep_ReplicatedMaterial0()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedMaterial0");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1
// (Native, Public)

void ASkeletalMeshActor::OnRep_ReplicatedMaterial1()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedMaterial1");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh
// (Native, Public)

void ASkeletalMeshActor::OnRep_ReplicatedMesh()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset
// (Native, Public)

void ASkeletalMeshActor::OnRep_ReplicatedPhysAsset()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ReplicatedPhysAsset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AnimationAsset.GetPlayLength
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimationAsset::GetPlayLength() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayLength");

	Params::AnimationAsset_GetPlayLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimecodeProvider.FetchAndUpdate
// (Native, Public, BlueprintCallable)

void UTimecodeProvider::FetchAndUpdate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FetchAndUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.TimecodeProvider.FetchTimecode
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FQualifiedFrameTime              OutFrameTime                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimecodeProvider::FetchTimecode(struct FQualifiedFrameTime* OutFrameTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FetchTimecode");

	Params::TimecodeProvider_FetchTimecode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutFrameTime != nullptr)
		*OutFrameTime = std::move(Parms.OutFrameTime);

	return Parms.ReturnValue;
}


// Function Engine.TimecodeProvider.GetDelayedQualifiedFrameTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FQualifiedFrameTime              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQualifiedFrameTime UTimecodeProvider::GetDelayedQualifiedFrameTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDelayedQualifiedFrameTime");

	Params::TimecodeProvider_GetDelayedQualifiedFrameTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimecodeProvider.GetDelayedTimecode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimecode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimecode UTimecodeProvider::GetDelayedTimecode() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDelayedTimecode");

	Params::TimecodeProvider_GetDelayedTimecode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimecodeProvider.GetFrameRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFrameRate                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFrameRate UTimecodeProvider::GetFrameRate() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFrameRate");

	Params::TimecodeProvider_GetFrameRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimecodeProvider.GetQualifiedFrameTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FQualifiedFrameTime              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQualifiedFrameTime UTimecodeProvider::GetQualifiedFrameTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetQualifiedFrameTime");

	Params::TimecodeProvider_GetQualifiedFrameTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimecodeProvider.GetSynchronizationState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETimecodeProviderSynchronizationState   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETimecodeProviderSynchronizationState UTimecodeProvider::GetSynchronizationState() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSynchronizationState");

	Params::TimecodeProvider_GetSynchronizationState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimecodeProvider.GetTimecode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimecode                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimecode UTimecodeProvider::GetTimecode() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTimecode");

	Params::TimecodeProvider_GetTimecode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.AddInstance
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       InstanceTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWorldSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInstancedStaticMeshComponent::AddInstance(const struct FTransform& InstanceTransform, bool bWorldSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddInstance");

	Params::InstancedStaticMeshComponent_AddInstance Parms{};

	Parms.InstanceTransform = std::move(InstanceTransform);
	Parms.bWorldSpace = bWorldSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.AddInstances
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FTransform>               InstanceTransforms                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bShouldReturnIndices                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWorldSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UInstancedStaticMeshComponent::AddInstances(const TArray<struct FTransform>& InstanceTransforms, bool bShouldReturnIndices, bool bWorldSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddInstances");

	Params::InstancedStaticMeshComponent_AddInstances Parms{};

	Parms.InstanceTransforms = std::move(InstanceTransforms);
	Parms.bShouldReturnIndices = bShouldReturnIndices;
	Parms.bWorldSpace = bWorldSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       WorldTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInstancedStaticMeshComponent::AddInstanceWorldSpace(const struct FTransform& WorldTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddInstanceWorldSpace");

	Params::InstancedStaticMeshComponent_AddInstanceWorldSpace Parms{};

	Parms.WorldTransform = std::move(WorldTransform);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   StartInstanceIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumInstances                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       NewInstancesTransform                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWorldSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMarkRenderStateDirty                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::BatchUpdateInstancesTransform(int32 StartInstanceIndex, int32 NumInstances, const struct FTransform& NewInstancesTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BatchUpdateInstancesTransform");

	Params::InstancedStaticMeshComponent_BatchUpdateInstancesTransform Parms{};

	Parms.StartInstanceIndex = StartInstanceIndex;
	Parms.NumInstances = NumInstances;
	Parms.NewInstancesTransform = std::move(NewInstancesTransform);
	Parms.bWorldSpace = bWorldSpace;
	Parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransforms
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   StartInstanceIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               NewInstancesTransforms                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWorldSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMarkRenderStateDirty                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::BatchUpdateInstancesTransforms(int32 StartInstanceIndex, const TArray<struct FTransform>& NewInstancesTransforms, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BatchUpdateInstancesTransforms");

	Params::InstancedStaticMeshComponent_BatchUpdateInstancesTransforms Parms{};

	Parms.StartInstanceIndex = StartInstanceIndex;
	Parms.NewInstancesTransforms = std::move(NewInstancesTransforms);
	Parms.bWorldSpace = bWorldSpace;
	Parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.ClearInstances
// (Native, Public, BlueprintCallable)

void UInstancedStaticMeshComponent::ClearInstances()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearInstances");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.InstancedStaticMeshComponent.RemoveInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::RemoveInstance(int32 InstanceIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveInstance");

	Params::InstancedStaticMeshComponent_RemoveInstance Parms{};

	Parms.InstanceIndex = InstanceIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.RemoveInstances
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           InstancesToRemove                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::RemoveInstances(const TArray<int32>& InstancesToRemove)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveInstances");

	Params::InstancedStaticMeshComponent_RemoveInstances Parms{};

	Parms.InstancesToRemove = std::move(InstancesToRemove);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.SetCullDistances
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   StartCullDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndCullDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInstancedStaticMeshComponent::SetCullDistances(int32 StartCullDistance, int32 EndCullDistance)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCullDistances");

	Params::InstancedStaticMeshComponent_SetCullDistances Parms{};

	Parms.StartCullDistance = StartCullDistance;
	Parms.EndCullDistance = EndCullDistance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.InstancedStaticMeshComponent.SetCustomDataValue
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CustomDataIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CustomDataValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMarkRenderStateDirty                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::SetCustomDataValue(int32 InstanceIndex, int32 CustomDataIndex, float CustomDataValue, bool bMarkRenderStateDirty)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCustomDataValue");

	Params::InstancedStaticMeshComponent_SetCustomDataValue Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.CustomDataIndex = CustomDataIndex;
	Parms.CustomDataValue = CustomDataValue;
	Parms.bMarkRenderStateDirty = bMarkRenderStateDirty;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       NewInstanceTransform                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWorldSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMarkRenderStateDirty                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTeleport                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::UpdateInstanceTransform(int32 InstanceIndex, const struct FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateInstanceTransform");

	Params::InstancedStaticMeshComponent_UpdateInstanceTransform Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.NewInstanceTransform = std::move(NewInstanceTransform);
	Parms.bWorldSpace = bWorldSpace;
	Parms.bMarkRenderStateDirty = bMarkRenderStateDirty;
	Parms.bTeleport = bTeleport;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.GetInstanceCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInstancedStaticMeshComponent::GetInstanceCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceCount");

	Params::InstancedStaticMeshComponent_GetInstanceCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingBox
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bBoxInWorldSpace                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UInstancedStaticMeshComponent::GetInstancesOverlappingBox(const struct FBox& Box, bool bBoxInWorldSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstancesOverlappingBox");

	Params::InstancedStaticMeshComponent_GetInstancesOverlappingBox Parms{};

	Parms.Box = std::move(Box);
	Parms.bBoxInWorldSpace = bBoxInWorldSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSphereInWorldSpace                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UInstancedStaticMeshComponent::GetInstancesOverlappingSphere(const struct FVector& Center, float Radius, bool bSphereInWorldSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstancesOverlappingSphere");

	Params::InstancedStaticMeshComponent_GetInstancesOverlappingSphere Parms{};

	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.bSphereInWorldSpace = bSphereInWorldSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.GetInstanceTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutInstanceTransform                                   (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWorldSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::GetInstanceTransform(int32 InstanceIndex, struct FTransform* OutInstanceTransform, bool bWorldSpace) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInstanceTransform");

	Params::InstancedStaticMeshComponent_GetInstanceTransform Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.bWorldSpace = bWorldSpace;

	UObject::ProcessEvent(Func, &Parms);

	if (OutInstanceTransform != nullptr)
		*OutInstanceTransform = std::move(Parms.OutInstanceTransform);

	return Parms.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.IsValidInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInstancedStaticMeshComponent::IsValidInstance(int32 InstanceIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsValidInstance");

	Params::InstancedStaticMeshComponent_IsValidInstance Parms{};

	Parms.InstanceIndex = InstanceIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SceneCaptureComponent.ClearHiddenComponents
// (Final, Native, Public, BlueprintCallable)

void USceneCaptureComponent::ClearHiddenComponents()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearHiddenComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneCaptureComponent.ClearShowOnlyComponents
// (Final, Native, Public, BlueprintCallable)

void USceneCaptureComponent::ClearShowOnlyComponents()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearShowOnlyComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneCaptureComponent.HideActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeFromChildActors                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::HideActorComponents(class AActor* InActor, const bool bIncludeFromChildActors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HideActorComponents");

	Params::SceneCaptureComponent_HideActorComponents Parms{};

	Parms.InActor = InActor;
	Parms.bIncludeFromChildActors = bIncludeFromChildActors;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponent.HideComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::HideComponent(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HideComponent");

	Params::SceneCaptureComponent_HideComponent Parms{};

	Parms.InComponent = InComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponent.RemoveShowOnlyActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeFromChildActors                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::RemoveShowOnlyActorComponents(class AActor* InActor, const bool bIncludeFromChildActors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveShowOnlyActorComponents");

	Params::SceneCaptureComponent_RemoveShowOnlyActorComponents Parms{};

	Parms.InActor = InActor;
	Parms.bIncludeFromChildActors = bIncludeFromChildActors;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponent.RemoveShowOnlyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::RemoveShowOnlyComponent(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveShowOnlyComponent");

	Params::SceneCaptureComponent_RemoveShowOnlyComponent Parms{};

	Parms.InComponent = InComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponent.SetCaptureSortPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewCaptureSortPriority                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::SetCaptureSortPriority(int32 NewCaptureSortPriority)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCaptureSortPriority");

	Params::SceneCaptureComponent_SetCaptureSortPriority Parms{};

	Parms.NewCaptureSortPriority = NewCaptureSortPriority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponent.ShowOnlyActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeFromChildActors                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::ShowOnlyActorComponents(class AActor* InActor, const bool bIncludeFromChildActors)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowOnlyActorComponents");

	Params::SceneCaptureComponent_ShowOnlyActorComponents Parms{};

	Parms.InActor = InActor;
	Parms.bIncludeFromChildActors = bIncludeFromChildActors;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponent.ShowOnlyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              InComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent::ShowOnlyComponent(class UPrimitiveComponent* InComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowOnlyComponent");

	Params::SceneCaptureComponent_ShowOnlyComponent Parms{};

	Parms.InComponent = InComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent2D::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddOrUpdateBlendable");

	Params::SceneCaptureComponent2D_AddOrUpdateBlendable Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponent2D.CaptureScene
// (Final, Native, Public, BlueprintCallable)

void USceneCaptureComponent2D::CaptureScene()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CaptureScene");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneCaptureComponent2D.RemoveBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USceneCaptureComponent2D::RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveBlendable");

	Params::SceneCaptureComponent2D_RemoveBlendable Parms{};

	Parms.InBlendableObject = InBlendableObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCanvas*                          Canvas                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Size                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDrawToRenderTargetContext       Context                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::BeginDrawCanvasToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UCanvas** Canvas, struct FVector2D* Size, struct FDrawToRenderTargetContext* Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BeginDrawCanvasToRenderTarget");

	Params::KismetRenderingLibrary_BeginDrawCanvasToRenderTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Canvas != nullptr)
		*Canvas = Parms.Canvas;

	if (Size != nullptr)
		*Size = std::move(Parms.Size);

	if (Context != nullptr)
		*Context = std::move(Parms.Context);
}


// Function Engine.KismetRenderingLibrary.BreakSkinWeightInfo
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSkelMeshSkinWeightInfo          InWeight                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Bone0                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bone1                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight1                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bone2                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight2                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bone3                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight3                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::BreakSkinWeightInfo(const struct FSkelMeshSkinWeightInfo& InWeight, int32* Bone0, uint8* Weight0, int32* Bone1, uint8* Weight1, int32* Bone2, uint8* Weight2, int32* Bone3, uint8* Weight3)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakSkinWeightInfo");

	Params::KismetRenderingLibrary_BreakSkinWeightInfo Parms{};

	Parms.InWeight = std::move(InWeight);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Bone0 != nullptr)
		*Bone0 = Parms.Bone0;

	if (Weight0 != nullptr)
		*Weight0 = Parms.Weight0;

	if (Bone1 != nullptr)
		*Bone1 = Parms.Bone1;

	if (Weight1 != nullptr)
		*Weight1 = Parms.Weight1;

	if (Bone2 != nullptr)
		*Bone2 = Parms.Bone2;

	if (Weight2 != nullptr)
		*Weight2 = Parms.Weight2;

	if (Bone3 != nullptr)
		*Bone3 = Parms.Bone3;

	if (Weight3 != nullptr)
		*Weight3 = Parms.Weight3;
}


// Function Engine.KismetRenderingLibrary.CalculateProjectionMatrix
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMinimalViewInfo                 MinimalViewInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetRenderingLibrary::CalculateProjectionMatrix(const struct FMinimalViewInfo& MinimalViewInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CalculateProjectionMatrix");

	Params::KismetRenderingLibrary_CalculateProjectionMatrix Parms{};

	Parms.MinimalViewInfo = std::move(MinimalViewInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ClearRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ClearColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ClearRenderTarget2D(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const struct FLinearColor& ClearColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClearRenderTarget2D");

	Params::KismetRenderingLibrary_ClearRenderTarget2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.ClearColor = std::move(ClearColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ConvertRenderTargetToTexture2DEditorOnly(class UObject* WorldContextObject, class UTextureRenderTarget2D* RenderTarget, class UTexture2D* Texture)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertRenderTargetToTexture2DEditorOnly");

	Params::KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RenderTarget = RenderTarget;
	Parms.Texture = Texture;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetRenderingLibrary.CreateRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextureRenderTargetFormat              Format                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ClearColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoGenerateMipMaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* UKismetRenderingLibrary::CreateRenderTarget2D(class UObject* WorldContextObject, int32 Width, int32 Height, ETextureRenderTargetFormat Format, const struct FLinearColor& ClearColor, bool bAutoGenerateMipMaps)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateRenderTarget2D");

	Params::KismetRenderingLibrary_CreateRenderTarget2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.Format = Format;
	Parms.ClearColor = std::move(ClearColor);
	Parms.bAutoGenerateMipMaps = bAutoGenerateMipMaps;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.CreateRenderTarget2DArray
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Slices                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextureRenderTargetFormat              Format                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ClearColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoGenerateMipMaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2DArray*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2DArray* UKismetRenderingLibrary::CreateRenderTarget2DArray(class UObject* WorldContextObject, int32 Width, int32 Height, int32 Slices, ETextureRenderTargetFormat Format, const struct FLinearColor& ClearColor, bool bAutoGenerateMipMaps)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateRenderTarget2DArray");

	Params::KismetRenderingLibrary_CreateRenderTarget2DArray Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.Slices = Slices;
	Parms.Format = Format;
	Parms.ClearColor = std::move(ClearColor);
	Parms.bAutoGenerateMipMaps = bAutoGenerateMipMaps;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.CreateRenderTargetVolume
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Depth                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextureRenderTargetFormat              Format                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ClearColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoGenerateMipMaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTargetVolume*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTargetVolume* UKismetRenderingLibrary::CreateRenderTargetVolume(class UObject* WorldContextObject, int32 Width, int32 Height, int32 Depth, ETextureRenderTargetFormat Format, const struct FLinearColor& ClearColor, bool bAutoGenerateMipMaps)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateRenderTargetVolume");

	Params::KismetRenderingLibrary_CreateRenderTargetVolume Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.Depth = Depth;
	Parms.Format = Format;
	Parms.ClearColor = std::move(ClearColor);
	Parms.bAutoGenerateMipMaps = bAutoGenerateMipMaps;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::DrawMaterialToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawMaterialToRenderTarget");

	Params::KismetRenderingLibrary_DrawMaterialToRenderTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.Material = Material;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDrawToRenderTargetContext       Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::EndDrawCanvasToRenderTarget(class UObject* WorldContextObject, const struct FDrawToRenderTargetContext& Context)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EndDrawCanvasToRenderTarget");

	Params::KismetRenderingLibrary_EndDrawCanvasToRenderTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Context = std::move(Context);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetRenderingLibrary.ExportRenderTarget
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ExportRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const class FString& FilePath, const class FString& Filename)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ExportRenderTarget");

	Params::KismetRenderingLibrary_ExportRenderTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.FilePath = std::move(FilePath);
	Parms.Filename = std::move(Filename);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetRenderingLibrary.ExportTexture2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ExportTexture2D(class UObject* WorldContextObject, class UTexture2D* Texture, const class FString& FilePath, const class FString& Filename)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ExportTexture2D");

	Params::KismetRenderingLibrary_ExportTexture2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Texture = Texture;
	Parms.FilePath = std::move(FilePath);
	Parms.Filename = std::move(Filename);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetRenderingLibrary.ImportBufferAsTexture2D
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           Buffer                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UKismetRenderingLibrary::ImportBufferAsTexture2D(class UObject* WorldContextObject, const TArray<uint8>& Buffer)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ImportBufferAsTexture2D");

	Params::KismetRenderingLibrary_ImportBufferAsTexture2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Buffer = std::move(Buffer);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ImportFileAsTexture2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UKismetRenderingLibrary::ImportFileAsTexture2D(class UObject* WorldContextObject, const class FString& Filename)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ImportFileAsTexture2D");

	Params::KismetRenderingLibrary_ImportFileAsTexture2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Filename = std::move(Filename);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.MakeSkinWeightInfo
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Bone0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bone1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight1                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bone2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight2                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bone3                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Weight3                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSkelMeshSkinWeightInfo          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSkelMeshSkinWeightInfo UKismetRenderingLibrary::MakeSkinWeightInfo(int32 Bone0, uint8 Weight0, int32 Bone1, uint8 Weight1, int32 Bone2, uint8 Weight2, int32 Bone3, uint8 Weight3)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeSkinWeightInfo");

	Params::KismetRenderingLibrary_MakeSkinWeightInfo Parms{};

	Parms.Bone0 = Bone0;
	Parms.Weight0 = Weight0;
	Parms.Bone1 = Bone1;
	Parms.Weight1 = Weight1;
	Parms.Bone2 = Bone2;
	Parms.Weight2 = Weight2;
	Parms.Bone3 = Bone3;
	Parms.Weight3 = Weight3;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTarget
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FColor>                   OutSamples                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bNormalize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetRenderingLibrary::ReadRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, TArray<struct FColor>* OutSamples, bool bNormalize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReadRenderTarget");

	Params::KismetRenderingLibrary_ReadRenderTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.bNormalize = bNormalize;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutSamples != nullptr)
		*OutSamples = std::move(Parms.OutSamples);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetPixel
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetRenderingLibrary::ReadRenderTargetPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 X, int32 Y)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReadRenderTargetPixel");

	Params::KismetRenderingLibrary_ReadRenderTargetPixel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.X = X;
	Parms.Y = Y;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRaw
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>             OutLinearSamples                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bNormalize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetRenderingLibrary::ReadRenderTargetRaw(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, TArray<struct FLinearColor>* OutLinearSamples, bool bNormalize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReadRenderTargetRaw");

	Params::KismetRenderingLibrary_ReadRenderTargetRaw Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.bNormalize = bNormalize;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLinearSamples != nullptr)
		*OutLinearSamples = std::move(Parms.OutLinearSamples);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixel
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNormalize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetRenderingLibrary::ReadRenderTargetRawPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 X, int32 Y, bool bNormalize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReadRenderTargetRawPixel");

	Params::KismetRenderingLibrary_ReadRenderTargetRawPixel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.X = X;
	Parms.Y = Y;
	Parms.bNormalize = bNormalize;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixelArea
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNormalize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLinearColor> UKismetRenderingLibrary::ReadRenderTargetRawPixelArea(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 MinX, int32 MinY, int32 MaxX, int32 MaxY, bool bNormalize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReadRenderTargetRawPixelArea");

	Params::KismetRenderingLibrary_ReadRenderTargetRawPixelArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.MinX = MinX;
	Parms.MinY = MinY;
	Parms.MaxX = MaxX;
	Parms.MaxY = MaxY;
	Parms.bNormalize = bNormalize;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUV
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   U                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNormalize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetRenderingLibrary::ReadRenderTargetRawUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V, bool bNormalize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReadRenderTargetRawUV");

	Params::KismetRenderingLibrary_ReadRenderTargetRawUV Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.U = U;
	Parms.V = V;
	Parms.bNormalize = bNormalize;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUVArea
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           Area                                                   (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bNormalize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLinearColor> UKismetRenderingLibrary::ReadRenderTargetRawUVArea(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const struct FBox2D& Area, bool bNormalize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReadRenderTargetRawUVArea");

	Params::KismetRenderingLibrary_ReadRenderTargetRawUVArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.Area = std::move(Area);
	Parms.bNormalize = bNormalize;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetUV
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   U                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetRenderingLibrary::ReadRenderTargetUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReadRenderTargetUV");

	Params::KismetRenderingLibrary_ReadRenderTargetUV Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextureRenderTarget = TextureRenderTarget;
	Parms.U = U;
	Parms.V = V;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           TextureRenderTarget                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::ReleaseRenderTarget2D(class UTextureRenderTarget2D* TextureRenderTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReleaseRenderTarget2D");

	Params::KismetRenderingLibrary_ReleaseRenderTarget2D Parms{};

	Parms.TextureRenderTarget = TextureRenderTarget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextureCompressionSettings             CompressionSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETextureMipGenSettings                  MipSettings                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UKismetRenderingLibrary::RenderTargetCreateStaticTexture2DEditorOnly(class UTextureRenderTarget2D* RenderTarget, const class FString& Name_0, ETextureCompressionSettings CompressionSettings, ETextureMipGenSettings MipSettings)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RenderTargetCreateStaticTexture2DEditorOnly");

	Params::KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly Parms{};

	Parms.RenderTarget = RenderTarget;
	Parms.Name_0 = std::move(Name_0);
	Parms.CompressionSettings = CompressionSettings;
	Parms.MipSettings = MipSettings;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.SetCastInsetShadowForAllAttachments
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCastInsetShadow                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLightAttachmentsAsGroup                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetRenderingLibrary::SetCastInsetShadowForAllAttachments(class UPrimitiveComponent* PrimitiveComponent, bool bCastInsetShadow, bool bLightAttachmentsAsGroup)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetCastInsetShadowForAllAttachments");

	Params::KismetRenderingLibrary_SetCastInsetShadowForAllAttachments Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.bCastInsetShadow = bCastInsetShadow;
	Parms.bLightAttachmentsAsGroup = bLightAttachmentsAsGroup;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovementComponent*               MovementComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAvoidanceManager::GetAvoidanceVelocityForComponent(class UMovementComponent* MovementComp)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAvoidanceVelocityForComponent");

	Params::AvoidanceManager_GetAvoidanceVelocityForComponent Parms{};

	Parms.MovementComp = MovementComp;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AvoidanceManager.GetNewAvoidanceUID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAvoidanceManager::GetNewAvoidanceUID()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNewAvoidanceUID");

	Params::AvoidanceManager_GetNewAvoidanceUID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AvoidanceManager.GetObjectCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAvoidanceManager::GetObjectCount()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetObjectCount");

	Params::AvoidanceManager_GetObjectCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AvoidanceManager.RegisterMovementComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMovementComponent*               MovementComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AvoidanceWeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAvoidanceManager::RegisterMovementComponent(class UMovementComponent* MovementComp, float AvoidanceWeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegisterMovementComponent");

	Params::AvoidanceManager_RegisterMovementComponent Parms{};

	Parms.MovementComp = MovementComp;
	Parms.AvoidanceWeight = AvoidanceWeight;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ChildActorComponent.SetChildActorClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChildActorComponent::SetChildActorClass(TSubclassOf<class AActor> InClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetChildActorClass");

	Params::ChildActorComponent_SetChildActorClass Parms{};

	Parms.InClass = InClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LevelScriptActor.LevelReset
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)

void ALevelScriptActor::LevelReset()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LevelReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.LevelScriptActor.RemoteEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelScriptActor::RemoteEvent(class FName EventName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoteEvent");

	Params::LevelScriptActor_RemoteEvent Parms{};

	Parms.EventName = EventName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelScriptActor.SetCinematicMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCinematicMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidePlayer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsHUD                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsMovement                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAffectsTurning                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelScriptActor::SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCinematicMode");

	Params::LevelScriptActor_SetCinematicMode Parms{};

	Parms.bCinematicMode = bCinematicMode;
	Parms.bHidePlayer = bHidePlayer;
	Parms.bAffectsHUD = bAffectsHUD;
	Parms.bAffectsMovement = bAffectsMovement;
	Parms.bAffectsTurning = bAffectsTurning;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LevelScriptActor.WorldOriginLocationChanged
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FIntVector                       OldOriginLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       NewOriginLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelScriptActor::WorldOriginLocationChanged(const struct FIntVector& OldOriginLocation, const struct FIntVector& NewOriginLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WorldOriginLocationChanged");

	Params::LevelScriptActor_WorldOriginLocationChanged Parms{};

	Parms.OldOriginLocation = std::move(OldOriginLocation);
	Parms.NewOriginLocation = std::move(NewOriginLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Predefined Function
// Gets a pointer to the current World of the GameViewport

class UWorld* UWorld::GetWorld()
{
	if constexpr (Offsets::GWorld != 0)
		return *reinterpret_cast<UWorld**>(InSDKUtils::GetImageBase() + Offsets::GWorld);

	if (UEngine* Engine = UEngine::GetEngine())
	{
		if (!Engine->GameViewport)
			return nullptr;

		return Engine->GameViewport->World;
	}

	return nullptr;
}


// Function Engine.World.HandleTimelineScrubbed
// (Final, Native, Public)

void UWorld::HandleTimelineScrubbed()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleTimelineScrubbed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.World.K2_GetWorldSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWorldSettings*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWorldSettings* UWorld::K2_GetWorldSettings()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetWorldSettings");

	Params::World_K2_GetWorldSettings Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerInput.ClearSmoothing
// (Final, Exec, Native, Public)

void UPlayerInput::ClearSmoothing()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearSmoothing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerInput.InvertAxis
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             AxisName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInput::InvertAxis(const class FName AxisName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InvertAxis");

	Params::PlayerInput_InvertAxis Parms{};

	Parms.AxisName = AxisName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerInput.InvertAxisKey
// (Final, Exec, Native, Public)
// Parameters:
// struct FKey                             AxisKey                                                (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInput::InvertAxisKey(const struct FKey& AxisKey)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InvertAxisKey");

	Params::PlayerInput_InvertAxisKey Parms{};

	Parms.AxisKey = std::move(AxisKey);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerInput.SetBind
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             BindName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInput::SetBind(class FName BindName, const class FString& Command)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBind");

	Params::PlayerInput_SetBind Parms{};

	Parms.BindName = BindName;
	Parms.Command = std::move(Command);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerInput.SetMouseSensitivity
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Sensitivity                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInput::SetMouseSensitivity(const float Sensitivity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMouseSensitivity");

	Params::PlayerInput_SetMouseSensitivity Parms{};

	Parms.Sensitivity = Sensitivity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.BeginTrails
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InFirstSocketName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSecondSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         InWidthMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWidth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::BeginTrails(class FName InFirstSocketName, class FName InSecondSocketName, ETrailWidthMode InWidthMode, float InWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BeginTrails");

	Params::ParticleSystemComponent_BeginTrails Parms{};

	Parms.InFirstSocketName = InFirstSocketName;
	Parms.InSecondSocketName = InSecondSocketName;
	Parms.InWidthMode = InWidthMode;
	Parms.InWidth = InWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               SourceMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* UParticleSystemComponent::CreateNamedDynamicMaterialInstance(class FName InName, class UMaterialInterface* SourceMaterial)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreateNamedDynamicMaterialInstance");

	Params::ParticleSystemComponent_CreateNamedDynamicMaterialInstance Parms{};

	Parms.InName = InName;
	Parms.SourceMaterial = SourceMaterial;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.EndTrails
// (Final, Native, Public, BlueprintCallable)

void UParticleSystemComponent::EndTrails()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EndTrails");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ParticleSystemComponent.GenerateParticleEvent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             InEventName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InEmitterTime                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InDirection                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InVelocity                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::GenerateParticleEvent(const class FName InEventName, const float InEmitterTime, const struct FVector& InLocation, const struct FVector& InDirection, const struct FVector& InVelocity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GenerateParticleEvent");

	Params::ParticleSystemComponent_GenerateParticleEvent Parms{};

	Parms.InEventName = InEventName;
	Parms.InEmitterTime = InEmitterTime;
	Parms.InLocation = std::move(InLocation);
	Parms.InDirection = std::move(InDirection);
	Parms.InVelocity = std::move(InVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetAutoAttachParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetAutoAttachParams(class USceneComponent* Parent, class FName SocketName, EAttachLocation LocationType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAutoAttachParams");

	Params::ParticleSystemComponent_SetAutoAttachParams Parms{};

	Parms.Parent = Parent;
	Parms.SocketName = SocketName;
	Parms.LocationType = LocationType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetBeamEndPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewEndPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamEndPoint(int32 EmitterIndex, const struct FVector& NewEndPoint)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBeamEndPoint");

	Params::ParticleSystemComponent_SetBeamEndPoint Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewEndPoint = std::move(NewEndPoint);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetBeamSourcePoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewSourcePoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamSourcePoint(int32 EmitterIndex, const struct FVector& NewSourcePoint, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBeamSourcePoint");

	Params::ParticleSystemComponent_SetBeamSourcePoint Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewSourcePoint = std::move(NewSourcePoint);
	Parms.SourceIndex = SourceIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetBeamSourceStrength
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewSourceStrength                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamSourceStrength(int32 EmitterIndex, float NewSourceStrength, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBeamSourceStrength");

	Params::ParticleSystemComponent_SetBeamSourceStrength Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewSourceStrength = NewSourceStrength;
	Parms.SourceIndex = SourceIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetBeamSourceTangent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTangentPoint                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamSourceTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 SourceIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBeamSourceTangent");

	Params::ParticleSystemComponent_SetBeamSourceTangent Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTangentPoint = std::move(NewTangentPoint);
	Parms.SourceIndex = SourceIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetBeamTargetPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTargetPoint                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamTargetPoint(int32 EmitterIndex, const struct FVector& NewTargetPoint, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBeamTargetPoint");

	Params::ParticleSystemComponent_SetBeamTargetPoint Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTargetPoint = std::move(NewTargetPoint);
	Parms.TargetIndex = TargetIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetBeamTargetStrength
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewTargetStrength                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamTargetStrength(int32 EmitterIndex, float NewTargetStrength, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBeamTargetStrength");

	Params::ParticleSystemComponent_SetBeamTargetStrength Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTargetStrength = NewTargetStrength;
	Parms.TargetIndex = TargetIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetBeamTargetTangent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewTangentPoint                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetBeamTargetTangent(int32 EmitterIndex, const struct FVector& NewTangentPoint, int32 TargetIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBeamTargetTangent");

	Params::ParticleSystemComponent_SetBeamTargetTangent Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.NewTangentPoint = std::move(NewTangentPoint);
	Parms.TargetIndex = TargetIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetMaterialParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetMaterialParameter(class FName ParameterName, class UMaterialInterface* Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaterialParameter");

	Params::ParticleSystemComponent_SetMaterialParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetTemplate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystem*                  NewTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetTemplate(class UParticleSystem* NewTemplate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTemplate");

	Params::ParticleSystemComponent_SetTemplate Parms{};

	Parms.NewTemplate = NewTemplate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.SetTrailSourceData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InFirstSocketName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSecondSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         InWidthMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWidth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleSystemComponent::SetTrailSourceData(class FName InFirstSocketName, class FName InSecondSocketName, ETrailWidthMode InWidthMode, float InWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTrailSourceData");

	Params::ParticleSystemComponent_SetTrailSourceData Parms{};

	Parms.InFirstSocketName = InFirstSocketName;
	Parms.InSecondSocketName = InSecondSocketName;
	Parms.InWidthMode = InWidthMode;
	Parms.InWidth = InWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ParticleSystemComponent.GetBeamEndPoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutEndPoint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamEndPoint(int32 EmitterIndex, struct FVector* OutEndPoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBeamEndPoint");

	Params::ParticleSystemComponent_GetBeamEndPoint Parms{};

	Parms.EmitterIndex = EmitterIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutEndPoint != nullptr)
		*OutEndPoint = std::move(Parms.OutEndPoint);

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamSourcePoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutSourcePoint                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamSourcePoint(int32 EmitterIndex, int32 SourceIndex, struct FVector* OutSourcePoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBeamSourcePoint");

	Params::ParticleSystemComponent_GetBeamSourcePoint Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.SourceIndex = SourceIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutSourcePoint != nullptr)
		*OutSourcePoint = std::move(Parms.OutSourcePoint);

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamSourceStrength
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutSourceStrength                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamSourceStrength(int32 EmitterIndex, int32 SourceIndex, float* OutSourceStrength) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBeamSourceStrength");

	Params::ParticleSystemComponent_GetBeamSourceStrength Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.SourceIndex = SourceIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutSourceStrength != nullptr)
		*OutSourceStrength = Parms.OutSourceStrength;

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamSourceTangent
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SourceIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutTangentPoint                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamSourceTangent(int32 EmitterIndex, int32 SourceIndex, struct FVector* OutTangentPoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBeamSourceTangent");

	Params::ParticleSystemComponent_GetBeamSourceTangent Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.SourceIndex = SourceIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutTangentPoint != nullptr)
		*OutTangentPoint = std::move(Parms.OutTangentPoint);

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamTargetPoint
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutTargetPoint                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamTargetPoint(int32 EmitterIndex, int32 TargetIndex, struct FVector* OutTargetPoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBeamTargetPoint");

	Params::ParticleSystemComponent_GetBeamTargetPoint Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.TargetIndex = TargetIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutTargetPoint != nullptr)
		*OutTargetPoint = std::move(Parms.OutTargetPoint);

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamTargetStrength
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTargetStrength                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamTargetStrength(int32 EmitterIndex, int32 TargetIndex, float* OutTargetStrength) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBeamTargetStrength");

	Params::ParticleSystemComponent_GetBeamTargetStrength Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.TargetIndex = TargetIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutTargetStrength != nullptr)
		*OutTargetStrength = Parms.OutTargetStrength;

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamTargetTangent
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   EmitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TargetIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutTangentPoint                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystemComponent::GetBeamTargetTangent(int32 EmitterIndex, int32 TargetIndex, struct FVector* OutTangentPoint) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBeamTargetTangent");

	Params::ParticleSystemComponent_GetBeamTargetTangent Parms{};

	Parms.EmitterIndex = EmitterIndex;
	Parms.TargetIndex = TargetIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (OutTangentPoint != nullptr)
		*OutTangentPoint = std::move(Parms.OutTangentPoint);

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetNamedMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UParticleSystemComponent::GetNamedMaterial(class FName InName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNamedMaterial");

	Params::ParticleSystemComponent_GetNamedMaterial Parms{};

	Parms.InName = InName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetNumActiveParticles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UParticleSystemComponent::GetNumActiveParticles() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumActiveParticles");

	Params::ParticleSystemComponent_GetNumActiveParticles Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ParticleSystem.ContainsEmitterType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           TypeData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UParticleSystem::ContainsEmitterType(class UClass* TypeData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ContainsEmitterType");

	Params::ParticleSystem_ContainsEmitterType Parms{};

	Parms.TypeData = TypeData;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CurveBase.GetTimeRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MinTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCurveBase::GetTimeRange(float* MinTime, float* MaxTime) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTimeRange");

	Params::CurveBase_GetTimeRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MinTime != nullptr)
		*MinTime = Parms.MinTime;

	if (MaxTime != nullptr)
		*MaxTime = Parms.MaxTime;
}


// Function Engine.CurveBase.GetValueRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MinValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCurveBase::GetValueRange(float* MinValue, float* MaxValue) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValueRange");

	Params::CurveBase_GetValueRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MinValue != nullptr)
		*MinValue = Parms.MinValue;

	if (MaxValue != nullptr)
		*MaxValue = Parms.MaxValue;
}


// Function Engine.CurveFloat.GetFloatValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCurveFloat::GetFloatValue(float InTime) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFloatValue");

	Params::CurveFloat_GetFloatValue Parms{};

	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMeshActor.SetMobility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EComponentMobility                      InMobility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStaticMeshActor::SetMobility(EComponentMobility InMobility)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMobility");

	Params::StaticMeshActor_SetMobility Parms{};

	Parms.InMobility = InMobility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Texture2D.Blueprint_GetSizeX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTexture2D::Blueprint_GetSizeX() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Blueprint_GetSizeX");

	Params::Texture2D_Blueprint_GetSizeX Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Texture2D.Blueprint_GetSizeY
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTexture2D::Blueprint_GetSizeY() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Blueprint_GetSizeY");

	Params::Texture2D_Blueprint_GetSizeY Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CurveVector.GetVectorValue
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCurveVector::GetVectorValue(float InTime) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVectorValue");

	Params::CurveVector_GetVectorValue Parms{};

	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataTableFunctionLibrary.DoesDataTableRowExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableFunctionLibrary::DoesDataTableRowExist(class UDataTable* Table, class FName RowName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DoesDataTableRowExist");

	Params::DataTableFunctionLibrary_DoesDataTableRowExist Parms{};

	Parms.Table = Table;
	Parms.RowName = RowName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCurveTable*                      CurveTable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InXY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEvaluateCurveTableResult               OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutXY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ContextString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataTableFunctionLibrary::EvaluateCurveTableRow(class UCurveTable* CurveTable, class FName RowName, float InXY, EEvaluateCurveTableResult* OutResult, float* OutXY, const class FString& ContextString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EvaluateCurveTableRow");

	Params::DataTableFunctionLibrary_EvaluateCurveTableRow Parms{};

	Parms.CurveTable = CurveTable;
	Parms.RowName = RowName;
	Parms.InXY = InXY;
	Parms.ContextString = std::move(ContextString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutResult != nullptr)
		*OutResult = Parms.OutResult;

	if (OutXY != nullptr)
		*OutXY = Parms.OutXY;
}


// Function Engine.DataTableFunctionLibrary.GetDataTableColumnAsString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UDataTableFunctionLibrary::GetDataTableColumnAsString(const class UDataTable* DataTable, class FName PropertyName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDataTableColumnAsString");

	Params::DataTableFunctionLibrary_GetDataTableColumnAsString Parms{};

	Parms.DataTable = DataTable;
	Parms.PropertyName = PropertyName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTableRowBase                    OutRow                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataTableFunctionLibrary::GetDataTableRowFromName(class UDataTable* Table, class FName RowName, struct FTableRowBase* OutRow)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDataTableRowFromName");

	Params::DataTableFunctionLibrary_GetDataTableRowFromName Parms{};

	Parms.Table = Table;
	Parms.RowName = RowName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutRow != nullptr)
		*OutRow = std::move(Parms.OutRow);

	return Parms.ReturnValue;
}


// Function Engine.DataTableFunctionLibrary.GetDataTableRowNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       Table                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutRowNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDataTableFunctionLibrary::GetDataTableRowNames(class UDataTable* Table, TArray<class FName>* OutRowNames)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDataTableRowNames");

	Params::DataTableFunctionLibrary_GetDataTableRowNames Parms{};

	Parms.Table = Table;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutRowNames != nullptr)
		*OutRowNames = std::move(Parms.OutRowNames);
}


// Function Engine.DebugCameraController.ReceiveOnActivate
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                OriginalPC                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugCameraController::ReceiveOnActivate(class APlayerController* OriginalPC)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveOnActivate");

	Params::DebugCameraController_ReceiveOnActivate Parms{};

	Parms.OriginalPC = OriginalPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DebugCameraController.ReceiveOnActorSelected
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           NewSelectedActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SelectHitLocation                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SelectHitNormal                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADebugCameraController::ReceiveOnActorSelected(class AActor* NewSelectedActor, const struct FVector& SelectHitLocation, const struct FVector& SelectHitNormal, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveOnActorSelected");

	Params::DebugCameraController_ReceiveOnActorSelected Parms{};

	Parms.NewSelectedActor = NewSelectedActor;
	Parms.SelectHitLocation = std::move(SelectHitLocation);
	Parms.SelectHitNormal = std::move(SelectHitNormal);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DebugCameraController.ReceiveOnDeactivate
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                RestoredPC                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugCameraController::ReceiveOnDeactivate(class APlayerController* RestoredPC)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveOnDeactivate");

	Params::DebugCameraController_ReceiveOnDeactivate Parms{};

	Parms.RestoredPC = RestoredPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DebugCameraController.SetPawnMovementSpeedScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewSpeedScale                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugCameraController::SetPawnMovementSpeedScale(float NewSpeedScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPawnMovementSpeedScale");

	Params::DebugCameraController_SetPawnMovementSpeedScale Parms{};

	Parms.NewSpeedScale = NewSpeedScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DebugCameraController.ShowDebugSelectedInfo
// (Exec, Native, Public)

void ADebugCameraController::ShowDebugSelectedInfo()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowDebugSelectedInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.DebugCameraController.ToggleDisplay
// (Final, Native, Public, BlueprintCallable)

void ADebugCameraController::ToggleDisplay()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleDisplay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.DebugCameraController.GetSelectedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ADebugCameraController::GetSelectedActor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSelectedActor");

	Params::DebugCameraController_GetSelectedActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Emitter.Activate
// (Final, Native, Public, BlueprintCallable)

void AEmitter::Activate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Activate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Emitter.Deactivate
// (Final, Native, Public, BlueprintCallable)

void AEmitter::Deactivate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Deactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Emitter.OnParticleSystemFinished
// (Native, Public)
// Parameters:
// class UParticleSystemComponent*         FinishedComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnParticleSystemFinished");

	Params::Emitter_OnParticleSystemFinished Parms{};

	Parms.FinishedComponent = FinishedComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Emitter.OnRep_bCurrentlyActive
// (Native, Public)

void AEmitter::OnRep_bCurrentlyActive()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bCurrentlyActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Emitter.SetActorParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetActorParameter(class FName ParameterName, class AActor* Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActorParameter");

	Params::Emitter_SetActorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Emitter.SetColorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetColorParameter(class FName ParameterName, const struct FLinearColor& Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetColorParameter");

	Params::Emitter_SetColorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Emitter.SetFloatParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetFloatParameter(class FName ParameterName, float Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFloatParameter");

	Params::Emitter_SetFloatParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Emitter.SetMaterialParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetMaterialParameter(class FName ParameterName, class UMaterialInterface* Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaterialParameter");

	Params::Emitter_SetMaterialParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = Param;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Emitter.SetTemplate
// (Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystem*                  NewTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetTemplate(class UParticleSystem* NewTemplate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTemplate");

	Params::Emitter_SetTemplate Parms{};

	Parms.NewTemplate = NewTemplate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Emitter.SetVectorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmitter::SetVectorParameter(class FName ParameterName, const struct FVector& Param)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorParameter");

	Params::Emitter_SetVectorParameter Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Param = std::move(Param);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Emitter.ToggleActive
// (Final, Native, Public, BlueprintCallable)

void AEmitter::ToggleActive()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleActive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Emitter.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEmitter::IsActive() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsActive");

	Params::Emitter_IsActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationProfileBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClearNotFound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::ApplyPhysicalAnimationProfileBelow(class FName BodyName, class FName ProfileName, bool bIncludeSelf, bool bClearNotFound)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ApplyPhysicalAnimationProfileBelow");

	Params::PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow Parms{};

	Parms.BodyName = BodyName;
	Parms.ProfileName = ProfileName;
	Parms.bIncludeSelf = bIncludeSelf;
	Parms.bClearNotFound = bClearNotFound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettings
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPhysicalAnimationData           PhysicalAnimationData                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::ApplyPhysicalAnimationSettings(class FName BodyName, const struct FPhysicalAnimationData& PhysicalAnimationData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ApplyPhysicalAnimationSettings");

	Params::PhysicalAnimationComponent_ApplyPhysicalAnimationSettings Parms{};

	Parms.BodyName = BodyName;
	Parms.PhysicalAnimationData = std::move(PhysicalAnimationData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettingsBelow
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPhysicalAnimationData           PhysicalAnimationData                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIncludeSelf                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::ApplyPhysicalAnimationSettingsBelow(class FName BodyName, const struct FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ApplyPhysicalAnimationSettingsBelow");

	Params::PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow Parms{};

	Parms.BodyName = BodyName;
	Parms.PhysicalAnimationData = std::move(PhysicalAnimationData);
	Parms.bIncludeSelf = bIncludeSelf;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicalAnimationComponent.SetSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMeshComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::SetSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSkeletalMeshComponent");

	Params::PhysicalAnimationComponent_SetSkeletalMeshComponent Parms{};

	Parms.InSkeletalMeshComponent = InSkeletalMeshComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicalAnimationComponent.SetStrengthMultiplyer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InStrengthMultiplyer                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicalAnimationComponent::SetStrengthMultiplyer(float InStrengthMultiplyer)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStrengthMultiplyer");

	Params::PhysicalAnimationComponent_SetStrengthMultiplyer Parms{};

	Parms.InStrengthMultiplyer = InStrengthMultiplyer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicalAnimationComponent.GetBodyTargetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BodyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UPhysicalAnimationComponent::GetBodyTargetTransform(class FName BodyName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBodyTargetTransform");

	Params::PhysicalAnimationComponent_GetBodyTargetTransform Parms{};

	Parms.BodyName = BodyName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Predefined Function
// Returns the result of UEngine::GetEngine() without a type-check, might be dangerous

class UGameEngine* UGameEngine::GetEngine()
{
	return static_cast<UGameEngine*>(UEngine::GetEngine());
}


// Function Engine.GameUserSettings.GetDefaultResolution
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetDefaultResolution()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDefaultResolution");

	Params::GameUserSettings_GetDefaultResolution Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetDefaultWindowMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EWindowMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWindowMode UGameUserSettings::GetDefaultWindowMode()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDefaultWindowMode");

	Params::GameUserSettings_GetDefaultWindowMode Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetDefaultWindowPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetDefaultWindowPosition()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDefaultWindowPosition");

	Params::GameUserSettings_GetDefaultWindowPosition Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetFramePace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetFramePace()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetFramePace");

	Params::GameUserSettings_GetFramePace Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameUserSettings*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameUserSettings* UGameUserSettings::GetGameUserSettings()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameUserSettings");

	Params::GameUserSettings_GetGameUserSettings Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetSyncInterval
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetSyncInterval()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSyncInterval");

	Params::GameUserSettings_GetSyncInterval Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.ApplyHardwareBenchmarkResults
// (Native, Public, BlueprintCallable)

void UGameUserSettings::ApplyHardwareBenchmarkResults()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ApplyHardwareBenchmarkResults");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.ApplyNonResolutionSettings
// (Native, Public, BlueprintCallable)

void UGameUserSettings::ApplyNonResolutionSettings()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ApplyNonResolutionSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.ApplyResolutionSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCheckForCommandLineOverrides                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::ApplyResolutionSettings(bool bCheckForCommandLineOverrides)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ApplyResolutionSettings");

	Params::GameUserSettings_ApplyResolutionSettings Parms{};

	Parms.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.ApplySettings
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCheckForCommandLineOverrides                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::ApplySettings(bool bCheckForCommandLineOverrides)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ApplySettings");

	Params::GameUserSettings_ApplySettings Parms{};

	Parms.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.ConfirmVideoMode
// (Native, Public, BlueprintCallable)

void UGameUserSettings::ConfirmVideoMode()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ConfirmVideoMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.EnableHDRDisplayOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayNits                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::EnableHDRDisplayOutput(bool bEnable, int32 DisplayNits)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableHDRDisplayOutput");

	Params::GameUserSettings_EnableHDRDisplayOutput Parms{};

	Parms.bEnable = bEnable;
	Parms.DisplayNits = DisplayNits;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.GetDefaultResolutionScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameUserSettings::GetDefaultResolutionScale()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultResolutionScale");

	Params::GameUserSettings_GetDefaultResolutionScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetRecommendedResolutionScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameUserSettings::GetRecommendedResolutionScale()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRecommendedResolutionScale");

	Params::GameUserSettings_GetRecommendedResolutionScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.LoadSettings
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceReload                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::LoadSettings(bool bForceReload)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("LoadSettings");

	Params::GameUserSettings_LoadSettings Parms{};

	Parms.bForceReload = bForceReload;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.ResetToCurrentSettings
// (Native, Public, BlueprintCallable)

void UGameUserSettings::ResetToCurrentSettings()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetToCurrentSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.RevertVideoMode
// (Final, Native, Public, BlueprintCallable)

void UGameUserSettings::RevertVideoMode()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RevertVideoMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.RunHardwareBenchmark
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   WorkScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CPUMultiplier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GPUMultiplier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::RunHardwareBenchmark(int32 WorkScale, float CPUMultiplier, float GPUMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RunHardwareBenchmark");

	Params::GameUserSettings_RunHardwareBenchmark Parms{};

	Parms.WorkScale = WorkScale;
	Parms.CPUMultiplier = CPUMultiplier;
	Parms.GPUMultiplier = GPUMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SaveSettings
// (Native, Public, BlueprintCallable)

void UGameUserSettings::SaveSettings()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SaveSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.SetAntiAliasingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetAntiAliasingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAntiAliasingQuality");

	Params::GameUserSettings_SetAntiAliasingQuality Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetAudioQualityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   QualityLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetAudioQualityLevel(int32 QualityLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAudioQualityLevel");

	Params::GameUserSettings_SetAudioQualityLevel Parms{};

	Parms.QualityLevel = QualityLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetBenchmarkFallbackValues
// (Final, Native, Public, BlueprintCallable)

void UGameUserSettings::SetBenchmarkFallbackValues()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBenchmarkFallbackValues");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.SetDynamicResolutionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetDynamicResolutionEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDynamicResolutionEnabled");

	Params::GameUserSettings_SetDynamicResolutionEnabled Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetFoliageQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetFoliageQuality(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFoliageQuality");

	Params::GameUserSettings_SetFoliageQuality Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetFrameRateLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLimit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetFrameRateLimit(float NewLimit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFrameRateLimit");

	Params::GameUserSettings_SetFrameRateLimit Parms{};

	Parms.NewLimit = NewLimit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetFullscreenMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWindowMode                             InFullscreenMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetFullscreenMode(EWindowMode InFullscreenMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFullscreenMode");

	Params::GameUserSettings_SetFullscreenMode Parms{};

	Parms.InFullscreenMode = InFullscreenMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetOverallScalabilityLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetOverallScalabilityLevel(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOverallScalabilityLevel");

	Params::GameUserSettings_SetOverallScalabilityLevel Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetPostProcessingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetPostProcessingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPostProcessingQuality");

	Params::GameUserSettings_SetPostProcessingQuality Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetResolutionScaleNormalized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewScaleNormalized                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetResolutionScaleNormalized(float NewScaleNormalized)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetResolutionScaleNormalized");

	Params::GameUserSettings_SetResolutionScaleNormalized Parms{};

	Parms.NewScaleNormalized = NewScaleNormalized;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetResolutionScaleValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewScaleValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetResolutionScaleValue(int32 NewScaleValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetResolutionScaleValue");

	Params::GameUserSettings_SetResolutionScaleValue Parms{};

	Parms.NewScaleValue = NewScaleValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetResolutionScaleValueEx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewScaleValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetResolutionScaleValueEx(float NewScaleValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetResolutionScaleValueEx");

	Params::GameUserSettings_SetResolutionScaleValueEx Parms{};

	Parms.NewScaleValue = NewScaleValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        Resolution                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetScreenResolution(const struct FIntPoint& Resolution)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScreenResolution");

	Params::GameUserSettings_SetScreenResolution Parms{};

	Parms.Resolution = std::move(Resolution);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetShadingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetShadingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadingQuality");

	Params::GameUserSettings_SetShadingQuality Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetShadowQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetShadowQuality(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowQuality");

	Params::GameUserSettings_SetShadowQuality Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetTextureQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetTextureQuality(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextureQuality");

	Params::GameUserSettings_SetTextureQuality Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetToDefaults
// (Native, Public, BlueprintCallable)

void UGameUserSettings::SetToDefaults()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetToDefaults");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.SetViewDistanceQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetViewDistanceQuality(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetViewDistanceQuality");

	Params::GameUserSettings_SetViewDistanceQuality Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetVisualEffectQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetVisualEffectQuality(int32 Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVisualEffectQuality");

	Params::GameUserSettings_SetVisualEffectQuality Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.SetVSyncEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::SetVSyncEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVSyncEnabled");

	Params::GameUserSettings_SetVSyncEnabled Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.GameUserSettings.ValidateSettings
// (Native, Public, BlueprintCallable)

void UGameUserSettings::ValidateSettings()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ValidateSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.GameUserSettings.GetAntiAliasingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetAntiAliasingQuality() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAntiAliasingQuality");

	Params::GameUserSettings_GetAntiAliasingQuality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetAudioQualityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetAudioQualityLevel() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAudioQualityLevel");

	Params::GameUserSettings_GetAudioQualityLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetCurrentHDRDisplayNits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetCurrentHDRDisplayNits() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentHDRDisplayNits");

	Params::GameUserSettings_GetCurrentHDRDisplayNits Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetDesktopResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetDesktopResolution() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDesktopResolution");

	Params::GameUserSettings_GetDesktopResolution Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetFoliageQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetFoliageQuality() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFoliageQuality");

	Params::GameUserSettings_GetFoliageQuality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetFrameRateLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameUserSettings::GetFrameRateLimit() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFrameRateLimit");

	Params::GameUserSettings_GetFrameRateLimit Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWindowMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWindowMode UGameUserSettings::GetFullscreenMode() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFullscreenMode");

	Params::GameUserSettings_GetFullscreenMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetLastConfirmedFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWindowMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWindowMode UGameUserSettings::GetLastConfirmedFullscreenMode() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastConfirmedFullscreenMode");

	Params::GameUserSettings_GetLastConfirmedFullscreenMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetLastConfirmedScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetLastConfirmedScreenResolution() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastConfirmedScreenResolution");

	Params::GameUserSettings_GetLastConfirmedScreenResolution Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetOverallScalabilityLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetOverallScalabilityLevel() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOverallScalabilityLevel");

	Params::GameUserSettings_GetOverallScalabilityLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetPostProcessingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetPostProcessingQuality() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPostProcessingQuality");

	Params::GameUserSettings_GetPostProcessingQuality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetPreferredFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWindowMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWindowMode UGameUserSettings::GetPreferredFullscreenMode() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPreferredFullscreenMode");

	Params::GameUserSettings_GetPreferredFullscreenMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetResolutionScaleInformation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   CurrentScaleNormalized                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentScaleValue                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinScaleValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxScaleValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::GetResolutionScaleInformation(float* CurrentScaleNormalized, int32* CurrentScaleValue, int32* MinScaleValue, int32* MaxScaleValue) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetResolutionScaleInformation");

	Params::GameUserSettings_GetResolutionScaleInformation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentScaleNormalized != nullptr)
		*CurrentScaleNormalized = Parms.CurrentScaleNormalized;

	if (CurrentScaleValue != nullptr)
		*CurrentScaleValue = Parms.CurrentScaleValue;

	if (MinScaleValue != nullptr)
		*MinScaleValue = Parms.MinScaleValue;

	if (MaxScaleValue != nullptr)
		*MaxScaleValue = Parms.MaxScaleValue;
}


// Function Engine.GameUserSettings.GetResolutionScaleInformationEx
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   CurrentScaleNormalized                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentScaleValue                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinScaleValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxScaleValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameUserSettings::GetResolutionScaleInformationEx(float* CurrentScaleNormalized, float* CurrentScaleValue, float* MinScaleValue, float* MaxScaleValue) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetResolutionScaleInformationEx");

	Params::GameUserSettings_GetResolutionScaleInformationEx Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentScaleNormalized != nullptr)
		*CurrentScaleNormalized = Parms.CurrentScaleNormalized;

	if (CurrentScaleValue != nullptr)
		*CurrentScaleValue = Parms.CurrentScaleValue;

	if (MinScaleValue != nullptr)
		*MinScaleValue = Parms.MinScaleValue;

	if (MaxScaleValue != nullptr)
		*MaxScaleValue = Parms.MaxScaleValue;
}


// Function Engine.GameUserSettings.GetResolutionScaleNormalized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameUserSettings::GetResolutionScaleNormalized() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetResolutionScaleNormalized");

	Params::GameUserSettings_GetResolutionScaleNormalized Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGameUserSettings::GetScreenResolution() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScreenResolution");

	Params::GameUserSettings_GetScreenResolution Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetShadingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetShadingQuality() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShadingQuality");

	Params::GameUserSettings_GetShadingQuality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetShadowQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetShadowQuality() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShadowQuality");

	Params::GameUserSettings_GetShadowQuality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetTextureQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetTextureQuality() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTextureQuality");

	Params::GameUserSettings_GetTextureQuality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetViewDistanceQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetViewDistanceQuality() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetViewDistanceQuality");

	Params::GameUserSettings_GetViewDistanceQuality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.GetVisualEffectQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameUserSettings::GetVisualEffectQuality() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVisualEffectQuality");

	Params::GameUserSettings_GetVisualEffectQuality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.IsDirty
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsDirty() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDirty");

	Params::GameUserSettings_IsDirty Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.IsDynamicResolutionDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsDynamicResolutionDirty() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDynamicResolutionDirty");

	Params::GameUserSettings_IsDynamicResolutionDirty Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.IsDynamicResolutionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsDynamicResolutionEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDynamicResolutionEnabled");

	Params::GameUserSettings_IsDynamicResolutionEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.IsFullscreenModeDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsFullscreenModeDirty() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsFullscreenModeDirty");

	Params::GameUserSettings_IsFullscreenModeDirty Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.IsHDREnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsHDREnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsHDREnabled");

	Params::GameUserSettings_IsHDREnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.IsScreenResolutionDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsScreenResolutionDirty() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsScreenResolutionDirty");

	Params::GameUserSettings_IsScreenResolutionDirty Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.IsVSyncDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsVSyncDirty() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsVSyncDirty");

	Params::GameUserSettings_IsVSyncDirty Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.IsVSyncEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::IsVSyncEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsVSyncEnabled");

	Params::GameUserSettings_IsVSyncEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameUserSettings.SupportsHDRDisplayOutput
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameUserSettings::SupportsHDRDisplayOutput() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SupportsHDRDisplayOutput");

	Params::GameUserSettings_SupportsHDRDisplayOutput Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.AdjustAttenuation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSoundAttenuationSettings        InAttenuationSettings                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAudioComponent::AdjustAttenuation(const struct FSoundAttenuationSettings& InAttenuationSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AdjustAttenuation");

	Params::AudioComponent_AdjustAttenuation Parms{};

	Parms.InAttenuationSettings = std::move(InAttenuationSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.AdjustVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AdjustVolumeDuration                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustVolumeLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAudioFaderCurve                        FadeCurve                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel, const EAudioFaderCurve FadeCurve)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AdjustVolume");

	Params::AudioComponent_AdjustVolume Parms{};

	Parms.AdjustVolumeDuration = AdjustVolumeDuration;
	Parms.AdjustVolumeLevel = AdjustVolumeLevel;
	Parms.FadeCurve = FadeCurve;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSoundAttenuationSettings        OutAttenuationSettings                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::BP_GetAttenuationSettingsToApply(struct FSoundAttenuationSettings* OutAttenuationSettings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_GetAttenuationSettingsToApply");

	Params::AudioComponent_BP_GetAttenuationSettingsToApply Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutAttenuationSettings != nullptr)
		*OutAttenuationSettings = std::move(Parms.OutAttenuationSettings);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.FadeIn
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeInDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolumeLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAudioFaderCurve                        FadeCurve                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime, const EAudioFaderCurve FadeCurve)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FadeIn");

	Params::AudioComponent_FadeIn Parms{};

	Parms.FadeInDuration = FadeInDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;
	Parms.StartTime = StartTime;
	Parms.FadeCurve = FadeCurve;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.FadeOut
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeOutDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolumeLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAudioFaderCurve                        FadeCurve                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::FadeOut(float FadeOutDuration, float FadeVolumeLevel, const EAudioFaderCurve FadeCurve)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FadeOut");

	Params::AudioComponent_FadeOut Parms{};

	Parms.FadeOutDuration = FadeOutDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;
	Parms.FadeCurve = FadeCurve;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.GetCookedEnvelopeData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   OutEnvelopeData                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::GetCookedEnvelopeData(float* OutEnvelopeData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCookedEnvelopeData");

	Params::AudioComponent_GetCookedEnvelopeData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutEnvelopeData != nullptr)
		*OutEnvelopeData = Parms.OutEnvelopeData;

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.GetCookedEnvelopeDataForAllPlayingSounds
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSoundWaveEnvelopeDataPerSound>OutEnvelopeData                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::GetCookedEnvelopeDataForAllPlayingSounds(TArray<struct FSoundWaveEnvelopeDataPerSound>* OutEnvelopeData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCookedEnvelopeDataForAllPlayingSounds");

	Params::AudioComponent_GetCookedEnvelopeDataForAllPlayingSounds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutEnvelopeData != nullptr)
		*OutEnvelopeData = std::move(Parms.OutEnvelopeData);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.GetCookedFFTData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           FrequenciesToGet                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FSoundWaveSpectralData>   OutSoundWaveSpectralData                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::GetCookedFFTData(const TArray<float>& FrequenciesToGet, TArray<struct FSoundWaveSpectralData>* OutSoundWaveSpectralData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCookedFFTData");

	Params::AudioComponent_GetCookedFFTData Parms{};

	Parms.FrequenciesToGet = std::move(FrequenciesToGet);

	UObject::ProcessEvent(Func, &Parms);

	if (OutSoundWaveSpectralData != nullptr)
		*OutSoundWaveSpectralData = std::move(Parms.OutSoundWaveSpectralData);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.GetCookedFFTDataForAllPlayingSounds
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSoundWaveSpectralDataPerSound>OutSoundWaveSpectralData                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::GetCookedFFTDataForAllPlayingSounds(TArray<struct FSoundWaveSpectralDataPerSound>* OutSoundWaveSpectralData)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCookedFFTDataForAllPlayingSounds");

	Params::AudioComponent_GetCookedFFTDataForAllPlayingSounds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutSoundWaveSpectralData != nullptr)
		*OutSoundWaveSpectralData = std::move(Parms.OutSoundWaveSpectralData);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.Play
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::Play(float StartTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Play");

	Params::AudioComponent_Play Parms{};

	Parms.StartTime = StartTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.PlayQuantized
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UQuartzClockHandle*               InClockHandle                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuartzQuantizationBoundary      InQuantizationBoundary                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(EQuartzCommandDelegateSubType EventType, class FName Name)>InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   InStartTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InFadeInDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InFadeVolumeLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAudioFaderCurve                        InFadeCurve                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::PlayQuantized(const class UObject* WorldContextObject, class UQuartzClockHandle*& InClockHandle, struct FQuartzQuantizationBoundary& InQuantizationBoundary, const TDelegate<void(EQuartzCommandDelegateSubType EventType, class FName Name)>& InDelegate, float InStartTime, float InFadeInDuration, float InFadeVolumeLevel, EAudioFaderCurve InFadeCurve)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayQuantized");

	Params::AudioComponent_PlayQuantized Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InClockHandle = InClockHandle;
	Parms.InQuantizationBoundary = std::move(InQuantizationBoundary);
	Parms.InDelegate = InDelegate;
	Parms.InStartTime = InStartTime;
	Parms.InFadeInDuration = InFadeInDuration;
	Parms.InFadeVolumeLevel = InFadeVolumeLevel;
	Parms.InFadeCurve = InFadeCurve;

	UObject::ProcessEvent(Func, &Parms);

	InClockHandle = Parms.InClockHandle;
	InQuantizationBoundary = std::move(Parms.InQuantizationBoundary);
}


// Function Engine.AudioComponent.SetAudioBusSendPostEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAudioBus*                        AudioBus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioBusSendLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetAudioBusSendPostEffect(class UAudioBus* AudioBus, float AudioBusSendLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAudioBusSendPostEffect");

	Params::AudioComponent_SetAudioBusSendPostEffect Parms{};

	Parms.AudioBus = AudioBus;
	Parms.AudioBusSendLevel = AudioBusSendLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetAudioBusSendPreEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAudioBus*                        AudioBus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioBusSendLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetAudioBusSendPreEffect(class UAudioBus* AudioBus, float AudioBusSendLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAudioBusSendPreEffect");

	Params::AudioComponent_SetAudioBusSendPreEffect Parms{};

	Parms.AudioBus = AudioBus;
	Parms.AudioBusSendLevel = AudioBusSendLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetLowPassFilterEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InLowPassFilterEnabled                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetLowPassFilterEnabled(bool InLowPassFilterEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLowPassFilterEnabled");

	Params::AudioComponent_SetLowPassFilterEnabled Parms{};

	Parms.InLowPassFilterEnabled = InLowPassFilterEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetLowPassFilterFrequency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InLowPassFilterFrequency                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetLowPassFilterFrequency(float InLowPassFilterFrequency)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLowPassFilterFrequency");

	Params::AudioComponent_SetLowPassFilterFrequency Parms{};

	Parms.InLowPassFilterFrequency = InLowPassFilterFrequency;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetOutputToBusOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInOutputToBusOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetOutputToBusOnly(bool bInOutputToBusOnly)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOutputToBusOnly");

	Params::AudioComponent_SetOutputToBusOnly Parms{};

	Parms.bInOutputToBusOnly = bInOutputToBusOnly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPause                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetPaused(bool bPause)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPaused");

	Params::AudioComponent_SetPaused Parms{};

	Parms.bPause = bPause;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetPitchMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewPitchMultiplier                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetPitchMultiplier(float NewPitchMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPitchMultiplier");

	Params::AudioComponent_SetPitchMultiplier Parms{};

	Parms.NewPitchMultiplier = NewPitchMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       NewSound                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetSound(class USoundBase* NewSound)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSound");

	Params::AudioComponent_SetSound Parms{};

	Parms.NewSound = NewSound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetSourceBusSendPostEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundSourceBus*                  SoundSourceBus                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SourceBusSendLevel                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetSourceBusSendPostEffect(class USoundSourceBus* SoundSourceBus, float SourceBusSendLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSourceBusSendPostEffect");

	Params::AudioComponent_SetSourceBusSendPostEffect Parms{};

	Parms.SoundSourceBus = SoundSourceBus;
	Parms.SourceBusSendLevel = SourceBusSendLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetSourceBusSendPreEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundSourceBus*                  SoundSourceBus                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SourceBusSendLevel                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetSourceBusSendPreEffect(class USoundSourceBus* SoundSourceBus, float SourceBusSendLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSourceBusSendPreEffect");

	Params::AudioComponent_SetSourceBusSendPreEffect Parms{};

	Parms.SoundSourceBus = SoundSourceBus;
	Parms.SourceBusSendLevel = SourceBusSendLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetSubmixSend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundSubmixBase*                 Submix                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SendLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetSubmixSend(class USoundSubmixBase* Submix, float SendLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSubmixSend");

	Params::AudioComponent_SetSubmixSend Parms{};

	Parms.Submix = Submix;
	Parms.SendLevel = SendLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetUISound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInUISound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetUISound(bool bInUISound)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUISound");

	Params::AudioComponent_SetUISound Parms{};

	Parms.bInUISound = bInUISound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetVolumeMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewVolumeMultiplier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetVolumeMultiplier(float NewVolumeMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumeMultiplier");

	Params::AudioComponent_SetVolumeMultiplier Parms{};

	Parms.NewVolumeMultiplier = NewVolumeMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.SetWaveParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                       InWave                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::SetWaveParameter(class FName InName, class USoundWave* InWave)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWaveParameter");

	Params::AudioComponent_SetWaveParameter Parms{};

	Parms.InName = InName;
	Parms.InWave = InWave;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.Stop
// (Native, Public, BlueprintCallable)

void UAudioComponent::Stop()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Stop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AudioComponent.StopDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioComponent::StopDelayed(float DelayTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopDelayed");

	Params::AudioComponent_StopDelayed Parms{};

	Parms.DelayTime = DelayTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AudioComponent.GetPlayState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAudioComponentPlayState                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAudioComponentPlayState UAudioComponent::GetPlayState() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayState");

	Params::AudioComponent_GetPlayState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.HasCookedAmplitudeEnvelopeData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::HasCookedAmplitudeEnvelopeData() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasCookedAmplitudeEnvelopeData");

	Params::AudioComponent_HasCookedAmplitudeEnvelopeData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.HasCookedFFTData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::HasCookedFFTData() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HasCookedFFTData");

	Params::AudioComponent_HasCookedFFTData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.IsPlaying
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::IsPlaying() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlaying");

	Params::AudioComponent_IsPlaying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AudioComponent.IsVirtualized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAudioComponent::IsVirtualized() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsVirtualized");

	Params::AudioComponent_IsVirtualized Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CameraComponent.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddOrUpdateBlendable");

	Params::CameraComponent_AddOrUpdateBlendable Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.GetCameraView
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMinimalViewInfo                 DesiredView                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UCameraComponent::GetCameraView(float DeltaTime, struct FMinimalViewInfo* DesiredView)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCameraView");

	Params::CameraComponent_GetCameraView Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);

	if (DesiredView != nullptr)
		*DesiredView = std::move(Parms.DesiredView);
}


// Function Engine.CameraComponent.OnCameraMeshHiddenChanged
// (Final, Native, Protected, BlueprintCallable)

void UCameraComponent::OnCameraMeshHiddenChanged()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnCameraMeshHiddenChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CameraComponent.RemoveBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveBlendable");

	Params::CameraComponent_RemoveBlendable Parms{};

	Parms.InBlendableObject = InBlendableObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InAspectRatio                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetAspectRatio(float InAspectRatio)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAspectRatio");

	Params::CameraComponent_SetAspectRatio Parms{};

	Parms.InAspectRatio = InAspectRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetConstraintAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInConstrainAspectRatio                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetConstraintAspectRatio(bool bInConstrainAspectRatio)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConstraintAspectRatio");

	Params::CameraComponent_SetConstraintAspectRatio Parms{};

	Parms.bInConstrainAspectRatio = bInConstrainAspectRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetFieldOfView
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   InFieldOfView                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetFieldOfView(float InFieldOfView)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFieldOfView");

	Params::CameraComponent_SetFieldOfView Parms{};

	Parms.InFieldOfView = InFieldOfView;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetOrthoFarClipPlane
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOrthoFarClipPlane                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetOrthoFarClipPlane(float InOrthoFarClipPlane)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOrthoFarClipPlane");

	Params::CameraComponent_SetOrthoFarClipPlane Parms{};

	Parms.InOrthoFarClipPlane = InOrthoFarClipPlane;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetOrthoNearClipPlane
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOrthoNearClipPlane                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetOrthoNearClipPlane(float InOrthoNearClipPlane)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOrthoNearClipPlane");

	Params::CameraComponent_SetOrthoNearClipPlane Parms{};

	Parms.InOrthoNearClipPlane = InOrthoNearClipPlane;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetOrthoWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOrthoWidth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetOrthoWidth(float InOrthoWidth)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOrthoWidth");

	Params::CameraComponent_SetOrthoWidth Parms{};

	Parms.InOrthoWidth = InOrthoWidth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetPostProcessBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPostProcessBlendWeight                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetPostProcessBlendWeight(float InPostProcessBlendWeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPostProcessBlendWeight");

	Params::CameraComponent_SetPostProcessBlendWeight Parms{};

	Parms.InPostProcessBlendWeight = InPostProcessBlendWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetProjectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraProjectionMode                   InProjectionMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetProjectionMode(ECameraProjectionMode InProjectionMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetProjectionMode");

	Params::CameraComponent_SetProjectionMode Parms{};

	Parms.InProjectionMode = InProjectionMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraComponent.SetUseFieldOfViewForLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInUseFieldOfViewForLOD                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraComponent::SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUseFieldOfViewForLOD");

	Params::CameraComponent_SetUseFieldOfViewForLOD Parms{};

	Parms.bInUseFieldOfViewForLOD = bInUseFieldOfViewForLOD;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.InputComponent.GetControllerAnalogKeyState
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInputComponent::GetControllerAnalogKeyState(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetControllerAnalogKeyState");

	Params::InputComponent_GetControllerAnalogKeyState Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InputComponent.GetControllerAnalogStickState
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EControllerAnalogStick                  WhichStick                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StickX                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StickY                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputComponent::GetControllerAnalogStickState(EControllerAnalogStick WhichStick, float* StickX, float* StickY) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetControllerAnalogStickState");

	Params::InputComponent_GetControllerAnalogStickState Parms{};

	Parms.WhichStick = WhichStick;

	UObject::ProcessEvent(Func, &Parms);

	if (StickX != nullptr)
		*StickX = Parms.StickX;

	if (StickY != nullptr)
		*StickY = Parms.StickY;
}


// Function Engine.InputComponent.GetControllerKeyTimeDown
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInputComponent::GetControllerKeyTimeDown(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetControllerKeyTimeDown");

	Params::InputComponent_GetControllerKeyTimeDown Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InputComponent.GetControllerMouseDelta
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DeltaX                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaY                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputComponent::GetControllerMouseDelta(float* DeltaX, float* DeltaY) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetControllerMouseDelta");

	Params::InputComponent_GetControllerMouseDelta Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DeltaX != nullptr)
		*DeltaX = Parms.DeltaX;

	if (DeltaY != nullptr)
		*DeltaY = Parms.DeltaY;
}


// Function Engine.InputComponent.GetControllerVectorKeyState
// (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInputComponent::GetControllerVectorKeyState(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetControllerVectorKeyState");

	Params::InputComponent_GetControllerVectorKeyState Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InputComponent.GetTouchState
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FingerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocationX                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LocationY                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCurrentlyPressed                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputComponent::GetTouchState(int32 FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTouchState");

	Params::InputComponent_GetTouchState Parms{};

	Parms.FingerIndex = FingerIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (LocationX != nullptr)
		*LocationX = Parms.LocationX;

	if (LocationY != nullptr)
		*LocationY = Parms.LocationY;

	if (bIsCurrentlyPressed != nullptr)
		*bIsCurrentlyPressed = Parms.bIsCurrentlyPressed;
}


// Function Engine.InputComponent.IsControllerKeyDown
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputComponent::IsControllerKeyDown(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsControllerKeyDown");

	Params::InputComponent_IsControllerKeyDown Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InputComponent.WasControllerKeyJustPressed
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputComponent::WasControllerKeyJustPressed(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasControllerKeyJustPressed");

	Params::InputComponent_WasControllerKeyJustPressed Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InputComponent.WasControllerKeyJustReleased
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputComponent::WasControllerKeyJustReleased(const struct FKey& Key) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("WasControllerKeyJustReleased");

	Params::InputComponent_WasControllerKeyJustReleased Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PointLightComponent.SetLightFalloffExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLightFalloffExponent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointLightComponent::SetLightFalloffExponent(float NewLightFalloffExponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFalloffExponent");

	Params::PointLightComponent_SetLightFalloffExponent Parms{};

	Parms.NewLightFalloffExponent = NewLightFalloffExponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PointLightComponent.SetSoftSourceRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointLightComponent::SetSoftSourceRadius(float bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSoftSourceRadius");

	Params::PointLightComponent_SetSoftSourceRadius Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PointLightComponent.SetSourceLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointLightComponent::SetSourceLength(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSourceLength");

	Params::PointLightComponent_SetSourceLength Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PointLightComponent.SetSourceRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPointLightComponent::SetSourceRadius(float bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSourceRadius");

	Params::PointLightComponent_SetSourceRadius Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SpotLightComponent.SetInnerConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewInnerConeAngle                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpotLightComponent::SetInnerConeAngle(float NewInnerConeAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInnerConeAngle");

	Params::SpotLightComponent_SetInnerConeAngle Parms{};

	Parms.NewInnerConeAngle = NewInnerConeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SpotLightComponent.SetOuterConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewOuterConeAngle                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpotLightComponent::SetOuterConeAngle(float NewOuterConeAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOuterConeAngle");

	Params::SpotLightComponent_SetOuterConeAngle Parms{};

	Parms.NewOuterConeAngle = NewOuterConeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimMontage.CreateSlotAnimationAsDynamicMontage_WithBlendSettings
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimSequenceBase*                Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMontageBlendSettings            BlendInSettings                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FMontageBlendSettings            BlendOutSettings                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendOutTriggerTime                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UAnimMontage::CreateSlotAnimationAsDynamicMontage_WithBlendSettings(class UAnimSequenceBase* Asset, class FName SlotNodeName, const struct FMontageBlendSettings& BlendInSettings, const struct FMontageBlendSettings& BlendOutSettings, float InPlayRate, int32 LoopCount, float InBlendOutTriggerTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateSlotAnimationAsDynamicMontage_WithBlendSettings");

	Params::AnimMontage_CreateSlotAnimationAsDynamicMontage_WithBlendSettings Parms{};

	Parms.Asset = Asset;
	Parms.SlotNodeName = SlotNodeName;
	Parms.BlendInSettings = std::move(BlendInSettings);
	Parms.BlendOutSettings = std::move(BlendOutSettings);
	Parms.InPlayRate = InPlayRate;
	Parms.LoopCount = LoopCount;
	Parms.InBlendOutTriggerTime = InBlendOutTriggerTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimMontage.GetBlendInArgs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAlphaBlendArgs                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAlphaBlendArgs UAnimMontage::GetBlendInArgs() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBlendInArgs");

	Params::AnimMontage_GetBlendInArgs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimMontage.GetBlendOutArgs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAlphaBlendArgs                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAlphaBlendArgs UAnimMontage::GetBlendOutArgs() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBlendOutArgs");

	Params::AnimMontage_GetBlendOutArgs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimMontage.GetDefaultBlendInTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimMontage::GetDefaultBlendInTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultBlendInTime");

	Params::AnimMontage_GetDefaultBlendInTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimMontage.GetDefaultBlendOutTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimMontage::GetDefaultBlendOutTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDefaultBlendOutTime");

	Params::AnimMontage_GetDefaultBlendOutTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimMontage.IsValidSectionName
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSectionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimMontage::IsValidSectionName(class FName InSectionName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsValidSectionName");

	Params::AnimMontage_IsValidSectionName Parms{};

	Parms.InSectionName = InSectionName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialBillboardComponent.AddElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      DistanceToOpacityCurve                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSizeIsInScreenSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseSizeX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseSizeY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      DistanceToSizeCurve                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialBillboardComponent::AddElement(class UMaterialInterface* Material, class UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UCurveFloat* DistanceToSizeCurve)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddElement");

	Params::MaterialBillboardComponent_AddElement Parms{};

	Parms.Material = Material;
	Parms.DistanceToOpacityCurve = DistanceToOpacityCurve;
	Parms.bSizeIsInScreenSpace = bSizeIsInScreenSpace;
	Parms.BaseSizeX = BaseSizeX;
	Parms.BaseSizeY = BaseSizeY;
	Parms.DistanceToSizeCurve = DistanceToSizeCurve;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialBillboardComponent.SetElements
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FMaterialSpriteElement>   NewElements                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UMaterialBillboardComponent::SetElements(const TArray<struct FMaterialSpriteElement>& NewElements)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetElements");

	Params::MaterialBillboardComponent_SetElements Parms{};

	Parms.NewElements = std::move(NewElements);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.AddForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::AddForce(const struct FVector& Force)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddForce");

	Params::CharacterMovementComponent_AddForce Parms{};

	Parms.Force = std::move(Force);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.AddImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVelocityChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::AddImpulse(const struct FVector& Impulse, bool bVelocityChange)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddImpulse");

	Params::CharacterMovementComponent_AddImpulse Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.bVelocityChange = bVelocityChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.CalcVelocity
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Friction                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFluid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BrakingDeceleration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CalcVelocity");

	Params::CharacterMovementComponent_CalcVelocity Parms{};

	Parms.DeltaTime = DeltaTime;
	Parms.Friction = Friction;
	Parms.bFluid = bFluid;
	Parms.BrakingDeceleration = BrakingDeceleration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.CapsuleTouched
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CapsuleTouched");

	Params::CharacterMovementComponent_CapsuleTouched Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.ClearAccumulatedForces
// (Native, Public, BlueprintCallable)

void UCharacterMovementComponent::ClearAccumulatedForces()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearAccumulatedForces");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CharacterMovementComponent.DisableMovement
// (Native, Public, BlueprintCallable)

void UCharacterMovementComponent::DisableMovement()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CharacterMovementComponent.SetAvoidanceEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetAvoidanceEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAvoidanceEnabled");

	Params::CharacterMovementComponent_SetAvoidanceEnabled Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetAvoidanceGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GroupFlags                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetAvoidanceGroup(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAvoidanceGroup");

	Params::CharacterMovementComponent_SetAvoidanceGroup Parms{};

	Parms.GroupFlags = GroupFlags;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetAvoidanceGroupMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask                GroupMask                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetAvoidanceGroupMask(const struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAvoidanceGroupMask");

	Params::CharacterMovementComponent_SetAvoidanceGroupMask Parms{};

	Parms.GroupMask = std::move(GroupMask);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetGroupsToAvoid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GroupFlags                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetGroupsToAvoid(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGroupsToAvoid");

	Params::CharacterMovementComponent_SetGroupsToAvoid Parms{};

	Parms.GroupFlags = GroupFlags;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetGroupsToAvoidMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask                GroupMask                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetGroupsToAvoidMask(const struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGroupsToAvoidMask");

	Params::CharacterMovementComponent_SetGroupsToAvoidMask Parms{};

	Parms.GroupMask = std::move(GroupMask);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetGroupsToIgnore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GroupFlags                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetGroupsToIgnore(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGroupsToIgnore");

	Params::CharacterMovementComponent_SetGroupsToIgnore Parms{};

	Parms.GroupFlags = GroupFlags;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetGroupsToIgnoreMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask                GroupMask                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetGroupsToIgnoreMask(const struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGroupsToIgnoreMask");

	Params::CharacterMovementComponent_SetGroupsToIgnoreMask Parms{};

	Parms.GroupMask = std::move(GroupMask);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetMovementMode
// (Native, Public, BlueprintCallable)
// Parameters:
// EMovementMode                           NewMovementMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewCustomMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetMovementMode(EMovementMode NewMovementMode, uint8 NewCustomMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMovementMode");

	Params::CharacterMovementComponent_SetMovementMode Parms{};

	Parms.NewMovementMode = NewMovementMode;
	Parms.NewCustomMode = NewCustomMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetWalkableFloorAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWalkableFloorAngle                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWalkableFloorAngle");

	Params::CharacterMovementComponent_SetWalkableFloorAngle Parms{};

	Parms.InWalkableFloorAngle = InWalkableFloorAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.SetWalkableFloorZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWalkableFloorZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWalkableFloorZ");

	Params::CharacterMovementComponent_SetWalkableFloorZ Parms{};

	Parms.InWalkableFloorZ = InWalkableFloorZ;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CharacterMovementComponent.GetAnalogInputModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetAnalogInputModifier() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnalogInputModifier");

	Params::CharacterMovementComponent_GetAnalogInputModifier Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetCharacterOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UCharacterMovementComponent::GetCharacterOwner() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCharacterOwner");

	Params::CharacterMovementComponent_GetCharacterOwner Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetCurrentAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterMovementComponent::GetCurrentAcceleration() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentAcceleration");

	Params::CharacterMovementComponent_GetCurrentAcceleration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterMovementComponent::GetImpartedMovementBaseVelocity() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetImpartedMovementBaseVelocity");

	Params::CharacterMovementComponent_GetImpartedMovementBaseVelocity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetLastUpdateLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterMovementComponent::GetLastUpdateLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastUpdateLocation");

	Params::CharacterMovementComponent_GetLastUpdateLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetLastUpdateRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UCharacterMovementComponent::GetLastUpdateRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastUpdateRotation");

	Params::CharacterMovementComponent_GetLastUpdateRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetLastUpdateVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterMovementComponent::GetLastUpdateVelocity() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLastUpdateVelocity");

	Params::CharacterMovementComponent_GetLastUpdateVelocity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMaxAcceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMaxAcceleration() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxAcceleration");

	Params::CharacterMovementComponent_GetMaxAcceleration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMaxBrakingDeceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMaxBrakingDeceleration() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxBrakingDeceleration");

	Params::CharacterMovementComponent_GetMaxBrakingDeceleration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMaxJumpHeight
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMaxJumpHeight() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxJumpHeight");

	Params::CharacterMovementComponent_GetMaxJumpHeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMaxJumpHeightWithJumpTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMaxJumpHeightWithJumpTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaxJumpHeightWithJumpTime");

	Params::CharacterMovementComponent_GetMaxJumpHeightWithJumpTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMinAnalogSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetMinAnalogSpeed() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinAnalogSpeed");

	Params::CharacterMovementComponent_GetMinAnalogSpeed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMovementBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UCharacterMovementComponent::GetMovementBase() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMovementBase");

	Params::CharacterMovementComponent_GetMovementBase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetPerchRadiusThreshold() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPerchRadiusThreshold");

	Params::CharacterMovementComponent_GetPerchRadiusThreshold Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetValidPerchRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::GetValidPerchRadius() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetValidPerchRadius");

	Params::CharacterMovementComponent_GetValidPerchRadius Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.IsWalkable
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterMovementComponent::IsWalkable(const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsWalkable");

	Params::CharacterMovementComponent_IsWalkable Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.IsWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterMovementComponent::IsWalking() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsWalking");

	Params::CharacterMovementComponent_IsWalking Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.K2_ComputeFloorDist
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          CapsuleLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LineDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SweepDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SweepRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFindFloorResult                 FloorResult                                            (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::K2_ComputeFloorDist(const struct FVector& CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, struct FFindFloorResult* FloorResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_ComputeFloorDist");

	Params::CharacterMovementComponent_K2_ComputeFloorDist Parms{};

	Parms.CapsuleLocation = std::move(CapsuleLocation);
	Parms.LineDistance = LineDistance;
	Parms.SweepDistance = SweepDistance;
	Parms.SweepRadius = SweepRadius;

	UObject::ProcessEvent(Func, &Parms);

	if (FloorResult != nullptr)
		*FloorResult = std::move(Parms.FloorResult);
}


// Function Engine.CharacterMovementComponent.K2_FindFloor
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          CapsuleLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFindFloorResult                 FloorResult                                            (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCharacterMovementComponent::K2_FindFloor(const struct FVector& CapsuleLocation, struct FFindFloorResult* FloorResult) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_FindFloor");

	Params::CharacterMovementComponent_K2_FindFloor Parms{};

	Parms.CapsuleLocation = std::move(CapsuleLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (FloorResult != nullptr)
		*FloorResult = std::move(Parms.FloorResult);
}


// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::K2_GetWalkableFloorAngle() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetWalkableFloorAngle");

	Params::CharacterMovementComponent_K2_GetWalkableFloorAngle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterMovementComponent::K2_GetWalkableFloorZ() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetWalkableFloorZ");

	Params::CharacterMovementComponent_K2_GetWalkableFloorZ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.AddCameraLensEffect
// (Native, Public)
// Parameters:
// TSubclassOf<class AEmitterCameraLensEffectBase>LensEffectEmitterClass                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEmitterCameraLensEffectBase*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEmitterCameraLensEffectBase* APlayerCameraManager::AddCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddCameraLensEffect");

	Params::PlayerCameraManager_AddCameraLensEffect Parms{};

	Parms.LensEffectEmitterClass = LensEffectEmitterClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.AddGenericCameraLensEffect
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               LensEffectEmitterClass                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class ICameraLensEffectInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TScriptInterface<class ICameraLensEffectInterface> APlayerCameraManager::AddGenericCameraLensEffect(TSubclassOf<class AActor> LensEffectEmitterClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddGenericCameraLensEffect");

	Params::PlayerCameraManager_AddGenericCameraLensEffect Parms{};

	Parms.LensEffectEmitterClass = LensEffectEmitterClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.AddNewCameraModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraModifier>      ModifierClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraModifier*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraModifier* APlayerCameraManager::AddNewCameraModifier(TSubclassOf<class UCameraModifier> ModifierClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddNewCameraModifier");

	Params::PlayerCameraManager_AddNewCameraModifier Parms{};

	Parms.ModifierClass = ModifierClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.BlueprintUpdateCamera
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           CameraTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewCameraLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewCameraRotation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   NewCameraFOV                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCameraManager::BlueprintUpdateCamera(class AActor* CameraTarget, struct FVector* NewCameraLocation, struct FRotator* NewCameraRotation, float* NewCameraFOV)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BlueprintUpdateCamera");

	Params::PlayerCameraManager_BlueprintUpdateCamera Parms{};

	Parms.CameraTarget = CameraTarget;

	UObject::ProcessEvent(Func, &Parms);

	if (NewCameraLocation != nullptr)
		*NewCameraLocation = std::move(Parms.NewCameraLocation);

	if (NewCameraRotation != nullptr)
		*NewCameraRotation = std::move(Parms.NewCameraRotation);

	if (NewCameraFOV != nullptr)
		*NewCameraFOV = Parms.NewCameraFOV;

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.ClearCameraLensEffects
// (Native, Public, BlueprintCallable)

void APlayerCameraManager::ClearCameraLensEffects()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ClearCameraLensEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerCameraManager.FindCameraModifierByClass
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraModifier>      ModifierClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraModifier*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraModifier* APlayerCameraManager::FindCameraModifierByClass(TSubclassOf<class UCameraModifier> ModifierClass)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindCameraModifierByClass");

	Params::PlayerCameraManager_FindCameraModifierByClass Parms{};

	Parms.ModifierClass = ModifierClass;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureEnd
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void APlayerCameraManager::OnPhotographyMultiPartCaptureEnd()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPhotographyMultiPartCaptureEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureStart
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void APlayerCameraManager::OnPhotographyMultiPartCaptureStart()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPhotographyMultiPartCaptureStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerCameraManager.OnPhotographySessionEnd
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void APlayerCameraManager::OnPhotographySessionEnd()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPhotographySessionEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerCameraManager.OnPhotographySessionStart
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void APlayerCameraManager::OnPhotographySessionStart()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPhotographySessionStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerCameraManager.PhotographyCameraModify
// (BlueprintCosmetic, Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          NewCameraLocation                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PreviousCameraLocation                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OriginalCameraLocation                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ResultCameraLocation                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::PhotographyCameraModify(const struct FVector& NewCameraLocation, const struct FVector& PreviousCameraLocation, const struct FVector& OriginalCameraLocation, struct FVector* ResultCameraLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PhotographyCameraModify");

	Params::PlayerCameraManager_PhotographyCameraModify Parms{};

	Parms.NewCameraLocation = std::move(NewCameraLocation);
	Parms.PreviousCameraLocation = std::move(PreviousCameraLocation);
	Parms.OriginalCameraLocation = std::move(OriginalCameraLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (ResultCameraLocation != nullptr)
		*ResultCameraLocation = std::move(Parms.ResultCameraLocation);
}


// Function Engine.PlayerCameraManager.PlayCameraAnim
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UCameraAnim*                      Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendInTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRandomStartTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraShakePlaySpace                   Playspace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         UserPlaySpaceRot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UCameraAnimInst*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraAnimInst* APlayerCameraManager::PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, ECameraShakePlaySpace Playspace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayCameraAnim");

	Params::PlayerCameraManager_PlayCameraAnim Parms{};

	Parms.Anim = Anim;
	Parms.Rate = Rate;
	Parms.Scale = Scale;
	Parms.BlendInTime = BlendInTime;
	Parms.BlendOutTime = BlendOutTime;
	Parms.bLoop = bLoop;
	Parms.bRandomStartTime = bRandomStartTime;
	Parms.Duration = Duration;
	Parms.Playspace = Playspace;
	Parms.UserPlaySpaceRot = std::move(UserPlaySpaceRot);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.RemoveCameraLensEffect
// (Native, Public)
// Parameters:
// class AEmitterCameraLensEffectBase*     Emitter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveCameraLensEffect");

	Params::PlayerCameraManager_RemoveCameraLensEffect Parms{};

	Parms.Emitter = Emitter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.RemoveCameraModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraModifier*                  ModifierToRemove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCameraManager::RemoveCameraModifier(class UCameraModifier* ModifierToRemove)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveCameraModifier");

	Params::PlayerCameraManager_RemoveCameraModifier Parms{};

	Parms.ModifierToRemove = ModifierToRemove;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.RemoveGenericCameraLensEffect
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ICameraLensEffectInterface>Emitter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::RemoveGenericCameraLensEffect(TScriptInterface<class ICameraLensEffectInterface> Emitter)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveGenericCameraLensEffect");

	Params::PlayerCameraManager_RemoveGenericCameraLensEffect Parms{};

	Parms.Emitter = Emitter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.SetGameCameraCutThisFrame
// (Native, Public, BlueprintCallable)

void APlayerCameraManager::SetGameCameraCutThisFrame()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGameCameraCutThisFrame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerCameraManager.SetManualCameraFade
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   InFadeAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInFadeAudio                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::SetManualCameraFade(float InFadeAmount, const struct FLinearColor& Color, bool bInFadeAudio)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetManualCameraFade");

	Params::PlayerCameraManager_SetManualCameraFade Parms{};

	Parms.InFadeAmount = InFadeAmount;
	Parms.Color = std::move(Color);
	Parms.bInFadeAudio = bInFadeAudio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StartCameraFade
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   FromAlpha                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ToAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldFadeAudio                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHoldWhenFinished                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StartCameraFade(float FromAlpha, float ToAlpha, float Duration, const struct FLinearColor& Color, bool bShouldFadeAudio, bool bHoldWhenFinished)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartCameraFade");

	Params::PlayerCameraManager_StartCameraFade Parms{};

	Parms.FromAlpha = FromAlpha;
	Parms.ToAlpha = ToAlpha;
	Parms.Duration = Duration;
	Parms.Color = std::move(Color);
	Parms.bShouldFadeAudio = bShouldFadeAudio;
	Parms.bHoldWhenFinished = bHoldWhenFinished;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StartCameraShake
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     ShakeClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraShakePlaySpace                   Playspace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         UserPlaySpaceRot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UCameraShakeBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraShakeBase* APlayerCameraManager::StartCameraShake(TSubclassOf<class UCameraShakeBase> ShakeClass, float Scale, ECameraShakePlaySpace Playspace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartCameraShake");

	Params::PlayerCameraManager_StartCameraShake Parms{};

	Parms.ShakeClass = ShakeClass;
	Parms.Scale = Scale;
	Parms.Playspace = Playspace;
	Parms.UserPlaySpaceRot = std::move(UserPlaySpaceRot);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.StartCameraShakeFromSource
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     ShakeClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraShakeSourceComponent*      SourceComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraShakePlaySpace                   Playspace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         UserPlaySpaceRot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UCameraShakeBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraShakeBase* APlayerCameraManager::StartCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> ShakeClass, class UCameraShakeSourceComponent* SourceComponent, float Scale, ECameraShakePlaySpace Playspace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartCameraShakeFromSource");

	Params::PlayerCameraManager_StartCameraShakeFromSource Parms{};

	Parms.ShakeClass = ShakeClass;
	Parms.SourceComponent = SourceComponent;
	Parms.Scale = Scale;
	Parms.Playspace = Playspace;
	Parms.UserPlaySpaceRot = std::move(UserPlaySpaceRot);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.StopAllCameraAnims
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllCameraAnims(bool bImmediate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllCameraAnims");

	Params::PlayerCameraManager_StopAllCameraAnims Parms{};

	Parms.bImmediate = bImmediate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StopAllCameraShakes
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllCameraShakes(bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllCameraShakes");

	Params::PlayerCameraManager_StopAllCameraShakes Parms{};

	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StopAllCameraShakesFromSource
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraShakeSourceComponent*      SourceComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllCameraShakesFromSource(class UCameraShakeSourceComponent* SourceComponent, bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllCameraShakesFromSource");

	Params::PlayerCameraManager_StopAllCameraShakesFromSource Parms{};

	Parms.SourceComponent = SourceComponent;
	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraAnim*                      Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllInstancesOfCameraAnim(class UCameraAnim* Anim, bool bImmediate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllInstancesOfCameraAnim");

	Params::PlayerCameraManager_StopAllInstancesOfCameraAnim Parms{};

	Parms.Anim = Anim;
	Parms.bImmediate = bImmediate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     Shake                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllInstancesOfCameraShake(TSubclassOf<class UCameraShakeBase> Shake, bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllInstancesOfCameraShake");

	Params::PlayerCameraManager_StopAllInstancesOfCameraShake Parms{};

	Parms.Shake = Shake;
	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShakeFromSource
// (Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     Shake                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraShakeSourceComponent*      SourceComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopAllInstancesOfCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> Shake, class UCameraShakeSourceComponent* SourceComponent, bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllInstancesOfCameraShakeFromSource");

	Params::PlayerCameraManager_StopAllInstancesOfCameraShakeFromSource Parms{};

	Parms.Shake = Shake;
	Parms.SourceComponent = SourceComponent;
	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StopCameraAnimInst
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraAnimInst*                  AnimInst                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopCameraAnimInst(class UCameraAnimInst* AnimInst, bool bImmediate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopCameraAnimInst");

	Params::PlayerCameraManager_StopCameraAnimInst Parms{};

	Parms.AnimInst = AnimInst;
	Parms.bImmediate = bImmediate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.StopCameraFade
// (Native, Public, BlueprintCallable)

void APlayerCameraManager::StopCameraFade()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopCameraFade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerCameraManager.StopCameraShake
// (Native, Public, BlueprintCallable)
// Parameters:
// class UCameraShakeBase*                 ShakeInstance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCameraManager::StopCameraShake(class UCameraShakeBase* ShakeInstance, bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopCameraShake");

	Params::PlayerCameraManager_StopCameraShake Parms{};

	Parms.ShakeInstance = ShakeInstance;
	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerCameraManager.SwapPendingViewTargetWhenUsingClientSideCameraUpdates
// (Final, Native, Protected)

void APlayerCameraManager::SwapPendingViewTargetWhenUsingClientSideCameraUpdates()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SwapPendingViewTargetWhenUsingClientSideCameraUpdates");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerCameraManager.GetCameraLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector APlayerCameraManager::GetCameraLocation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCameraLocation");

	Params::PlayerCameraManager_GetCameraLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.GetCameraRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator APlayerCameraManager::GetCameraRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCameraRotation");

	Params::PlayerCameraManager_GetCameraRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.GetFOVAngle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerCameraManager::GetFOVAngle() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFOVAngle");

	Params::PlayerCameraManager_GetFOVAngle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerCameraManager.GetOwningPlayerController
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* APlayerCameraManager::GetOwningPlayerController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwningPlayerController");

	Params::PlayerCameraManager_GetOwningPlayerController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerState.OnRep_bIsInactive
// (Native, Public)

void APlayerState::OnRep_bIsInactive()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bIsInactive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerState.OnRep_PlayerId
// (Native, Public)

void APlayerState::OnRep_PlayerId()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_PlayerId");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerState.OnRep_PlayerName
// (Native, Public)

void APlayerState::OnRep_PlayerName()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_PlayerName");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerState.OnRep_Score
// (Native, Public)

void APlayerState::OnRep_Score()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Score");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerState.OnRep_UniqueId
// (Native, Public)

void APlayerState::OnRep_UniqueId()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_UniqueId");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PlayerState.ReceiveCopyProperties
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerState*                     NewPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerState::ReceiveCopyProperties(class APlayerState* NewPlayerState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveCopyProperties");

	Params::PlayerState_ReceiveCopyProperties Parms{};

	Parms.NewPlayerState = NewPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerState.ReceiveOverrideWith
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerState*                     OldPlayerState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerState::ReceiveOverrideWith(class APlayerState* OldPlayerState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveOverrideWith");

	Params::PlayerState_ReceiveOverrideWith Parms{};

	Parms.OldPlayerState = OldPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlayerState.BP_GetUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl APlayerState::BP_GetUniqueId() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BP_GetUniqueId");

	Params::PlayerState_BP_GetUniqueId Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerState.GetPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* APlayerState::GetPawn() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPawn");

	Params::PlayerState_GetPawn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerState.GetPingInMilliseconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APlayerState::GetPingInMilliseconds() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPingInMilliseconds");

	Params::PlayerState_GetPingInMilliseconds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerState.GetPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* APlayerState::GetPlayerController() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayerController");

	Params::PlayerState_GetPlayerController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerState.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APlayerState::GetPlayerName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayerName");

	Params::PlayerState_GetPlayerName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlayerState.IsOnlyASpectator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerState::IsOnlyASpectator() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsOnlyASpectator");

	Params::PlayerState_IsOnlyASpectator Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Light.OnRep_bEnabled
// (Native, Public)

void ALight::OnRep_bEnabled()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Light.SetAffectTranslucentLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetAffectTranslucentLighting(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAffectTranslucentLighting");

	Params::Light_SetAffectTranslucentLighting Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Light.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewBrightness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetBrightness(float NewBrightness)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBrightness");

	Params::Light_SetBrightness Parms{};

	Parms.NewBrightness = NewBrightness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Light.SetCastShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetCastShadows(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCastShadows");

	Params::Light_SetCastShadows Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Light.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSetEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetEnabled(bool bSetEnabled)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnabled");

	Params::Light_SetEnabled Parms{};

	Parms.bSetEnabled = bSetEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Light.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewLightColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetLightColor(const struct FLinearColor& NewLightColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightColor");

	Params::Light_SetLightColor Parms{};

	Parms.NewLightColor = std::move(NewLightColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Light.SetLightFunctionFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLightFunctionFadeDistance                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFunctionFadeDistance");

	Params::Light_SetLightFunctionFadeDistance Parms{};

	Parms.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Light.SetLightFunctionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               NewLightFunctionMaterial                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFunctionMaterial");

	Params::Light_SetLightFunctionMaterial Parms{};

	Parms.NewLightFunctionMaterial = NewLightFunctionMaterial;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Light.SetLightFunctionScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLightFunctionScale                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALight::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFunctionScale");

	Params::Light_SetLightFunctionScale Parms{};

	Parms.NewLightFunctionScale = std::move(NewLightFunctionScale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Light.ToggleEnabled
// (Final, Native, Public, BlueprintCallable)

void ALight::ToggleEnabled()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.Light.GetBrightness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALight::GetBrightness() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBrightness");

	Params::Light_GetBrightness Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Light.GetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ALight::GetLightColor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLightColor");

	Params::Light_GetLightColor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Light.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALight::IsEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsEnabled");

	Params::Light_IsEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SpotLight.SetInnerConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewInnerConeAngle                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpotLight::SetInnerConeAngle(float NewInnerConeAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInnerConeAngle");

	Params::SpotLight_SetInnerConeAngle Parms{};

	Parms.NewInnerConeAngle = NewInnerConeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SpotLight.SetOuterConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewOuterConeAngle                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpotLight::SetOuterConeAngle(float NewOuterConeAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOuterConeAngle");

	Params::SpotLight_SetOuterConeAngle Parms{};

	Parms.NewOuterConeAngle = NewOuterConeAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CapsuleComponent.SetCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCapsuleHalfHeight");

	Params::CapsuleComponent_SetCapsuleHalfHeight Parms{};

	Parms.HalfHeight = HalfHeight;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CapsuleComponent.SetCapsuleRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::SetCapsuleRadius(float Radius, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCapsuleRadius");

	Params::CapsuleComponent_SetCapsuleRadius Parms{};

	Parms.Radius = Radius;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CapsuleComponent.SetCapsuleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHalfHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateOverlaps                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCapsuleSize");

	Params::CapsuleComponent_SetCapsuleSize Parms{};

	Parms.InRadius = InRadius;
	Parms.InHalfHeight = InHalfHeight;
	Parms.bUpdateOverlaps = bUpdateOverlaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetScaledCapsuleHalfHeight() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledCapsuleHalfHeight");

	Params::CapsuleComponent_GetScaledCapsuleHalfHeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetScaledCapsuleHalfHeight_WithoutHemisphere() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledCapsuleHalfHeight_WithoutHemisphere");

	Params::CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetScaledCapsuleRadius() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledCapsuleRadius");

	Params::CapsuleComponent_GetScaledCapsuleRadius Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutHalfHeight                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::GetScaledCapsuleSize(float* OutRadius, float* OutHalfHeight) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledCapsuleSize");

	Params::CapsuleComponent_GetScaledCapsuleSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeight != nullptr)
		*OutHalfHeight = Parms.OutHalfHeight;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleSize_WithoutHemisphere
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutHalfHeightWithoutHemisphere                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::GetScaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetScaledCapsuleSize_WithoutHemisphere");

	Params::CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeightWithoutHemisphere != nullptr)
		*OutHalfHeightWithoutHemisphere = Parms.OutHalfHeightWithoutHemisphere;
}


// Function Engine.CapsuleComponent.GetShapeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetShapeScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetShapeScale");

	Params::CapsuleComponent_GetShapeScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetUnscaledCapsuleHalfHeight() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnscaledCapsuleHalfHeight");

	Params::CapsuleComponent_GetUnscaledCapsuleHalfHeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetUnscaledCapsuleHalfHeight_WithoutHemisphere() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnscaledCapsuleHalfHeight_WithoutHemisphere");

	Params::CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCapsuleComponent::GetUnscaledCapsuleRadius() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnscaledCapsuleRadius");

	Params::CapsuleComponent_GetUnscaledCapsuleRadius Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutHalfHeight                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::GetUnscaledCapsuleSize(float* OutRadius, float* OutHalfHeight) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnscaledCapsuleSize");

	Params::CapsuleComponent_GetUnscaledCapsuleSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeight != nullptr)
		*OutHalfHeight = Parms.OutHalfHeight;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize_WithoutHemisphere
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   OutRadius                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutHalfHeightWithoutHemisphere                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCapsuleComponent::GetUnscaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnscaledCapsuleSize_WithoutHemisphere");

	Params::CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutRadius != nullptr)
		*OutRadius = Parms.OutRadius;

	if (OutHalfHeightWithoutHemisphere != nullptr)
		*OutHalfHeightWithoutHemisphere = Parms.OutHalfHeightWithoutHemisphere;
}


// Function Engine.MaterialInterface.GetBaseMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterial*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterial* UMaterialInterface::GetBaseMaterial()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBaseMaterial");

	Params::MaterialInterface_GetBaseMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInterface.SetForceMipLevelsToBeResident
// (RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    OverrideForceMiplevelsToBeResident                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceMiplevelsToBeResidentValue                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForceDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CinematicTextureGroups                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFastResponse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInterface::SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, int32 CinematicTextureGroups, bool bFastResponse)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForceMipLevelsToBeResident");

	Params::MaterialInterface_SetForceMipLevelsToBeResident Parms{};

	Parms.OverrideForceMiplevelsToBeResident = OverrideForceMiplevelsToBeResident;
	Parms.bForceMiplevelsToBeResidentValue = bForceMiplevelsToBeResidentValue;
	Parms.ForceDuration = ForceDuration;
	Parms.CinematicTextureGroups = CinematicTextureGroups;
	Parms.bFastResponse = bFastResponse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInterface.GetParameterInfo
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMaterialParameterAssociation           Association                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialFunctionInterface*       LayerFunction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMaterialParameterInfo           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMaterialParameterInfo UMaterialInterface::GetParameterInfo(EMaterialParameterAssociation Association, class FName ParameterName, class UMaterialFunctionInterface* LayerFunction) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParameterInfo");

	Params::MaterialInterface_GetParameterInfo Parms{};

	Parms.Association = Association;
	Parms.ParameterName = ParameterName;
	Parms.LayerFunction = LayerFunction;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInterface.GetPhysicalMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPhysicalMaterial*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* UMaterialInterface::GetPhysicalMaterial() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicalMaterial");

	Params::MaterialInterface_GetPhysicalMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInterface.GetPhysicalMaterialFromMap
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* UMaterialInterface::GetPhysicalMaterialFromMap(int32 Index_0) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicalMaterialFromMap");

	Params::MaterialInterface_GetPhysicalMaterialFromMap Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInterface.GetPhysicalMaterialMask
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPhysicalMaterialMask*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterialMask* UMaterialInterface::GetPhysicalMaterialMask() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPhysicalMaterialMask");

	Params::MaterialInterface_GetPhysicalMaterialMask Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkyLight.OnRep_bEnabled
// (Native, Public)

void ASkyLight::OnRep_bEnabled()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.VOIPTalker.CreateTalkerForPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     OwningState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVOIPTalker*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVOIPTalker* UVOIPTalker::CreateTalkerForPlayer(class APlayerState* OwningState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateTalkerForPlayer");

	Params::VOIPTalker_CreateTalkerForPlayer Parms{};

	Parms.OwningState = OwningState;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.VOIPTalker.BPOnTalkingBegin
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVOIPTalker::BPOnTalkingBegin(class UAudioComponent* AudioComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BPOnTalkingBegin");

	Params::VOIPTalker_BPOnTalkingBegin Parms{};

	Parms.AudioComponent = AudioComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VOIPTalker.BPOnTalkingEnd
// (Native, Event, Protected, BlueprintEvent)

void UVOIPTalker::BPOnTalkingEnd()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BPOnTalkingEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.VOIPTalker.GetVoiceLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVOIPTalker::GetVoiceLevel()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetVoiceLevel");

	Params::VOIPTalker_GetVoiceLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.VOIPTalker.RegisterWithPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     OwningState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVOIPTalker::RegisterWithPlayerState(class APlayerState* OwningState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RegisterWithPlayerState");

	Params::VOIPTalker_RegisterWithPlayerState Parms{};

	Parms.OwningState = OwningState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Exporter.RunAssetExportTask
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAssetExportTask*                 Task                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExporter::RunAssetExportTask(class UAssetExportTask* Task)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RunAssetExportTask");

	Params::Exporter_RunAssetExportTask Parms{};

	Parms.Task = Task;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Exporter.RunAssetExportTasks
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UAssetExportTask*>         ExportTasks                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExporter::RunAssetExportTasks(const TArray<class UAssetExportTask*>& ExportTasks)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RunAssetExportTasks");

	Params::Exporter_RunAssetExportTasks Parms{};

	Parms.ExportTasks = std::move(ExportTasks);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Exporter.ScriptRunAssetExportTask
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAssetExportTask*                 Task                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UExporter::ScriptRunAssetExportTask(class UAssetExportTask* Task)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScriptRunAssetExportTask");

	Params::Exporter_ScriptRunAssetExportTask Parms{};

	Parms.Task = Task;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.K2_GetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaterialInstanceConstant::K2_GetScalarParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetScalarParameterValue");

	Params::MaterialInstanceConstant_K2_GetScalarParameterValue Parms{};

	Parms.ParameterName = ParameterName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.K2_GetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UMaterialInstanceConstant::K2_GetTextureParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetTextureParameterValue");

	Params::MaterialInstanceConstant_K2_GetTextureParameterValue Parms{};

	Parms.ParameterName = ParameterName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.K2_GetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UMaterialInstanceConstant::K2_GetVectorParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetVectorParameterValue");

	Params::MaterialInstanceConstant_K2_GetVectorParameterValue Parms{};

	Parms.ParameterName = ParameterName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesLerpAlongAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     StartColor                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     EndColor                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVertexPaintAxis                        Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToSRGB                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshVertexPainterKismetLibrary::PaintVerticesLerpAlongAxis(class UStaticMeshComponent* StaticMeshComponent, const struct FLinearColor& StartColor, const struct FLinearColor& EndColor, EVertexPaintAxis Axis, bool bConvertToSRGB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PaintVerticesLerpAlongAxis");

	Params::MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.StartColor = std::move(StartColor);
	Parms.EndColor = std::move(EndColor);
	Parms.Axis = Axis;
	Parms.bConvertToSRGB = bConvertToSRGB;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesSingleColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     FillColor                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToSRGB                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshVertexPainterKismetLibrary::PaintVerticesSingleColor(class UStaticMeshComponent* StaticMeshComponent, const struct FLinearColor& FillColor, bool bConvertToSRGB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PaintVerticesSingleColor");

	Params::MeshVertexPainterKismetLibrary_PaintVerticesSingleColor Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.FillColor = std::move(FillColor);
	Parms.bConvertToSRGB = bConvertToSRGB;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.MeshVertexPainterKismetLibrary.RemovePaintedVertices
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeshVertexPainterKismetLibrary::RemovePaintedVertices(class UStaticMeshComponent* StaticMeshComponent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RemovePaintedVertices");

	Params::MeshVertexPainterKismetLibrary_RemovePaintedVertices Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BillboardComponent.SetOpacityMaskRefVal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RefVal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBillboardComponent::SetOpacityMaskRefVal(float RefVal)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOpacityMaskRefVal");

	Params::BillboardComponent_SetOpacityMaskRefVal Parms{};

	Parms.RefVal = RefVal;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.BillboardComponent.SetSprite
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       NewSprite                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBillboardComponent::SetSprite(class UTexture2D* NewSprite)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSprite");

	Params::BillboardComponent_SetSprite Parms{};

	Parms.NewSprite = NewSprite;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.BillboardComponent.SetSpriteAndUV
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       NewSprite                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewU                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewUL                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewV                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewVL                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBillboardComponent::SetSpriteAndUV(class UTexture2D* NewSprite, int32 NewU, int32 NewUL, int32 NewV, int32 NewVL)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSpriteAndUV");

	Params::BillboardComponent_SetSpriteAndUV Parms{};

	Parms.NewSprite = NewSprite;
	Parms.NewU = NewU;
	Parms.NewUL = NewUL;
	Parms.NewV = NewV;
	Parms.NewVL = NewVL;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.BillboardComponent.SetUV
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewU                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewUL                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewV                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewVL                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBillboardComponent::SetUV(int32 NewU, int32 NewUL, int32 NewV, int32 NewVL)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUV");

	Params::BillboardComponent_SetUV Parms{};

	Parms.NewU = NewU;
	Parms.NewUL = NewUL;
	Parms.NewV = NewV;
	Parms.NewVL = NewVL;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ActorSoundParameterInterface.GetActorSoundParams
// (Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TArray<struct FAudioParameter>          Params_0                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void IActorSoundParameterInterface::GetActorSoundParams(TArray<struct FAudioParameter>* Params_0) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActorSoundParams");

	Params::ActorSoundParameterInterface_GetActorSoundParams Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Params_0 != nullptr)
		*Params_0 = std::move(Parms.Params_0);
}


// Function Engine.AmbientSound.AdjustVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   AdjustVolumeDuration                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdjustVolumeLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbientSound::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AdjustVolume");

	Params::AmbientSound_AdjustVolume Parms{};

	Parms.AdjustVolumeDuration = AdjustVolumeDuration;
	Parms.AdjustVolumeLevel = AdjustVolumeLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AmbientSound.FadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeInDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolumeLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbientSound::FadeIn(float FadeInDuration, float FadeVolumeLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FadeIn");

	Params::AmbientSound_FadeIn Parms{};

	Parms.FadeInDuration = FadeInDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AmbientSound.FadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeOutDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeVolumeLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbientSound::FadeOut(float FadeOutDuration, float FadeVolumeLevel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FadeOut");

	Params::AmbientSound_FadeOut Parms{};

	Parms.FadeOutDuration = FadeOutDuration;
	Parms.FadeVolumeLevel = FadeVolumeLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AmbientSound.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAmbientSound::Play(float StartTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Play");

	Params::AmbientSound_Play Parms{};

	Parms.StartTime = StartTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AmbientSound.Stop
// (Final, Native, Public, BlueprintCallable)

void AAmbientSound::Stop()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Stop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SplineMeshComponent.SetBoundaryMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBoundaryMax                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoundaryMax");

	Params::SplineMeshComponent_SetBoundaryMax Parms{};

	Parms.InBoundaryMax = InBoundaryMax;
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetBoundaryMin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBoundaryMin                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoundaryMin");

	Params::SplineMeshComponent_SetBoundaryMin Parms{};

	Parms.InBoundaryMin = InBoundaryMin;
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetEndOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        EndOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndOffset(const struct FVector2D& EndOffset, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEndOffset");

	Params::SplineMeshComponent_SetEndOffset Parms{};

	Parms.EndOffset = std::move(EndOffset);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetEndPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          EndPos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndPosition(const struct FVector& EndPos, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEndPosition");

	Params::SplineMeshComponent_SetEndPosition Parms{};

	Parms.EndPos = std::move(EndPos);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetEndRoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   EndRoll                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndRoll(float EndRoll, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEndRoll");

	Params::SplineMeshComponent_SetEndRoll Parms{};

	Parms.EndRoll = EndRoll;
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetEndScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        EndScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndScale(const struct FVector2D& EndScale, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEndScale");

	Params::SplineMeshComponent_SetEndScale Parms{};

	Parms.EndScale = std::move(EndScale);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetEndTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          EndTangent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetEndTangent(const struct FVector& EndTangent, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEndTangent");

	Params::SplineMeshComponent_SetEndTangent Parms{};

	Parms.EndTangent = std::move(EndTangent);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetForwardAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESplineMeshAxis                         InForwardAxis                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetForwardAxis(ESplineMeshAxis InForwardAxis, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetForwardAxis");

	Params::SplineMeshComponent_SetForwardAxis Parms{};

	Parms.InForwardAxis = InForwardAxis;
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetSplineUpDir
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InSplineUpDir                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetSplineUpDir(const struct FVector& InSplineUpDir, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSplineUpDir");

	Params::SplineMeshComponent_SetSplineUpDir Parms{};

	Parms.InSplineUpDir = std::move(InSplineUpDir);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetStartAndEnd
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartPos                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartTangent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndPos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndTangent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartAndEnd(const struct FVector& StartPos, const struct FVector& StartTangent, const struct FVector& EndPos, const struct FVector& EndTangent, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStartAndEnd");

	Params::SplineMeshComponent_SetStartAndEnd Parms{};

	Parms.StartPos = std::move(StartPos);
	Parms.StartTangent = std::move(StartTangent);
	Parms.EndPos = std::move(EndPos);
	Parms.EndTangent = std::move(EndTangent);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetStartOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        StartOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartOffset(const struct FVector2D& StartOffset, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStartOffset");

	Params::SplineMeshComponent_SetStartOffset Parms{};

	Parms.StartOffset = std::move(StartOffset);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetStartPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartPos                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartPosition(const struct FVector& StartPos, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStartPosition");

	Params::SplineMeshComponent_SetStartPosition Parms{};

	Parms.StartPos = std::move(StartPos);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetStartRoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartRoll                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartRoll(float StartRoll, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStartRoll");

	Params::SplineMeshComponent_SetStartRoll Parms{};

	Parms.StartRoll = StartRoll;
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetStartScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        StartScale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartScale(const struct FVector2D& StartScale, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStartScale");

	Params::SplineMeshComponent_SetStartScale Parms{};

	Parms.StartScale = std::move(StartScale);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.SetStartTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartTangent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMesh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMeshComponent::SetStartTangent(const struct FVector& StartTangent, bool bUpdateMesh)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStartTangent");

	Params::SplineMeshComponent_SetStartTangent Parms{};

	Parms.StartTangent = std::move(StartTangent);
	Parms.bUpdateMesh = bUpdateMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SplineMeshComponent.UpdateMesh
// (Final, Native, Public, BlueprintCallable)

void USplineMeshComponent::UpdateMesh()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SplineMeshComponent.GetBoundaryMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineMeshComponent::GetBoundaryMax() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoundaryMax");

	Params::SplineMeshComponent_GetBoundaryMax Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetBoundaryMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineMeshComponent::GetBoundaryMin() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoundaryMin");

	Params::SplineMeshComponent_GetBoundaryMin Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USplineMeshComponent::GetEndOffset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEndOffset");

	Params::SplineMeshComponent_GetEndOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetEndPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEndPosition");

	Params::SplineMeshComponent_GetEndPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineMeshComponent::GetEndRoll() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEndRoll");

	Params::SplineMeshComponent_GetEndRoll Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USplineMeshComponent::GetEndScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEndScale");

	Params::SplineMeshComponent_GetEndScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetEndTangent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEndTangent");

	Params::SplineMeshComponent_GetEndTangent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetForwardAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESplineMeshAxis                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESplineMeshAxis USplineMeshComponent::GetForwardAxis() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetForwardAxis");

	Params::SplineMeshComponent_GetForwardAxis Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetSplineUpDir
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetSplineUpDir() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSplineUpDir");

	Params::SplineMeshComponent_GetSplineUpDir Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USplineMeshComponent::GetStartOffset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStartOffset");

	Params::SplineMeshComponent_GetStartOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetStartPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStartPosition");

	Params::SplineMeshComponent_GetStartPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USplineMeshComponent::GetStartRoll() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStartRoll");

	Params::SplineMeshComponent_GetStartRoll Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D USplineMeshComponent::GetStartScale() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStartScale");

	Params::SplineMeshComponent_GetStartScale Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USplineMeshComponent::GetStartTangent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStartTangent");

	Params::SplineMeshComponent_GetStartTangent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyMirrorInspectionLibrary.GetMirrorDataTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UMirrorDataTable*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMirrorDataTable* UAnimNotifyMirrorInspectionLibrary::GetMirrorDataTable(const struct FAnimNotifyEventReference& EventReference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMirrorDataTable");

	Params::AnimNotifyMirrorInspectionLibrary_GetMirrorDataTable Parms{};

	Parms.EventReference = std::move(EventReference);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyMirrorInspectionLibrary.IsTriggeredByMirroredAnimation
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyMirrorInspectionLibrary::IsTriggeredByMirroredAnimation(const struct FAnimNotifyEventReference& EventReference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsTriggeredByMirroredAnimation");

	Params::AnimNotifyMirrorInspectionLibrary_IsTriggeredByMirroredAnimation Parms{};

	Parms.EventReference = std::move(EventReference);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyStateMachineInspectionLibrary.IsTriggeredByState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StateName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyStateMachineInspectionLibrary::IsTriggeredByState(const struct FAnimNotifyEventReference& EventReference, class UAnimInstance* AnimInstance, class FName StateName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsTriggeredByState");

	Params::AnimNotifyStateMachineInspectionLibrary_IsTriggeredByState Parms{};

	Parms.EventReference = std::move(EventReference);
	Parms.AnimInstance = AnimInstance;
	Parms.StateName = StateName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyStateMachineInspectionLibrary.IsTriggeredByStateInStateMachine
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StateMachineName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StateName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyStateMachineInspectionLibrary::IsTriggeredByStateInStateMachine(const struct FAnimNotifyEventReference& EventReference, class UAnimInstance* AnimInstance, class FName StateMachineName, class FName StateName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsTriggeredByStateInStateMachine");

	Params::AnimNotifyStateMachineInspectionLibrary_IsTriggeredByStateInStateMachine Parms{};

	Parms.EventReference = std::move(EventReference);
	Parms.AnimInstance = AnimInstance;
	Parms.StateMachineName = StateMachineName;
	Parms.StateName = StateName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyStateMachineInspectionLibrary.IsTriggeredByStateMachine
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimNotifyEventReference        EventReference                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StateMachineName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyStateMachineInspectionLibrary::IsTriggeredByStateMachine(const struct FAnimNotifyEventReference& EventReference, class UAnimInstance* AnimInstance, class FName StateMachineName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsTriggeredByStateMachine");

	Params::AnimNotifyStateMachineInspectionLibrary_IsTriggeredByStateMachine Parms{};

	Parms.EventReference = std::move(EventReference);
	Parms.AnimInstance = AnimInstance;
	Parms.StateMachineName = StateMachineName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimNotifyState_Trail.OverridePSTemplate
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* UAnimNotifyState_Trail::OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OverridePSTemplate");

	Params::AnimNotifyState_Trail_OverridePSTemplate Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimSingleNodeInstance.GetLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimSingleNodeInstance::GetLength()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLength");

	Params::AnimSingleNodeInstance_GetLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimSingleNodeInstance.GetMirrorDataTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UMirrorDataTable*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMirrorDataTable* UAnimSingleNodeInstance::GetMirrorDataTable()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMirrorDataTable");

	Params::AnimSingleNodeInstance_GetMirrorDataTable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimSingleNodeInstance.PlayAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsLooping                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStartPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayAnim");

	Params::AnimSingleNodeInstance_PlayAnim Parms{};

	Parms.bIsLooping = bIsLooping;
	Parms.InPlayRate = InPlayRate;
	Parms.InStartPosition = InStartPosition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetAnimationAsset
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimationAsset*                  NewAsset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLooping                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetAnimationAsset(class UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAnimationAsset");

	Params::AnimSingleNodeInstance_SetAnimationAsset Parms{};

	Parms.NewAsset = NewAsset;
	Parms.bIsLooping = bIsLooping;
	Parms.InPlayRate = InPlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetBlendSpacePosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InPosition                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetBlendSpacePosition(const struct FVector& InPosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBlendSpacePosition");

	Params::AnimSingleNodeInstance_SetBlendSpacePosition Parms{};

	Parms.InPosition = std::move(InPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetLooping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsLooping                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetLooping(bool bIsLooping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLooping");

	Params::AnimSingleNodeInstance_SetLooping Parms{};

	Parms.bIsLooping = bIsLooping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetMirrorDataTable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMirrorDataTable*                 MirrorDataTable                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetMirrorDataTable(const class UMirrorDataTable* MirrorDataTable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMirrorDataTable");

	Params::AnimSingleNodeInstance_SetMirrorDataTable Parms{};

	Parms.MirrorDataTable = MirrorDataTable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsPlaying                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPlaying(bool bIsPlaying)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlaying");

	Params::AnimSingleNodeInstance_SetPlaying Parms{};

	Parms.bIsPlaying = bIsPlaying;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPlayRate(float InPlayRate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlayRate");

	Params::AnimSingleNodeInstance_SetPlayRate Parms{};

	Parms.InPlayRate = InPlayRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireNotifies                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPosition(float InPosition, bool bFireNotifies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPosition");

	Params::AnimSingleNodeInstance_SetPosition Parms{};

	Parms.InPosition = InPosition;
	Parms.bFireNotifies = bFireNotifies;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetPositionWithPreviousTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPreviousTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireNotifies                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPositionWithPreviousTime");

	Params::AnimSingleNodeInstance_SetPositionWithPreviousTime Parms{};

	Parms.InPosition = InPosition;
	Parms.InPreviousTime = InPreviousTime;
	Parms.bFireNotifies = bFireNotifies;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetPreviewCurveOverride
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PoseName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveIfZero                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetPreviewCurveOverride(const class FName& PoseName, float Value, bool bRemoveIfZero)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPreviewCurveOverride");

	Params::AnimSingleNodeInstance_SetPreviewCurveOverride Parms{};

	Parms.PoseName = PoseName;
	Parms.Value = Value;
	Parms.bRemoveIfZero = bRemoveIfZero;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.SetReverse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInReverse                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimSingleNodeInstance::SetReverse(bool bInReverse)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetReverse");

	Params::AnimSingleNodeInstance_SetReverse Parms{};

	Parms.bInReverse = bInReverse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimSingleNodeInstance.StopAnim
// (Final, Native, Public, BlueprintCallable)

void UAnimSingleNodeInstance::StopAnim()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAnim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.AnimSingleNodeInstance.GetAnimationAsset
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimationAsset*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationAsset* UAnimSingleNodeInstance::GetAnimationAsset() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAnimationAsset");

	Params::AnimSingleNodeInstance_GetAnimationAsset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ArrowComponent.SetArrowColor
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewColor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArrowComponent::SetArrowColor(const struct FLinearColor& NewColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetArrowColor");

	Params::ArrowComponent_SetArrowColor Parms{};

	Parms.NewColor = std::move(NewColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AsyncActionHandleSaveGame.AsyncLoadGameFromSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncActionHandleSaveGame*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionHandleSaveGame* UAsyncActionHandleSaveGame::AsyncLoadGameFromSlot(class UObject* WorldContextObject, const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsyncLoadGameFromSlot");

	Params::AsyncActionHandleSaveGame_AsyncLoadGameFromSlot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AsyncActionHandleSaveGame.AsyncSaveGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGameObject_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncActionHandleSaveGame*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionHandleSaveGame* UAsyncActionHandleSaveGame::AsyncSaveGameToSlot(class UObject* WorldContextObject, class USaveGame* SaveGameObject_0, const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsyncSaveGameToSlot");

	Params::AsyncActionHandleSaveGame_AsyncSaveGameToSlot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SaveGameObject_0 = SaveGameObject_0;
	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AsyncActionLoadPrimaryAsset.AsyncLoadPrimaryAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  PrimaryAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     LoadBundles                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionLoadPrimaryAsset*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionLoadPrimaryAsset* UAsyncActionLoadPrimaryAsset::AsyncLoadPrimaryAsset(class UObject* WorldContextObject, const struct FPrimaryAssetId& PrimaryAsset, const TArray<class FName>& LoadBundles)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsyncLoadPrimaryAsset");

	Params::AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAsset = std::move(PrimaryAsset);
	Parms.LoadBundles = std::move(LoadBundles);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AsyncActionLoadPrimaryAssetClass.AsyncLoadPrimaryAssetClass
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  PrimaryAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     LoadBundles                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionLoadPrimaryAssetClass*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionLoadPrimaryAssetClass* UAsyncActionLoadPrimaryAssetClass::AsyncLoadPrimaryAssetClass(class UObject* WorldContextObject, const struct FPrimaryAssetId& PrimaryAsset, const TArray<class FName>& LoadBundles)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsyncLoadPrimaryAssetClass");

	Params::AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAsset = std::move(PrimaryAsset);
	Parms.LoadBundles = std::move(LoadBundles);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AsyncActionLoadPrimaryAssetList.AsyncLoadPrimaryAssetList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          PrimaryAssetList                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     LoadBundles                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionLoadPrimaryAssetList* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionLoadPrimaryAssetList* UAsyncActionLoadPrimaryAssetList::AsyncLoadPrimaryAssetList(class UObject* WorldContextObject, const TArray<struct FPrimaryAssetId>& PrimaryAssetList, const TArray<class FName>& LoadBundles)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsyncLoadPrimaryAssetList");

	Params::AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAssetList = std::move(PrimaryAssetList);
	Parms.LoadBundles = std::move(LoadBundles);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AsyncActionLoadPrimaryAssetClassList.AsyncLoadPrimaryAssetClassList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          PrimaryAssetList                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     LoadBundles                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionLoadPrimaryAssetClassList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionLoadPrimaryAssetClassList* UAsyncActionLoadPrimaryAssetClassList::AsyncLoadPrimaryAssetClassList(class UObject* WorldContextObject, const TArray<struct FPrimaryAssetId>& PrimaryAssetList, const TArray<class FName>& LoadBundles)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsyncLoadPrimaryAssetClassList");

	Params::AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAssetList = std::move(PrimaryAssetList);
	Parms.LoadBundles = std::move(LoadBundles);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForMatchingPrimaryAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     NewBundles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     OldBundles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionChangePrimaryAssetBundles*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionChangePrimaryAssetBundles* UAsyncActionChangePrimaryAssetBundles::AsyncChangeBundleStateForMatchingPrimaryAssets(class UObject* WorldContextObject, const TArray<class FName>& NewBundles, const TArray<class FName>& OldBundles)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsyncChangeBundleStateForMatchingPrimaryAssets");

	Params::AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NewBundles = std::move(NewBundles);
	Parms.OldBundles = std::move(OldBundles);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForPrimaryAssetList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          PrimaryAssetList                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     AddBundles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     RemoveBundles                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAsyncActionChangePrimaryAssetBundles*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncActionChangePrimaryAssetBundles* UAsyncActionChangePrimaryAssetBundles::AsyncChangeBundleStateForPrimaryAssetList(class UObject* WorldContextObject, const TArray<struct FPrimaryAssetId>& PrimaryAssetList, const TArray<class FName>& AddBundles, const TArray<class FName>& RemoveBundles)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsyncChangeBundleStateForPrimaryAssetList");

	Params::AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrimaryAssetList = std::move(PrimaryAssetList);
	Parms.AddBundles = std::move(AddBundles);
	Parms.RemoveBundles = std::move(RemoveBundles);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementCommonActions.DeleteNormalizedElements
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementListProxy           ElementList                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTypedElementSelectionSet*        InSelectionSet                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTypedElementDeletionOptions     DeletionOptions                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTypedElementCommonActions::DeleteNormalizedElements(const struct FTypedElementListProxy& ElementList, class UWorld* World, class UTypedElementSelectionSet* InSelectionSet, const struct FTypedElementDeletionOptions& DeletionOptions)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DeleteNormalizedElements");

	Params::TypedElementCommonActions_DeleteNormalizedElements Parms{};

	Parms.ElementList = std::move(ElementList);
	Parms.World = World;
	Parms.InSelectionSet = InSelectionSet;
	Parms.DeletionOptions = std::move(DeletionOptions);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementCommonActions.DeleteSelectedElements
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTypedElementSelectionSet*        SelectionSet                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTypedElementDeletionOptions     DeletionOptions                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTypedElementCommonActions::DeleteSelectedElements(class UTypedElementSelectionSet* SelectionSet, class UWorld* World, const struct FTypedElementDeletionOptions& DeletionOptions)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DeleteSelectedElements");

	Params::TypedElementCommonActions_DeleteSelectedElements Parms{};

	Parms.SelectionSet = SelectionSet;
	Parms.World = World;
	Parms.DeletionOptions = std::move(DeletionOptions);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementCommonActions.DuplicateNormalizedElements
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementListProxy           ElementList                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationOffset                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTypedElementHandle>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTypedElementHandle> UTypedElementCommonActions::DuplicateNormalizedElements(const struct FTypedElementListProxy& ElementList, class UWorld* World, const struct FVector& LocationOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DuplicateNormalizedElements");

	Params::TypedElementCommonActions_DuplicateNormalizedElements Parms{};

	Parms.ElementList = std::move(ElementList);
	Parms.World = World;
	Parms.LocationOffset = std::move(LocationOffset);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementCommonActions.DuplicateSelectedElements
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UTypedElementSelectionSet*        SelectionSet                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocationOffset                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTypedElementHandle>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTypedElementHandle> UTypedElementCommonActions::DuplicateSelectedElements(const class UTypedElementSelectionSet* SelectionSet, class UWorld* World, const struct FVector& LocationOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DuplicateSelectedElements");

	Params::TypedElementCommonActions_DuplicateSelectedElements Parms{};

	Parms.SelectionSet = SelectionSet;
	Parms.World = World;
	Parms.LocationOffset = std::move(LocationOffset);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkyAtmosphereComponent.GetAtmosphereTransmitanceOnGroundAtPlanetTop
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UDirectionalLightComponent*       DirectionalLight                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor USkyAtmosphereComponent::GetAtmosphereTransmitanceOnGroundAtPlanetTop(class UDirectionalLightComponent* DirectionalLight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAtmosphereTransmitanceOnGroundAtPlanetTop");

	Params::SkyAtmosphereComponent_GetAtmosphereTransmitanceOnGroundAtPlanetTop Parms{};

	Parms.DirectionalLight = DirectionalLight;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SkyAtmosphereComponent.OverrideAtmosphereLightDirection
// (Final, RequiredAPI, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   AtmosphereLightIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LightDirection                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::OverrideAtmosphereLightDirection(int32 AtmosphereLightIndex, const struct FVector& LightDirection)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OverrideAtmosphereLightDirection");

	Params::SkyAtmosphereComponent_OverrideAtmosphereLightDirection Parms{};

	Parms.AtmosphereLightIndex = AtmosphereLightIndex;
	Parms.LightDirection = std::move(LightDirection);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetAerialPespectiveViewDistanceScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetAerialPespectiveViewDistanceScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAerialPespectiveViewDistanceScale");

	Params::SkyAtmosphereComponent_SetAerialPespectiveViewDistanceScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetAtmosphereHeight
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetAtmosphereHeight(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAtmosphereHeight");

	Params::SkyAtmosphereComponent_SetAtmosphereHeight Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetHeightFogContribution
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetHeightFogContribution(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHeightFogContribution");

	Params::SkyAtmosphereComponent_SetHeightFogContribution Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetMieAbsorption
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetMieAbsorption(const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMieAbsorption");

	Params::SkyAtmosphereComponent_SetMieAbsorption Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetMieAbsorptionScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetMieAbsorptionScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMieAbsorptionScale");

	Params::SkyAtmosphereComponent_SetMieAbsorptionScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetMieAnisotropy
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetMieAnisotropy(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMieAnisotropy");

	Params::SkyAtmosphereComponent_SetMieAnisotropy Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetMieExponentialDistribution
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetMieExponentialDistribution(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMieExponentialDistribution");

	Params::SkyAtmosphereComponent_SetMieExponentialDistribution Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetMieScattering
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetMieScattering(const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMieScattering");

	Params::SkyAtmosphereComponent_SetMieScattering Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetMieScatteringScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetMieScatteringScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMieScatteringScale");

	Params::SkyAtmosphereComponent_SetMieScatteringScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetMultiScatteringFactor
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetMultiScatteringFactor(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMultiScatteringFactor");

	Params::SkyAtmosphereComponent_SetMultiScatteringFactor Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetOtherAbsorption
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetOtherAbsorption(const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOtherAbsorption");

	Params::SkyAtmosphereComponent_SetOtherAbsorption Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetOtherAbsorptionScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetOtherAbsorptionScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOtherAbsorptionScale");

	Params::SkyAtmosphereComponent_SetOtherAbsorptionScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetRayleighExponentialDistribution
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetRayleighExponentialDistribution(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRayleighExponentialDistribution");

	Params::SkyAtmosphereComponent_SetRayleighExponentialDistribution Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetRayleighScattering
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetRayleighScattering(const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRayleighScattering");

	Params::SkyAtmosphereComponent_SetRayleighScattering Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetRayleighScatteringScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetRayleighScatteringScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRayleighScatteringScale");

	Params::SkyAtmosphereComponent_SetRayleighScatteringScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyAtmosphereComponent.SetSkyLuminanceFactor
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyAtmosphereComponent::SetSkyLuminanceFactor(const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSkyLuminanceFactor");

	Params::SkyAtmosphereComponent_SetSkyLuminanceFactor Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.DisableGroundScattering
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewGroundScattering                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::DisableGroundScattering(bool NewGroundScattering)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableGroundScattering");

	Params::AtmosphericFogComponent_DisableGroundScattering Parms{};

	Parms.NewGroundScattering = NewGroundScattering;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.DisableSunDisk
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewSunDisk                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::DisableSunDisk(bool NewSunDisk)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableSunDisk");

	Params::AtmosphericFogComponent_DisableSunDisk Parms{};

	Parms.NewSunDisk = NewSunDisk;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetAltitudeScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewAltitudeScale                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetAltitudeScale(float NewAltitudeScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAltitudeScale");

	Params::AtmosphericFogComponent_SetAltitudeScale Parms{};

	Parms.NewAltitudeScale = NewAltitudeScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetDefaultBrightness
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewBrightness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDefaultBrightness(float NewBrightness)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultBrightness");

	Params::AtmosphericFogComponent_SetDefaultBrightness Parms{};

	Parms.NewBrightness = NewBrightness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetDefaultLightColor
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewLightColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDefaultLightColor(const struct FLinearColor& NewLightColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDefaultLightColor");

	Params::AtmosphericFogComponent_SetDefaultLightColor Parms{};

	Parms.NewLightColor = std::move(NewLightColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetDensityMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewDensityMultiplier                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDensityMultiplier(float NewDensityMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDensityMultiplier");

	Params::AtmosphericFogComponent_SetDensityMultiplier Parms{};

	Parms.NewDensityMultiplier = NewDensityMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetDensityOffset
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewDensityOffset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDensityOffset(float NewDensityOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDensityOffset");

	Params::AtmosphericFogComponent_SetDensityOffset Parms{};

	Parms.NewDensityOffset = NewDensityOffset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetDistanceOffset
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewDistanceOffset                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDistanceOffset(float NewDistanceOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDistanceOffset");

	Params::AtmosphericFogComponent_SetDistanceOffset Parms{};

	Parms.NewDistanceOffset = NewDistanceOffset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetDistanceScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewDistanceScale                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetDistanceScale(float NewDistanceScale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDistanceScale");

	Params::AtmosphericFogComponent_SetDistanceScale Parms{};

	Parms.NewDistanceScale = NewDistanceScale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetFogMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewFogMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetFogMultiplier(float NewFogMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFogMultiplier");

	Params::AtmosphericFogComponent_SetFogMultiplier Parms{};

	Parms.NewFogMultiplier = NewFogMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetPrecomputeParams
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DensityHeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxScatteringOrder                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InscatterAltitudeSampleNum                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetPrecomputeParams(float DensityHeight, int32 MaxScatteringOrder, int32 InscatterAltitudeSampleNum)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPrecomputeParams");

	Params::AtmosphericFogComponent_SetPrecomputeParams Parms{};

	Parms.DensityHeight = DensityHeight;
	Parms.MaxScatteringOrder = MaxScatteringOrder;
	Parms.InscatterAltitudeSampleNum = InscatterAltitudeSampleNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetStartDistance
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewStartDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetStartDistance(float NewStartDistance)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStartDistance");

	Params::AtmosphericFogComponent_SetStartDistance Parms{};

	Parms.NewStartDistance = NewStartDistance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AtmosphericFogComponent.SetSunMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewSunMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtmosphericFogComponent::SetSunMultiplier(float NewSunMultiplier)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSunMultiplier");

	Params::AtmosphericFogComponent_SetSunMultiplier Parms{};

	Parms.NewSunMultiplier = NewSunMultiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationAttributeIdentifierExtensions.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimationAttributeIdentifier    Identifier                                             (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationAttributeIdentifierExtensions::IsValid(struct FAnimationAttributeIdentifier& Identifier)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValid");

	Params::AnimationAttributeIdentifierExtensions_IsValid Parms{};

	Parms.Identifier = std::move(Identifier);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Identifier = std::move(Parms.Identifier);

	return Parms.ReturnValue;
}


// Function Engine.AudioPanelWidgetInterface.GetEditorName
// (Event, Public, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IAudioPanelWidgetInterface::GetEditorName()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetEditorName");

	Params::AudioPanelWidgetInterface_GetEditorName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AudioPanelWidgetInterface.GetIconBrushName
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName IAudioPanelWidgetInterface::GetIconBrushName()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIconBrushName");

	Params::AudioPanelWidgetInterface_GetIconBrushName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AutoDestroySubsystem.OnActorEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          EndPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutoDestroySubsystem::OnActorEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnActorEndPlay");

	Params::AutoDestroySubsystem_OnActorEndPlay Parms{};

	Parms.Actor = Actor;
	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintMapLibrary.Map_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Key                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::Map_Add(const TMap<int32, int32>& TargetMap, const int32& Key, const int32& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_Add");

	Params::BlueprintMapLibrary_Map_Add Parms{};

	Parms.TargetMap = std::move(TargetMap);
	Parms.Key = Key;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintMapLibrary.Map_Clear
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::Map_Clear(const TMap<int32, int32>& TargetMap)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_Clear");

	Params::BlueprintMapLibrary_Map_Clear Parms{};

	Parms.TargetMap = std::move(TargetMap);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintMapLibrary.Map_Contains
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Key                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintMapLibrary::Map_Contains(const TMap<int32, int32>& TargetMap, const int32& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_Contains");

	Params::BlueprintMapLibrary_Map_Contains Parms{};

	Parms.TargetMap = std::move(TargetMap);
	Parms.Key = Key;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_Find
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Key                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintMapLibrary::Map_Find(const TMap<int32, int32>& TargetMap, const int32& Key, int32* Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_Find");

	Params::BlueprintMapLibrary_Map_Find Parms{};

	Parms.TargetMap = std::move(TargetMap);
	Parms.Key = Key;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_IsEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintMapLibrary::Map_IsEmpty(const TMap<int32, int32>& TargetMap)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_IsEmpty");

	Params::BlueprintMapLibrary_Map_IsEmpty Parms{};

	Parms.TargetMap = std::move(TargetMap);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_IsNotEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintMapLibrary::Map_IsNotEmpty(const TMap<int32, int32>& TargetMap)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_IsNotEmpty");

	Params::BlueprintMapLibrary_Map_IsNotEmpty Parms{};

	Parms.TargetMap = std::move(TargetMap);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_Keys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           Keys                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::Map_Keys(const TMap<int32, int32>& TargetMap, TArray<int32>* Keys)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_Keys");

	Params::BlueprintMapLibrary_Map_Keys Parms{};

	Parms.TargetMap = std::move(TargetMap);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Keys != nullptr)
		*Keys = std::move(Parms.Keys);
}


// Function Engine.BlueprintMapLibrary.Map_Length
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintMapLibrary::Map_Length(const TMap<int32, int32>& TargetMap)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_Length");

	Params::BlueprintMapLibrary_Map_Length Parms{};

	Parms.TargetMap = std::move(TargetMap);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Key                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintMapLibrary::Map_Remove(const TMap<int32, int32>& TargetMap, const int32& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_Remove");

	Params::BlueprintMapLibrary_Map_Remove Parms{};

	Parms.TargetMap = std::move(TargetMap);
	Parms.Key = Key;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_Values
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<int32, int32>                      TargetMap                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           Values                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::Map_Values(const TMap<int32, int32>& TargetMap, TArray<int32>* Values)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Map_Values");

	Params::BlueprintMapLibrary_Map_Values Parms{};

	Parms.TargetMap = std::move(TargetMap);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Values != nullptr)
		*Values = std::move(Parms.Values);
}


// Function Engine.BlueprintMapLibrary.SetMapPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, int32>                      Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintMapLibrary::SetMapPropertyByName(class UObject* Object, class FName PropertyName, const TMap<int32, int32>& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetMapPropertyByName");

	Params::BlueprintMapLibrary_SetMapPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintPathsLibrary.AutomationDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::AutomationDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AutomationDir");

	Params::BlueprintPathsLibrary_AutomationDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.AutomationLogDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::AutomationLogDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AutomationLogDir");

	Params::BlueprintPathsLibrary_AutomationLogDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.AutomationTransientDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::AutomationTransientDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AutomationTransientDir");

	Params::BlueprintPathsLibrary_AutomationTransientDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.BugItDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::BugItDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BugItDir");

	Params::BlueprintPathsLibrary_BugItDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ChangeExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InNewExtension                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ChangeExtension(const class FString& InPath, const class FString& InNewExtension)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ChangeExtension");

	Params::BlueprintPathsLibrary_ChangeExtension Parms{};

	Parms.InPath = std::move(InPath);
	Parms.InNewExtension = std::move(InNewExtension);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.CloudDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::CloudDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CloudDir");

	Params::BlueprintPathsLibrary_CloudDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.CollapseRelativeDirectories
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::CollapseRelativeDirectories(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CollapseRelativeDirectories");

	Params::BlueprintPathsLibrary_CollapseRelativeDirectories Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.Combine
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   InPaths                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::Combine(const TArray<class FString>& InPaths)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Combine");

	Params::BlueprintPathsLibrary_Combine Parms{};

	Parms.InPaths = std::move(InPaths);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ConvertFromSandboxPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InSandboxName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ConvertFromSandboxPath(const class FString& InPath, const class FString& InSandboxName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertFromSandboxPath");

	Params::BlueprintPathsLibrary_ConvertFromSandboxPath Parms{};

	Parms.InPath = std::move(InPath);
	Parms.InSandboxName = std::move(InSandboxName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ConvertRelativePathToFull
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InBasePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ConvertRelativePathToFull(const class FString& InPath, const class FString& InBasePath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertRelativePathToFull");

	Params::BlueprintPathsLibrary_ConvertRelativePathToFull Parms{};

	Parms.InPath = std::move(InPath);
	Parms.InBasePath = std::move(InBasePath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ConvertToSandboxPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InSandboxName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ConvertToSandboxPath(const class FString& InPath, const class FString& InSandboxName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertToSandboxPath");

	Params::BlueprintPathsLibrary_ConvertToSandboxPath Parms{};

	Parms.InPath = std::move(InPath);
	Parms.InSandboxName = std::move(InSandboxName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.CreateTempFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Extension                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::CreateTempFilename(const class FString& Path, const class FString& Prefix, const class FString& Extension)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateTempFilename");

	Params::BlueprintPathsLibrary_CreateTempFilename Parms{};

	Parms.Path = std::move(Path);
	Parms.Prefix = std::move(Prefix);
	Parms.Extension = std::move(Extension);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.DiffDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::DiffDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DiffDir");

	Params::BlueprintPathsLibrary_DiffDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.DirectoryExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::DirectoryExists(const class FString& InPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DirectoryExists");

	Params::BlueprintPathsLibrary_DirectoryExists Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineConfigDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EngineConfigDir");

	Params::BlueprintPathsLibrary_EngineConfigDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineContentDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineContentDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EngineContentDir");

	Params::BlueprintPathsLibrary_EngineContentDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EngineDir");

	Params::BlueprintPathsLibrary_EngineDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineIntermediateDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineIntermediateDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EngineIntermediateDir");

	Params::BlueprintPathsLibrary_EngineIntermediateDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EnginePluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EnginePluginsDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EnginePluginsDir");

	Params::BlueprintPathsLibrary_EnginePluginsDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineSavedDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EngineSavedDir");

	Params::BlueprintPathsLibrary_EngineSavedDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineSourceDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineSourceDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EngineSourceDir");

	Params::BlueprintPathsLibrary_EngineSourceDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineUserDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EngineUserDir");

	Params::BlueprintPathsLibrary_EngineUserDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineVersionAgnosticUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EngineVersionAgnosticUserDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EngineVersionAgnosticUserDir");

	Params::BlueprintPathsLibrary_EngineVersionAgnosticUserDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EnterpriseDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EnterpriseDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EnterpriseDir");

	Params::BlueprintPathsLibrary_EnterpriseDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EnterpriseFeaturePackDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EnterpriseFeaturePackDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EnterpriseFeaturePackDir");

	Params::BlueprintPathsLibrary_EnterpriseFeaturePackDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EnterprisePluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::EnterprisePluginsDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EnterprisePluginsDir");

	Params::BlueprintPathsLibrary_EnterprisePluginsDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.FeaturePackDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::FeaturePackDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FeaturePackDir");

	Params::BlueprintPathsLibrary_FeaturePackDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.FileExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::FileExists(const class FString& InPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FileExists");

	Params::BlueprintPathsLibrary_FileExists Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GameAgnosticSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GameAgnosticSavedDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GameAgnosticSavedDir");

	Params::BlueprintPathsLibrary_GameAgnosticSavedDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GameDevelopersDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GameDevelopersDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GameDevelopersDir");

	Params::BlueprintPathsLibrary_GameDevelopersDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GameSourceDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GameSourceDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GameSourceDir");

	Params::BlueprintPathsLibrary_GameSourceDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GameUserDeveloperDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GameUserDeveloperDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GameUserDeveloperDir");

	Params::BlueprintPathsLibrary_GameUserDeveloperDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GeneratedConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GeneratedConfigDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GeneratedConfigDir");

	Params::BlueprintPathsLibrary_GeneratedConfigDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetBaseFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemovePath                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetBaseFilename(const class FString& InPath, bool bRemovePath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetBaseFilename");

	Params::BlueprintPathsLibrary_GetBaseFilename Parms{};

	Parms.InPath = std::move(InPath);
	Parms.bRemovePath = bRemovePath;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetCleanFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetCleanFilename(const class FString& InPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCleanFilename");

	Params::BlueprintPathsLibrary_GetCleanFilename Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetEditorLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FString>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FString> UBlueprintPathsLibrary::GetEditorLocalizationPaths()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEditorLocalizationPaths");

	Params::BlueprintPathsLibrary_GetEditorLocalizationPaths Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetEngineLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FString>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FString> UBlueprintPathsLibrary::GetEngineLocalizationPaths()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEngineLocalizationPaths");

	Params::BlueprintPathsLibrary_GetEngineLocalizationPaths Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetExtension(const class FString& InPath, bool bIncludeDot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetExtension");

	Params::BlueprintPathsLibrary_GetExtension Parms{};

	Parms.InPath = std::move(InPath);
	Parms.bIncludeDot = bIncludeDot;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetGameLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FString>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FString> UBlueprintPathsLibrary::GetGameLocalizationPaths()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameLocalizationPaths");

	Params::BlueprintPathsLibrary_GetGameLocalizationPaths Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetInvalidFileSystemChars
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetInvalidFileSystemChars()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetInvalidFileSystemChars");

	Params::BlueprintPathsLibrary_GetInvalidFileSystemChars Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetPath(const class FString& InPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPath");

	Params::BlueprintPathsLibrary_GetPath Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetProjectFilePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetProjectFilePath()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProjectFilePath");

	Params::BlueprintPathsLibrary_GetProjectFilePath Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetPropertyNameLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FString>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FString> UBlueprintPathsLibrary::GetPropertyNameLocalizationPaths()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPropertyNameLocalizationPaths");

	Params::BlueprintPathsLibrary_GetPropertyNameLocalizationPaths Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetRelativePathToRoot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::GetRelativePathToRoot()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRelativePathToRoot");

	Params::BlueprintPathsLibrary_GetRelativePathToRoot Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetRestrictedFolderNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FString>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FString> UBlueprintPathsLibrary::GetRestrictedFolderNames()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRestrictedFolderNames");

	Params::BlueprintPathsLibrary_GetRestrictedFolderNames Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetToolTipLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<class FString>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FString> UBlueprintPathsLibrary::GetToolTipLocalizationPaths()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetToolTipLocalizationPaths");

	Params::BlueprintPathsLibrary_GetToolTipLocalizationPaths Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.HasProjectPersistentDownloadDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::HasProjectPersistentDownloadDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HasProjectPersistentDownloadDir");

	Params::BlueprintPathsLibrary_HasProjectPersistentDownloadDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsDrive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsDrive(const class FString& InPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsDrive");

	Params::BlueprintPathsLibrary_IsDrive Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsProjectFilePathSet
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsProjectFilePathSet()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsProjectFilePathSet");

	Params::BlueprintPathsLibrary_IsProjectFilePathSet Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsRelative
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsRelative(const class FString& InPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsRelative");

	Params::BlueprintPathsLibrary_IsRelative Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsRestrictedPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsRestrictedPath(const class FString& InPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsRestrictedPath");

	Params::BlueprintPathsLibrary_IsRestrictedPath Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsSamePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PathA                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PathB                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::IsSamePath(const class FString& PathA, const class FString& PathB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsSamePath");

	Params::BlueprintPathsLibrary_IsSamePath Parms{};

	Parms.PathA = std::move(PathA);
	Parms.PathB = std::move(PathB);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.LaunchDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::LaunchDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LaunchDir");

	Params::BlueprintPathsLibrary_LaunchDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.MakePathRelativeTo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InRelativeTo                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::MakePathRelativeTo(const class FString& InPath, const class FString& InRelativeTo, class FString* OutPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakePathRelativeTo");

	Params::BlueprintPathsLibrary_MakePathRelativeTo Parms{};

	Parms.InPath = std::move(InPath);
	Parms.InRelativeTo = std::move(InRelativeTo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.MakePlatformFilename
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::MakePlatformFilename(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakePlatformFilename");

	Params::BlueprintPathsLibrary_MakePlatformFilename Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);
}


// Function Engine.BlueprintPathsLibrary.MakeStandardFilename
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::MakeStandardFilename(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeStandardFilename");

	Params::BlueprintPathsLibrary_MakeStandardFilename Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);
}


// Function Engine.BlueprintPathsLibrary.MakeValidFileName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InReplacementChar                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::MakeValidFileName(const class FString& InString, const class FString& InReplacementChar)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeValidFileName");

	Params::BlueprintPathsLibrary_MakeValidFileName Parms{};

	Parms.InString = std::move(InString);
	Parms.InReplacementChar = std::move(InReplacementChar);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.NormalizeDirectoryName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::NormalizeDirectoryName(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NormalizeDirectoryName");

	Params::BlueprintPathsLibrary_NormalizeDirectoryName Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);
}


// Function Engine.BlueprintPathsLibrary.NormalizeFilename
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::NormalizeFilename(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NormalizeFilename");

	Params::BlueprintPathsLibrary_NormalizeFilename Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);
}


// Function Engine.BlueprintPathsLibrary.ProfilingDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProfilingDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProfilingDir");

	Params::BlueprintPathsLibrary_ProfilingDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectConfigDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectConfigDir");

	Params::BlueprintPathsLibrary_ProjectConfigDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectContentDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectContentDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectContentDir");

	Params::BlueprintPathsLibrary_ProjectContentDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectDir");

	Params::BlueprintPathsLibrary_ProjectDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectIntermediateDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectIntermediateDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectIntermediateDir");

	Params::BlueprintPathsLibrary_ProjectIntermediateDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectLogDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectLogDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectLogDir");

	Params::BlueprintPathsLibrary_ProjectLogDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectModsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectModsDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectModsDir");

	Params::BlueprintPathsLibrary_ProjectModsDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectPersistentDownloadDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectPersistentDownloadDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectPersistentDownloadDir");

	Params::BlueprintPathsLibrary_ProjectPersistentDownloadDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectPluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectPluginsDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectPluginsDir");

	Params::BlueprintPathsLibrary_ProjectPluginsDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectSavedDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectSavedDir");

	Params::BlueprintPathsLibrary_ProjectSavedDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ProjectUserDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectUserDir");

	Params::BlueprintPathsLibrary_ProjectUserDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.RemoveDuplicateSlashes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::RemoveDuplicateSlashes(const class FString& InPath, class FString* OutPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RemoveDuplicateSlashes");

	Params::BlueprintPathsLibrary_RemoveDuplicateSlashes Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);
}


// Function Engine.BlueprintPathsLibrary.RootDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::RootDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RootDir");

	Params::BlueprintPathsLibrary_RootDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.SandboxesDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::SandboxesDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SandboxesDir");

	Params::BlueprintPathsLibrary_SandboxesDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ScreenShotDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ScreenShotDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScreenShotDir");

	Params::BlueprintPathsLibrary_ScreenShotDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.SetExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InNewExtension                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::SetExtension(const class FString& InPath, const class FString& InNewExtension)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetExtension");

	Params::BlueprintPathsLibrary_SetExtension Parms{};

	Parms.InPath = std::move(InPath);
	Parms.InNewExtension = std::move(InNewExtension);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.SetProjectFilePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           NewGameProjectFilePath                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::SetProjectFilePath(const class FString& NewGameProjectFilePath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetProjectFilePath");

	Params::BlueprintPathsLibrary_SetProjectFilePath Parms{};

	Parms.NewGameProjectFilePath = std::move(NewGameProjectFilePath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintPathsLibrary.ShaderWorkingDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::ShaderWorkingDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ShaderWorkingDir");

	Params::BlueprintPathsLibrary_ShaderWorkingDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ShouldSaveToUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintPathsLibrary::ShouldSaveToUserDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ShouldSaveToUserDir");

	Params::BlueprintPathsLibrary_ShouldSaveToUserDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.SourceConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::SourceConfigDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SourceConfigDir");

	Params::BlueprintPathsLibrary_SourceConfigDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.Split
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PathPart                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FilenamePart                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ExtensionPart                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::Split(const class FString& InPath, class FString* PathPart, class FString* FilenamePart, class FString* ExtensionPart)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Split");

	Params::BlueprintPathsLibrary_Split Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PathPart != nullptr)
		*PathPart = std::move(Parms.PathPart);

	if (FilenamePart != nullptr)
		*FilenamePart = std::move(Parms.FilenamePart);

	if (ExtensionPart != nullptr)
		*ExtensionPart = std::move(Parms.ExtensionPart);
}


// Function Engine.BlueprintPathsLibrary.ValidatePath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDidSucceed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutReason                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UBlueprintPathsLibrary::ValidatePath(const class FString& InPath, bool* bDidSucceed, class FText* OutReason)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ValidatePath");

	Params::BlueprintPathsLibrary_ValidatePath Parms{};

	Parms.InPath = std::move(InPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (bDidSucceed != nullptr)
		*bDidSucceed = Parms.bDidSucceed;

	if (OutReason != nullptr)
		*OutReason = std::move(Parms.OutReason);
}


// Function Engine.BlueprintPathsLibrary.VideoCaptureDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintPathsLibrary::VideoCaptureDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VideoCaptureDir");

	Params::BlueprintPathsLibrary_VideoCaptureDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.VolumetricCloudComponent.SetbUsePerSampleAtmosphericLightTransmittance
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetbUsePerSampleAtmosphericLightTransmittance(bool NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetbUsePerSampleAtmosphericLightTransmittance");

	Params::VolumetricCloudComponent_SetbUsePerSampleAtmosphericLightTransmittance Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetGroundAlbedo
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                           NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetGroundAlbedo(const struct FColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetGroundAlbedo");

	Params::VolumetricCloudComponent_SetGroundAlbedo Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetLayerBottomAltitude
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetLayerBottomAltitude(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLayerBottomAltitude");

	Params::VolumetricCloudComponent_SetLayerBottomAltitude Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetLayerHeight
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetLayerHeight(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLayerHeight");

	Params::VolumetricCloudComponent_SetLayerHeight Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetMaterial(class UMaterialInterface* NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaterial");

	Params::VolumetricCloudComponent_SetMaterial Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetPlanetRadius
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetPlanetRadius(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlanetRadius");

	Params::VolumetricCloudComponent_SetPlanetRadius Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetReflectionSampleCountScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetReflectionSampleCountScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetReflectionSampleCountScale");

	Params::VolumetricCloudComponent_SetReflectionSampleCountScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetShadowReflectionSampleCountScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetShadowReflectionSampleCountScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowReflectionSampleCountScale");

	Params::VolumetricCloudComponent_SetShadowReflectionSampleCountScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetShadowTracingDistance
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetShadowTracingDistance(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowTracingDistance");

	Params::VolumetricCloudComponent_SetShadowTracingDistance Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetShadowViewSampleCountScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetShadowViewSampleCountScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowViewSampleCountScale");

	Params::VolumetricCloudComponent_SetShadowViewSampleCountScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetSkyLightCloudBottomOcclusion
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetSkyLightCloudBottomOcclusion(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSkyLightCloudBottomOcclusion");

	Params::VolumetricCloudComponent_SetSkyLightCloudBottomOcclusion Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetStopTracingTransmittanceThreshold
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetStopTracingTransmittanceThreshold(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStopTracingTransmittanceThreshold");

	Params::VolumetricCloudComponent_SetStopTracingTransmittanceThreshold Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetTracingMaxDistance
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetTracingMaxDistance(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTracingMaxDistance");

	Params::VolumetricCloudComponent_SetTracingMaxDistance Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetTracingStartMaxDistance
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetTracingStartMaxDistance(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTracingStartMaxDistance");

	Params::VolumetricCloudComponent_SetTracingStartMaxDistance Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VolumetricCloudComponent.SetViewSampleCountScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVolumetricCloudComponent::SetViewSampleCountScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetViewSampleCountScale");

	Params::VolumetricCloudComponent_SetViewSampleCountScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintPlatformLibrary.CancelLocalNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ActivationEvent                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPlatformLibrary::CancelLocalNotification(const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CancelLocalNotification");

	Params::BlueprintPlatformLibrary_CancelLocalNotification Parms{};

	Parms.ActivationEvent = std::move(ActivationEvent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintPlatformLibrary.CancelLocalNotificationById
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   NotificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPlatformLibrary::CancelLocalNotificationById(int32 NotificationId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CancelLocalNotificationById");

	Params::BlueprintPlatformLibrary_CancelLocalNotificationById Parms{};

	Parms.NotificationId = NotificationId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintPlatformLibrary.ClearAllLocalNotifications
// (Final, Native, Static, Public, BlueprintCallable)

void UBlueprintPlatformLibrary::ClearAllLocalNotifications()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClearAllLocalNotifications");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.BlueprintPlatformLibrary.GetDeviceOrientation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EScreenOrientation                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EScreenOrientation UBlueprintPlatformLibrary::GetDeviceOrientation()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDeviceOrientation");

	Params::BlueprintPlatformLibrary_GetDeviceOrientation Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPlatformLibrary.GetLaunchNotification
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    NotificationLaunchedApp                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActivationEvent                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FireDate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPlatformLibrary::GetLaunchNotification(bool* NotificationLaunchedApp, class FString* ActivationEvent, int32* FireDate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLaunchNotification");

	Params::BlueprintPlatformLibrary_GetLaunchNotification Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (NotificationLaunchedApp != nullptr)
		*NotificationLaunchedApp = Parms.NotificationLaunchedApp;

	if (ActivationEvent != nullptr)
		*ActivationEvent = std::move(Parms.ActivationEvent);

	if (FireDate != nullptr)
		*FireDate = Parms.FireDate;
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationAtTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        FireDateTime                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LocalTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Title                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Body                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Action                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ActivationEvent                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintPlatformLibrary::ScheduleLocalNotificationAtTime(const struct FDateTime& FireDateTime, bool LocalTime, const class FText& Title, const class FText& Body, const class FText& Action, const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScheduleLocalNotificationAtTime");

	Params::BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime Parms{};

	Parms.FireDateTime = std::move(FireDateTime);
	Parms.LocalTime = LocalTime;
	Parms.Title = std::move(Title);
	Parms.Body = std::move(Body);
	Parms.Action = std::move(Action);
	Parms.ActivationEvent = std::move(ActivationEvent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeAtTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        FireDateTime                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LocalTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActivationEvent                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintPlatformLibrary::ScheduleLocalNotificationBadgeAtTime(const struct FDateTime& FireDateTime, bool LocalTime, const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScheduleLocalNotificationBadgeAtTime");

	Params::BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime Parms{};

	Parms.FireDateTime = std::move(FireDateTime);
	Parms.LocalTime = LocalTime;
	Parms.ActivationEvent = std::move(ActivationEvent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeFromNow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   inSecondsFromNow                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActivationEvent                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintPlatformLibrary::ScheduleLocalNotificationBadgeFromNow(int32 inSecondsFromNow, const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScheduleLocalNotificationBadgeFromNow");

	Params::BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow Parms{};

	Parms.inSecondsFromNow = inSecondsFromNow;
	Parms.ActivationEvent = std::move(ActivationEvent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationFromNow
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   inSecondsFromNow                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Title                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Body                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Action                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ActivationEvent                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintPlatformLibrary::ScheduleLocalNotificationFromNow(int32 inSecondsFromNow, const class FText& Title, const class FText& Body, const class FText& Action, const class FString& ActivationEvent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ScheduleLocalNotificationFromNow");

	Params::BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow Parms{};

	Parms.inSecondsFromNow = inSecondsFromNow;
	Parms.Title = std::move(Title);
	Parms.Body = std::move(Body);
	Parms.Action = std::move(Action);
	Parms.ActivationEvent = std::move(ActivationEvent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   NewItem                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Add(const TSet<int32>& TargetSet, const int32& NewItem)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_Add");

	Params::BlueprintSetLibrary_Set_Add Parms{};

	Parms.TargetSet = std::move(TargetSet);
	Parms.NewItem = NewItem;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintSetLibrary.Set_AddItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           NewItems                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_AddItems(const TSet<int32>& TargetSet, const TArray<int32>& NewItems)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_AddItems");

	Params::BlueprintSetLibrary_Set_AddItems Parms{};

	Parms.TargetSet = std::move(TargetSet);
	Parms.NewItems = std::move(NewItems);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintSetLibrary.Set_Clear
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Clear(const TSet<int32>& TargetSet)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_Clear");

	Params::BlueprintSetLibrary_Set_Clear Parms{};

	Parms.TargetSet = std::move(TargetSet);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintSetLibrary.Set_Contains
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ItemToFind                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintSetLibrary::Set_Contains(const TSet<int32>& TargetSet, const int32& ItemToFind)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_Contains");

	Params::BlueprintSetLibrary_Set_Contains Parms{};

	Parms.TargetSet = std::move(TargetSet);
	Parms.ItemToFind = ItemToFind;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_Difference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                             Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Difference(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_Difference");

	Params::BlueprintSetLibrary_Set_Difference Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Engine.BlueprintSetLibrary.Set_Intersection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                             Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Intersection(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_Intersection");

	Params::BlueprintSetLibrary_Set_Intersection Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Engine.BlueprintSetLibrary.Set_IsEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintSetLibrary::Set_IsEmpty(const TSet<int32>& TargetSet)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_IsEmpty");

	Params::BlueprintSetLibrary_Set_IsEmpty Parms{};

	Parms.TargetSet = std::move(TargetSet);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_IsNotEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintSetLibrary::Set_IsNotEmpty(const TSet<int32>& TargetSet)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_IsNotEmpty");

	Params::BlueprintSetLibrary_Set_IsNotEmpty Parms{};

	Parms.TargetSet = std::move(TargetSet);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_Length
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintSetLibrary::Set_Length(const TSet<int32>& TargetSet)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_Length");

	Params::BlueprintSetLibrary_Set_Length Parms{};

	Parms.TargetSet = std::move(TargetSet);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Item                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintSetLibrary::Set_Remove(const TSet<int32>& TargetSet, const int32& Item)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_Remove");

	Params::BlueprintSetLibrary_Set_Remove Parms{};

	Parms.TargetSet = std::move(TargetSet);
	Parms.Item = Item;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_RemoveItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             TargetSet                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_RemoveItems(const TSet<int32>& TargetSet, const TArray<int32>& Items)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_RemoveItems");

	Params::BlueprintSetLibrary_Set_RemoveItems Parms{};

	Parms.TargetSet = std::move(TargetSet);
	Parms.Items = std::move(Items);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.BlueprintSetLibrary.Set_ToArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_ToArray(const TSet<int32>& A, TArray<int32>* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_ToArray");

	Params::BlueprintSetLibrary_Set_ToArray Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Engine.BlueprintSetLibrary.Set_Union
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<int32>                             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<int32>                             Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::Set_Union(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set_Union");

	Params::BlueprintSetLibrary_Set_Union Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Engine.BlueprintSetLibrary.SetSetPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<int32>                             Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintSetLibrary::SetSetPropertyByName(class UObject* Object, class FName PropertyName, const TSet<int32>& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetSetPropertyByName");

	Params::BlueprintSetLibrary_SetSetPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.CachedAnimDataLibrary.StateMachine_GetGlobalWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    InAnimInstance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCachedAnimStateData             CachedAnimStateData                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCachedAnimDataLibrary::StateMachine_GetGlobalWeight(class UAnimInstance* InAnimInstance, const struct FCachedAnimStateData& CachedAnimStateData)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StateMachine_GetGlobalWeight");

	Params::CachedAnimDataLibrary_StateMachine_GetGlobalWeight Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.CachedAnimStateData = std::move(CachedAnimStateData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CachedAnimDataLibrary.StateMachine_GetLocalWeight
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    InAnimInstance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCachedAnimStateData             CachedAnimStateData                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCachedAnimDataLibrary::StateMachine_GetLocalWeight(class UAnimInstance* InAnimInstance, const struct FCachedAnimStateData& CachedAnimStateData)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StateMachine_GetLocalWeight");

	Params::CachedAnimDataLibrary_StateMachine_GetLocalWeight Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.CachedAnimStateData = std::move(CachedAnimStateData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CachedAnimDataLibrary.StateMachine_IsStateRelevant
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    InAnimInstance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCachedAnimStateData             CachedAnimStateData                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCachedAnimDataLibrary::StateMachine_IsStateRelevant(class UAnimInstance* InAnimInstance, const struct FCachedAnimStateData& CachedAnimStateData)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StateMachine_IsStateRelevant");

	Params::CachedAnimDataLibrary_StateMachine_IsStateRelevant Parms{};

	Parms.InAnimInstance = InAnimInstance;
	Parms.CachedAnimStateData = std::move(CachedAnimStateData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CameraAnimInst.SetDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAnimInst::SetDuration(float NewDuration)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDuration");

	Params::CameraAnimInst_SetDuration Parms{};

	Parms.NewDuration = NewDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraAnimInst.SetScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAnimInst::SetScale(float NewDuration)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScale");

	Params::CameraAnimInst_SetScale Parms{};

	Parms.NewDuration = NewDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraAnimInst.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAnimInst::Stop(bool bImmediate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Stop");

	Params::CameraAnimInst_Stop Parms{};

	Parms.bImmediate = bImmediate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraLensEffectInterface.GetParticleComponents
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UFXSystemComponent*>       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UFXSystemComponent*> ICameraLensEffectInterface::GetParticleComponents() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetParticleComponents");

	Params::CameraLensEffectInterface_GetParticleComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CameraLensEffectInterface.GetPrimaryParticleComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFXSystemComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemComponent* ICameraLensEffectInterface::GetPrimaryParticleComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPrimaryParticleComponent");

	Params::CameraLensEffectInterface_GetPrimaryParticleComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CameraLensEffectInterfaceClassSupportLibrary.GetInterfaceClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCameraLensInterfaceClassSupport CameraLens                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AActor> UCameraLensEffectInterfaceClassSupportLibrary::GetInterfaceClass(const struct FCameraLensInterfaceClassSupport& CameraLens)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetInterfaceClass");

	Params::CameraLensEffectInterfaceClassSupportLibrary_GetInterfaceClass Parms{};

	Parms.CameraLens = std::move(CameraLens);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CameraLensEffectInterfaceClassSupportLibrary.IsInterfaceClassValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCameraLensInterfaceClassSupport CameraLens                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EInterfaceValidResult                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraLensEffectInterfaceClassSupportLibrary::IsInterfaceClassValid(const struct FCameraLensInterfaceClassSupport& CameraLens, EInterfaceValidResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsInterfaceClassValid");

	Params::CameraLensEffectInterfaceClassSupportLibrary_IsInterfaceClassValid Parms{};

	Parms.CameraLens = std::move(CameraLens);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Engine.CameraLensEffectInterfaceClassSupportLibrary.IsInterfaceValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TScriptInterface<class ICameraLensEffectInterface>CameraLens                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInterfaceValidResult                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraLensEffectInterfaceClassSupportLibrary::IsInterfaceValid(const TScriptInterface<class ICameraLensEffectInterface>& CameraLens, EInterfaceValidResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsInterfaceValid");

	Params::CameraLensEffectInterfaceClassSupportLibrary_IsInterfaceValid Parms{};

	Parms.CameraLens = CameraLens;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Engine.CameraLensEffectInterfaceClassSupportLibrary.SetInterfaceClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCameraLensInterfaceClassSupport Var                                                    (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EInterfaceValidResult                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraLensEffectInterfaceClassSupportLibrary::SetInterfaceClass(TSubclassOf<class AActor> Class_0, struct FCameraLensInterfaceClassSupport& Var, EInterfaceValidResult* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetInterfaceClass");

	Params::CameraLensEffectInterfaceClassSupportLibrary_SetInterfaceClass Parms{};

	Parms.Class_0 = Class_0;
	Parms.Var = std::move(Var);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Var = std::move(Parms.Var);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function Engine.CameraShakeSourceComponent.Start
// (Final, Native, Public, BlueprintCallable)

void UCameraShakeSourceComponent::Start()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Start");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.CameraShakeSourceComponent.StartCameraShake
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     InCameraShake                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECameraShakePlaySpace                   Playspace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         UserPlaySpaceRot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCameraShakeSourceComponent::StartCameraShake(TSubclassOf<class UCameraShakeBase> InCameraShake, float Scale, ECameraShakePlaySpace Playspace, const struct FRotator& UserPlaySpaceRot)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartCameraShake");

	Params::CameraShakeSourceComponent_StartCameraShake Parms{};

	Parms.InCameraShake = InCameraShake;
	Parms.Scale = Scale;
	Parms.Playspace = Playspace;
	Parms.UserPlaySpaceRot = std::move(UserPlaySpaceRot);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraShakeSourceComponent.StopAllCameraShakes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraShakeSourceComponent::StopAllCameraShakes(bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllCameraShakes");

	Params::CameraShakeSourceComponent_StopAllCameraShakes Parms{};

	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraShakeSourceComponent.StopAllCameraShakesOfType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     InCameraShake                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediately                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraShakeSourceComponent::StopAllCameraShakesOfType(TSubclassOf<class UCameraShakeBase> InCameraShake, bool bImmediately)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopAllCameraShakesOfType");

	Params::CameraShakeSourceComponent_StopAllCameraShakesOfType Parms{};

	Parms.InCameraShake = InCameraShake;
	Parms.bImmediately = bImmediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CameraShakeSourceComponent.GetAttenuationFactor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCameraShakeSourceComponent::GetAttenuationFactor(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAttenuationFactor");

	Params::CameraShakeSourceComponent_GetAttenuationFactor Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Canvas.K2_Deproject
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldOrigin                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_Deproject(const struct FVector2D& ScreenPosition, struct FVector* WorldOrigin, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_Deproject");

	Params::Canvas_K2_Deproject Parms{};

	Parms.ScreenPosition = std::move(ScreenPosition);

	UObject::ProcessEvent(Func, &Parms);

	if (WorldOrigin != nullptr)
		*WorldOrigin = std::move(Parms.WorldOrigin);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);
}


// Function Engine.Canvas.K2_DrawBorder
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         BorderTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         BackgroundTexture                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         LeftBorderTexture                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         RightBorderTexture                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         TopBorderTexture                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         BottomBorderTexture                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CoordinatePosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CoordinateSize                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     RenderColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        BorderScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        BackgroundScale                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        PivotPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CornerSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawBorder(class UTexture* BorderTexture, class UTexture* BackgroundTexture, class UTexture* LeftBorderTexture, class UTexture* RightBorderTexture, class UTexture* TopBorderTexture, class UTexture* BottomBorderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, const struct FVector2D& BorderScale, const struct FVector2D& BackgroundScale, float Rotation, const struct FVector2D& PivotPoint, const struct FVector2D& CornerSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawBorder");

	Params::Canvas_K2_DrawBorder Parms{};

	Parms.BorderTexture = BorderTexture;
	Parms.BackgroundTexture = BackgroundTexture;
	Parms.LeftBorderTexture = LeftBorderTexture;
	Parms.RightBorderTexture = RightBorderTexture;
	Parms.TopBorderTexture = TopBorderTexture;
	Parms.BottomBorderTexture = BottomBorderTexture;
	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.ScreenSize = std::move(ScreenSize);
	Parms.CoordinatePosition = std::move(CoordinatePosition);
	Parms.CoordinateSize = std::move(CoordinateSize);
	Parms.RenderColor = std::move(RenderColor);
	Parms.BorderScale = std::move(BorderScale);
	Parms.BackgroundScale = std::move(BackgroundScale);
	Parms.Rotation = Rotation;
	Parms.PivotPoint = std::move(PivotPoint);
	Parms.CornerSize = std::move(CornerSize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_DrawBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     RenderColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawBox(const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, float Thickness, const struct FLinearColor& RenderColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawBox");

	Params::Canvas_K2_DrawBox Parms{};

	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.ScreenSize = std::move(ScreenSize);
	Parms.Thickness = Thickness;
	Parms.RenderColor = std::move(RenderColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_DrawLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ScreenPositionA                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPositionB                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     RenderColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawLine(const struct FVector2D& ScreenPositionA, const struct FVector2D& ScreenPositionB, float Thickness, const struct FLinearColor& RenderColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawLine");

	Params::Canvas_K2_DrawLine Parms{};

	Parms.ScreenPositionA = std::move(ScreenPositionA);
	Parms.ScreenPositionB = std::move(ScreenPositionB);
	Parms.Thickness = Thickness;
	Parms.RenderColor = std::move(RenderColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_DrawMaterial
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               RenderMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CoordinatePosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CoordinateSize                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        PivotPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawMaterial(class UMaterialInterface* RenderMaterial, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, float Rotation, const struct FVector2D& PivotPoint)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawMaterial");

	Params::Canvas_K2_DrawMaterial Parms{};

	Parms.RenderMaterial = RenderMaterial;
	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.ScreenSize = std::move(ScreenSize);
	Parms.CoordinatePosition = std::move(CoordinatePosition);
	Parms.CoordinateSize = std::move(CoordinateSize);
	Parms.Rotation = Rotation;
	Parms.PivotPoint = std::move(PivotPoint);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_DrawMaterialTriangle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               RenderMaterial                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCanvasUVTri>             Triangles                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawMaterialTriangle(class UMaterialInterface* RenderMaterial, const TArray<struct FCanvasUVTri>& Triangles)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawMaterialTriangle");

	Params::Canvas_K2_DrawMaterialTriangle Parms{};

	Parms.RenderMaterial = RenderMaterial;
	Parms.Triangles = std::move(Triangles);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_DrawPolygon
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         RenderTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumberOfSides                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     RenderColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawPolygon(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& Radius, int32 NumberOfSides, const struct FLinearColor& RenderColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawPolygon");

	Params::Canvas_K2_DrawPolygon Parms{};

	Parms.RenderTexture = RenderTexture;
	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.Radius = std::move(Radius);
	Parms.NumberOfSides = NumberOfSides;
	Parms.RenderColor = std::move(RenderColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_DrawText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UFont*                            RenderFont                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RenderText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     RenderColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Kerning                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ShadowColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ShadowOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCentreX                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCentreY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutlined                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     OutlineColor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawText(class UFont* RenderFont, const class FString& RenderText, const struct FVector2D& ScreenPosition, const struct FVector2D& Scale, const struct FLinearColor& RenderColor, float Kerning, const struct FLinearColor& ShadowColor, const struct FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, const struct FLinearColor& OutlineColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawText");

	Params::Canvas_K2_DrawText Parms{};

	Parms.RenderFont = RenderFont;
	Parms.RenderText = std::move(RenderText);
	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.Scale = std::move(Scale);
	Parms.RenderColor = std::move(RenderColor);
	Parms.Kerning = Kerning;
	Parms.ShadowColor = std::move(ShadowColor);
	Parms.ShadowOffset = std::move(ShadowOffset);
	Parms.bCentreX = bCentreX;
	Parms.bCentreY = bCentreY;
	Parms.bOutlined = bOutlined;
	Parms.OutlineColor = std::move(OutlineColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_DrawTexture
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         RenderTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CoordinatePosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        CoordinateSize                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     RenderColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBlendMode                              BlendMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        PivotPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawTexture(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, EBlendMode BlendMode, float Rotation, const struct FVector2D& PivotPoint)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawTexture");

	Params::Canvas_K2_DrawTexture Parms{};

	Parms.RenderTexture = RenderTexture;
	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.ScreenSize = std::move(ScreenSize);
	Parms.CoordinatePosition = std::move(CoordinatePosition);
	Parms.CoordinateSize = std::move(CoordinateSize);
	Parms.RenderColor = std::move(RenderColor);
	Parms.BlendMode = BlendMode;
	Parms.Rotation = Rotation;
	Parms.PivotPoint = std::move(PivotPoint);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_DrawTriangle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         RenderTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCanvasUVTri>             Triangles                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCanvas::K2_DrawTriangle(class UTexture* RenderTexture, const TArray<struct FCanvasUVTri>& Triangles)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_DrawTriangle");

	Params::Canvas_K2_DrawTriangle Parms{};

	Parms.RenderTexture = RenderTexture;
	Parms.Triangles = std::move(Triangles);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.Canvas.K2_Project
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCanvas::K2_Project(const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_Project");

	Params::Canvas_K2_Project Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Canvas.K2_StrLen
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UFont*                            RenderFont                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RenderText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCanvas::K2_StrLen(class UFont* RenderFont, const class FString& RenderText)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_StrLen");

	Params::Canvas_K2_StrLen Parms{};

	Parms.RenderFont = RenderFont;
	Parms.RenderText = std::move(RenderText);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.Canvas.K2_TextSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UFont*                            RenderFont                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RenderText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCanvas::K2_TextSize(class UFont* RenderFont, const class FString& RenderText, const struct FVector2D& Scale)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_TextSize");

	Params::Canvas_K2_TextSize Parms{};

	Parms.RenderFont = RenderFont;
	Parms.RenderText = std::move(RenderText);
	Parms.Scale = std::move(Scale);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCanvasRenderTarget2D>CanvasRenderTarget2DClass                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCanvasRenderTarget2D*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCanvasRenderTarget2D* UCanvasRenderTarget2D::CreateCanvasRenderTarget2D(class UObject* WorldContextObject, TSubclassOf<class UCanvasRenderTarget2D> CanvasRenderTarget2DClass, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateCanvasRenderTarget2D");

	Params::CanvasRenderTarget2D_CreateCanvasRenderTarget2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CanvasRenderTarget2DClass = CanvasRenderTarget2DClass;
	Parms.Width = Width;
	Parms.Height = Height;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CanvasRenderTarget2D.GetSize
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Width                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasRenderTarget2D::GetSize(int32* Width, int32* Height)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSize");

	Params::CanvasRenderTarget2D_GetSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Width != nullptr)
		*Width = Parms.Width;

	if (Height != nullptr)
		*Height = Parms.Height;
}


// Function Engine.CanvasRenderTarget2D.ReceiveUpdate
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCanvas*                          Canvas                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCanvasRenderTarget2D::ReceiveUpdate(class UCanvas* Canvas, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReceiveUpdate");

	Params::CanvasRenderTarget2D_ReceiveUpdate Parms{};

	Parms.Canvas = Canvas;
	Parms.Width = Width;
	Parms.Height = Height;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.CanvasRenderTarget2D.UpdateResource
// (Native, Public, BlueprintCallable)

void UCanvasRenderTarget2D::UpdateResource()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateResource");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ComputeGraphComponent.CreateDataProviders
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSetDefaultBindings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UComputeGraphComponent::CreateDataProviders(bool bSetDefaultBindings)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreateDataProviders");

	Params::ComputeGraphComponent_CreateDataProviders Parms{};

	Parms.bSetDefaultBindings = bSetDefaultBindings;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ComputeGraphComponent.QueueExecute
// (Final, Native, Public, BlueprintCallable)

void UComputeGraphComponent::QueueExecute()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("QueueExecute");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.WorldPartitionStreamingSourceComponent.DisableStreamingSource
// (Final, Native, Public, BlueprintCallable)

void UWorldPartitionStreamingSourceComponent::DisableStreamingSource()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableStreamingSource");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.WorldPartitionStreamingSourceComponent.EnableStreamingSource
// (Final, Native, Public, BlueprintCallable)

void UWorldPartitionStreamingSourceComponent::EnableStreamingSource()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableStreamingSource");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.WorldPartitionStreamingSourceComponent.IsStreamingCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldPartitionStreamingSourceComponent::IsStreamingCompleted() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsStreamingCompleted");

	Params::WorldPartitionStreamingSourceComponent_IsStreamingCompleted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.WorldPartitionStreamingSourceComponent.IsStreamingSourceEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldPartitionStreamingSourceComponent::IsStreamingSourceEnabled() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsStreamingSourceEnabled");

	Params::WorldPartitionStreamingSourceComponent_IsStreamingSourceEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationCurveIdentifierExtensions.GetName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimationCurveIdentifier        Identifier                                             (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAnimationCurveIdentifierExtensions::GetName(struct FAnimationCurveIdentifier& Identifier)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetName");

	Params::AnimationCurveIdentifierExtensions_GetName Parms{};

	Parms.Identifier = std::move(Identifier);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Identifier = std::move(Parms.Identifier);

	return Parms.ReturnValue;
}


// Function Engine.AnimationCurveIdentifierExtensions.GetType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimationCurveIdentifier        Identifier                                             (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ERawCurveTrackTypes                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERawCurveTrackTypes UAnimationCurveIdentifierExtensions::GetType(struct FAnimationCurveIdentifier& Identifier)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetType");

	Params::AnimationCurveIdentifierExtensions_GetType Parms{};

	Parms.Identifier = std::move(Identifier);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Identifier = std::move(Parms.Identifier);

	return Parms.ReturnValue;
}


// Function Engine.AnimationCurveIdentifierExtensions.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnimationCurveIdentifier        Identifier                                             (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimationCurveIdentifierExtensions::IsValid(struct FAnimationCurveIdentifier& Identifier)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValid");

	Params::AnimationCurveIdentifierExtensions_IsValid Parms{};

	Parms.Identifier = std::move(Identifier);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Identifier = std::move(Parms.Identifier);

	return Parms.ReturnValue;
}


// Function Engine.CurveLinearColor.GetClampedLinearColorValue
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UCurveLinearColor::GetClampedLinearColorValue(float InTime) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClampedLinearColorValue");

	Params::CurveLinearColor_GetClampedLinearColorValue Parms{};

	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CurveLinearColor.GetLinearColorValue
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UCurveLinearColor::GetLinearColorValue(float InTime) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLinearColorValue");

	Params::CurveLinearColor_GetLinearColorValue Parms{};

	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CurveLinearColor.GetUnadjustedLinearColorValue
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UCurveLinearColor::GetUnadjustedLinearColorValue(float InTime) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnadjustedLinearColorValue");

	Params::CurveLinearColor_GetUnadjustedLinearColorValue Parms{};

	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CurveLinearColorAtlas.GetCurvePosition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCurveLinearColor*                InCurve                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Position                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCurveLinearColorAtlas::GetCurvePosition(class UCurveLinearColor* InCurve, float* Position)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurvePosition");

	Params::CurveLinearColorAtlas_GetCurvePosition Parms{};

	Parms.InCurve = InCurve;

	UObject::ProcessEvent(Func, &Parms);

	if (Position != nullptr)
		*Position = Parms.Position;

	return Parms.ReturnValue;
}


// Function Engine.CurveSourceInterface.GetBindingName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ICurveSourceInterface::GetBindingName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBindingName");

	Params::CurveSourceInterface_GetBindingName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.CurveSourceInterface.GetCurves
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TArray<struct FNamedCurveValue>         OutValues                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ICurveSourceInterface::GetCurves(TArray<struct FNamedCurveValue>* OutValues) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurves");

	Params::CurveSourceInterface_GetCurves Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutValues != nullptr)
		*OutValues = std::move(Parms.OutValues);
}


// Function Engine.CurveSourceInterface.GetCurveValue
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICurveSourceInterface::GetCurveValue(class FName CurveName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurveValue");

	Params::CurveSourceInterface_GetCurveValue Parms{};

	Parms.CurveName = CurveName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.WorldDataLayers.OnDataLayerStateChanged
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UDataLayer*                       InDataLayer                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataLayerState                         InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWorldDataLayers::OnDataLayerStateChanged(const class UDataLayer* InDataLayer, EDataLayerState InState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnDataLayerStateChanged");

	Params::WorldDataLayers_OnDataLayerStateChanged Parms{};

	Parms.InDataLayer = InDataLayer;
	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.WorldDataLayers.OnRep_ActiveDataLayerNames
// (Final, Native, Protected)

void AWorldDataLayers::OnRep_ActiveDataLayerNames()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_ActiveDataLayerNames");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.WorldDataLayers.OnRep_LoadedDataLayerNames
// (Final, Native, Protected)

void AWorldDataLayers::OnRep_LoadedDataLayerNames()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_LoadedDataLayerNames");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.DataLayer.Equals
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FActorDataLayer                  ActorDataLayer                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataLayer::Equals(const struct FActorDataLayer& ActorDataLayer) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Equals");

	Params::DataLayer_Equals Parms{};

	Parms.ActorDataLayer = std::move(ActorDataLayer);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayer.GetDataLayerLabel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDataLayer::GetDataLayerLabel() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDataLayerLabel");

	Params::DataLayer_GetDataLayerLabel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayer.GetDebugColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UDataLayer::GetDebugColor() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDebugColor");

	Params::DataLayer_GetDebugColor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayer.GetInitialState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDataLayerState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDataLayerState UDataLayer::GetInitialState() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetInitialState");

	Params::DataLayer_GetInitialState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayer.IsDynamicallyLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataLayer::IsDynamicallyLoaded() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsDynamicallyLoaded");

	Params::DataLayer_IsDynamicallyLoaded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayer.IsInitiallyActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataLayer::IsInitiallyActive() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInitiallyActive");

	Params::DataLayer_IsInitiallyActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayer.IsInitiallyVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataLayer::IsInitiallyVisible() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInitiallyVisible");

	Params::DataLayer_IsInitiallyVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayer.IsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDataLayer::IsVisible() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsVisible");

	Params::DataLayer_IsVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayerSubsystem.SetDataLayerState
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FActorDataLayer                  InDataLayer                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EDataLayerState                         InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataLayerSubsystem::SetDataLayerState(const struct FActorDataLayer& InDataLayer, EDataLayerState InState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDataLayerState");

	Params::DataLayerSubsystem_SetDataLayerState Parms{};

	Parms.InDataLayer = std::move(InDataLayer);
	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DataLayerSubsystem.SetDataLayerStateByLabel
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InDataLayerLabel                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataLayerState                         InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDataLayerSubsystem::SetDataLayerStateByLabel(const class FName& InDataLayerLabel, EDataLayerState InState)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDataLayerStateByLabel");

	Params::DataLayerSubsystem_SetDataLayerStateByLabel Parms{};

	Parms.InDataLayerLabel = InDataLayerLabel;
	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DataLayerSubsystem.GetActiveDataLayerNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class FName>                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class FName> UDataLayerSubsystem::GetActiveDataLayerNames() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveDataLayerNames");

	Params::DataLayerSubsystem_GetActiveDataLayerNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayerSubsystem.GetDataLayer
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FActorDataLayer                  InDataLayer                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UDataLayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataLayer* UDataLayerSubsystem::GetDataLayer(const struct FActorDataLayer& InDataLayer) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDataLayer");

	Params::DataLayerSubsystem_GetDataLayer Parms{};

	Parms.InDataLayer = std::move(InDataLayer);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayerSubsystem.GetDataLayerFromLabel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InDataLayerLabel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataLayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataLayer* UDataLayerSubsystem::GetDataLayerFromLabel(class FName InDataLayerLabel) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDataLayerFromLabel");

	Params::DataLayerSubsystem_GetDataLayerFromLabel Parms{};

	Parms.InDataLayerLabel = InDataLayerLabel;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayerSubsystem.GetDataLayerFromName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InDataLayerName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDataLayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDataLayer* UDataLayerSubsystem::GetDataLayerFromName(class FName InDataLayerName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDataLayerFromName");

	Params::DataLayerSubsystem_GetDataLayerFromName Parms{};

	Parms.InDataLayerName = InDataLayerName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayerSubsystem.GetDataLayerState
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FActorDataLayer                  InDataLayer                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EDataLayerState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDataLayerState UDataLayerSubsystem::GetDataLayerState(const struct FActorDataLayer& InDataLayer) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDataLayerState");

	Params::DataLayerSubsystem_GetDataLayerState Parms{};

	Parms.InDataLayer = std::move(InDataLayer);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayerSubsystem.GetDataLayerStateByLabel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InDataLayerLabel                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDataLayerState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDataLayerState UDataLayerSubsystem::GetDataLayerStateByLabel(const class FName& InDataLayerLabel) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDataLayerStateByLabel");

	Params::DataLayerSubsystem_GetDataLayerStateByLabel Parms{};

	Parms.InDataLayerLabel = InDataLayerLabel;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DataLayerSubsystem.GetLoadedDataLayerNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class FName>                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class FName> UDataLayerSubsystem::GetLoadedDataLayerNames() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLoadedDataLayerNames");

	Params::DataLayerSubsystem_GetLoadedDataLayerNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PawnNoiseEmitterComponent.MakeNoise
// (BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           NoiseMaker                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Loudness                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NoiseLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPawnNoiseEmitterComponent::MakeNoise(class AActor* NoiseMaker, float Loudness, const struct FVector& NoiseLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MakeNoise");

	Params::PawnNoiseEmitterComponent_MakeNoise Parms{};

	Parms.NoiseMaker = NoiseMaker;
	Parms.Loudness = Loudness;
	Parms.NoiseLocation = std::move(NoiseLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DecalActor.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* ADecalActor::CreateDynamicMaterialInstance()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreateDynamicMaterialInstance");

	Params::DecalActor_CreateDynamicMaterialInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.DecalActor.SetDecalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               NewDecalMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADecalActor::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDecalMaterial");

	Params::DecalActor_SetDecalMaterial Parms{};

	Parms.NewDecalMaterial = NewDecalMaterial;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DecalActor.GetDecalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* ADecalActor::GetDecalMaterial() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDecalMaterial");

	Params::DecalActor_GetDecalMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.RuntimeVirtualTexture.GetPageTableSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeVirtualTexture::GetPageTableSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPageTableSize");

	Params::RuntimeVirtualTexture_GetPageTableSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.RuntimeVirtualTexture.GetSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeVirtualTexture::GetSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSize");

	Params::RuntimeVirtualTexture_GetSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.RuntimeVirtualTexture.GetTileBorderSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeVirtualTexture::GetTileBorderSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTileBorderSize");

	Params::RuntimeVirtualTexture_GetTileBorderSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.RuntimeVirtualTexture.GetTileCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeVirtualTexture::GetTileCount() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTileCount");

	Params::RuntimeVirtualTexture_GetTileCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.RuntimeVirtualTexture.GetTileSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 URuntimeVirtualTexture::GetTileSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTileSize");

	Params::RuntimeVirtualTexture_GetTileSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.VOIPStatics.SetMicThreshold
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InThreshold                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVOIPStatics::SetMicThreshold(float InThreshold)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetMicThreshold");

	Params::VOIPStatics_SetMicThreshold Parms{};

	Parms.InThreshold = InThreshold;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetAtmosphereSunLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetAtmosphereSunLight(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAtmosphereSunLight");

	Params::DirectionalLightComponent_SetAtmosphereSunLight Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetAtmosphereSunLightIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetAtmosphereSunLightIndex(int32 NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAtmosphereSunLightIndex");

	Params::DirectionalLightComponent_SetAtmosphereSunLightIndex Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetCascadeDistributionExponent(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCascadeDistributionExponent");

	Params::DirectionalLightComponent_SetCascadeDistributionExponent Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetCascadeTransitionFraction(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCascadeTransitionFraction");

	Params::DirectionalLightComponent_SetCascadeTransitionFraction Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetDynamicShadowCascades
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetDynamicShadowCascades(int32 NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDynamicShadowCascades");

	Params::DirectionalLightComponent_SetDynamicShadowCascades Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetDynamicShadowDistanceMovableLight(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDynamicShadowDistanceMovableLight");

	Params::DirectionalLightComponent_SetDynamicShadowDistanceMovableLight Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetDynamicShadowDistanceStationaryLight(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDynamicShadowDistanceStationaryLight");

	Params::DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetEnableLightShaftOcclusion(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEnableLightShaftOcclusion");

	Params::DirectionalLightComponent_SetEnableLightShaftOcclusion Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetLightShaftOverrideDirection(const struct FVector& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightShaftOverrideDirection");

	Params::DirectionalLightComponent_SetLightShaftOverrideDirection Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetOcclusionMaskDarkness(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOcclusionMaskDarkness");

	Params::DirectionalLightComponent_SetOcclusionMaskDarkness Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetShadowAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetShadowAmount(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowAmount");

	Params::DirectionalLightComponent_SetShadowAmount Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalLightComponent::SetShadowDistanceFadeoutFraction(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShadowDistanceFadeoutFraction");

	Params::DirectionalLightComponent_SetShadowDistanceFadeoutFraction Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.KismetGuidLibrary.Conv_GuidToString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                            InGuid                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetGuidLibrary::Conv_GuidToString(const struct FGuid& InGuid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_GuidToString");

	Params::KismetGuidLibrary_Conv_GuidToString Parms{};

	Parms.InGuid = std::move(InGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                            A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetGuidLibrary::EqualEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_GuidGuid");

	Params::KismetGuidLibrary_EqualEqual_GuidGuid Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetGuidLibrary.Invalidate_Guid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            InGuid                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetGuidLibrary::Invalidate_Guid(struct FGuid& InGuid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Invalidate_Guid");

	Params::KismetGuidLibrary_Invalidate_Guid Parms{};

	Parms.InGuid = std::move(InGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	InGuid = std::move(Parms.InGuid);
}


// Function Engine.KismetGuidLibrary.IsValid_Guid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                            InGuid                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetGuidLibrary::IsValid_Guid(const struct FGuid& InGuid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValid_Guid");

	Params::KismetGuidLibrary_IsValid_Guid Parms{};

	Parms.InGuid = std::move(InGuid);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetGuidLibrary.NewGuid
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid UKismetGuidLibrary::NewGuid()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NewGuid");

	Params::KismetGuidLibrary_NewGuid Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetGuidLibrary.NotEqual_GuidGuid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                            A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetGuidLibrary::NotEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_GuidGuid");

	Params::KismetGuidLibrary_NotEqual_GuidGuid Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetGuidLibrary.Parse_StringToGuid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           GuidString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            OutGuid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetGuidLibrary::Parse_StringToGuid(const class FString& GuidString, struct FGuid* OutGuid, bool* Success)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Parse_StringToGuid");

	Params::KismetGuidLibrary_Parse_StringToGuid Parms{};

	Parms.GuidString = std::move(GuidString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutGuid != nullptr)
		*OutGuid = std::move(Parms.OutGuid);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function Engine.SoundEffectPresetWidgetInterface.GetClass
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class USoundEffectPreset>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class USoundEffectPreset> ISoundEffectPresetWidgetInterface::GetClass()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClass");

	Params::SoundEffectPresetWidgetInterface_GetClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SoundEffectPresetWidgetInterface.OnConstructed
// (Event, Public, BlueprintEvent)
// Parameters:
// class USoundEffectPreset*               Preset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISoundEffectPresetWidgetInterface::OnConstructed(class USoundEffectPreset* Preset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnConstructed");

	Params::SoundEffectPresetWidgetInterface_OnConstructed Parms{};

	Parms.Preset = Preset;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundEffectPresetWidgetInterface.OnPropertyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class USoundEffectPreset*               Preset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISoundEffectPresetWidgetInterface::OnPropertyChanged(class USoundEffectPreset* Preset, class FName PropertyName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnPropertyChanged");

	Params::SoundEffectPresetWidgetInterface_OnPropertyChanged Parms{};

	Parms.Preset = Preset;
	Parms.PropertyName = PropertyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.KismetTextLibrary.AsCurrency_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoundingMode                           RoundingMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysSign                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrencyCode                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsCurrency_Float(float Value, ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, const class FString& CurrencyCode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsCurrency_Float");

	Params::KismetTextLibrary_AsCurrency_Float Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;
	Parms.CurrencyCode = std::move(CurrencyCode);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsCurrency_Integer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoundingMode                           RoundingMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysSign                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrencyCode                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsCurrency_Integer(int32 Value, ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, const class FString& CurrencyCode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsCurrency_Integer");

	Params::KismetTextLibrary_AsCurrency_Integer Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;
	Parms.CurrencyCode = std::move(CurrencyCode);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsCurrencyBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   BaseValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrencyCode                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsCurrencyBase(int32 BaseValue, const class FString& CurrencyCode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsCurrencyBase");

	Params::KismetTextLibrary_AsCurrencyBase Parms{};

	Parms.BaseValue = BaseValue;
	Parms.CurrencyCode = std::move(CurrencyCode);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsDate_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        InDateTime                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsDate_DateTime(const struct FDateTime& InDateTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsDate_DateTime");

	Params::KismetTextLibrary_AsDate_DateTime Parms{};

	Parms.InDateTime = std::move(InDateTime);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsDateTime_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        In                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsDateTime_DateTime(const struct FDateTime& In)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsDateTime_DateTime");

	Params::KismetTextLibrary_AsDateTime_DateTime Parms{};

	Parms.In = std::move(In);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsPercent_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoundingMode                           RoundingMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysSign                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsPercent_Float(float Value, ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsPercent_Float");

	Params::KismetTextLibrary_AsPercent_Float Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTime_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        In                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTime_DateTime(const struct FDateTime& In)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsTime_DateTime");

	Params::KismetTextLibrary_AsTime_DateTime Parms{};

	Parms.In = std::move(In);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTimespan_Timespan
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        InTimespan                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTimespan_Timespan(const struct FTimespan& InTimespan)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsTimespan_Timespan");

	Params::KismetTextLibrary_AsTimespan_Timespan Parms{};

	Parms.InTimespan = std::move(InTimespan);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTimeZoneDate_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        InDateTime                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InTimeZone                                             (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTimeZoneDate_DateTime(const struct FDateTime& InDateTime, const class FString& InTimeZone)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsTimeZoneDate_DateTime");

	Params::KismetTextLibrary_AsTimeZoneDate_DateTime Parms{};

	Parms.InDateTime = std::move(InDateTime);
	Parms.InTimeZone = std::move(InTimeZone);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTimeZoneDateTime_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        InDateTime                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InTimeZone                                             (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTimeZoneDateTime_DateTime(const struct FDateTime& InDateTime, const class FString& InTimeZone)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsTimeZoneDateTime_DateTime");

	Params::KismetTextLibrary_AsTimeZoneDateTime_DateTime Parms{};

	Parms.InDateTime = std::move(InDateTime);
	Parms.InTimeZone = std::move(InTimeZone);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTimeZoneTime_DateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        InDateTime                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InTimeZone                                             (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::AsTimeZoneTime_DateTime(const struct FDateTime& InDateTime, const class FString& InTimeZone)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AsTimeZoneTime_DateTime");

	Params::KismetTextLibrary_AsTimeZoneTime_DateTime Parms{};

	Parms.InDateTime = std::move(InDateTime);
	Parms.InTimeZone = std::move(InTimeZone);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_BoolToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InBool                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_BoolToText(bool InBool)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_BoolToText");

	Params::KismetTextLibrary_Conv_BoolToText Parms{};

	Parms.InBool = InBool;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_ByteToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_ByteToText(uint8 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ByteToText");

	Params::KismetTextLibrary_Conv_ByteToText Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_ColorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_ColorToText(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ColorToText");

	Params::KismetTextLibrary_Conv_ColorToText Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_FloatToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERoundingMode                           RoundingMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysSign                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumFractionalDigits                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_FloatToText(float Value, ERoundingMode RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_FloatToText");

	Params::KismetTextLibrary_Conv_FloatToText Parms{};

	Parms.Value = Value;
	Parms.RoundingMode = RoundingMode;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;
	Parms.MinimumFractionalDigits = MinimumFractionalDigits;
	Parms.MaximumFractionalDigits = MaximumFractionalDigits;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_Int64ToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysSign                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_Int64ToText(int64 Value, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Int64ToText");

	Params::KismetTextLibrary_Conv_Int64ToText Parms{};

	Parms.Value = Value;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_IntToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlwaysSign                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseGrouping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinimumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaximumIntegralDigits                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_IntToText(int32 Value, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToText");

	Params::KismetTextLibrary_Conv_IntToText Parms{};

	Parms.Value = Value;
	Parms.bAlwaysSign = bAlwaysSign;
	Parms.bUseGrouping = bUseGrouping;
	Parms.MinimumIntegralDigits = MinimumIntegralDigits;
	Parms.MaximumIntegralDigits = MaximumIntegralDigits;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_NameToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_NameToText(class FName InName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_NameToText");

	Params::KismetTextLibrary_Conv_NameToText Parms{};

	Parms.InName = InName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_ObjectToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InObj                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_ObjectToText(class UObject* InObj)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ObjectToText");

	Params::KismetTextLibrary_Conv_ObjectToText Parms{};

	Parms.InObj = InObj;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_RotatorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_RotatorToText(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_RotatorToText");

	Params::KismetTextLibrary_Conv_RotatorToText Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_StringToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_StringToText(const class FString& InString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToText");

	Params::KismetTextLibrary_Conv_StringToText Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_TextToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetTextLibrary::Conv_TextToString(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_TextToString");

	Params::KismetTextLibrary_Conv_TextToString Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_TransformToText
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       InTrans                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_TransformToText(const struct FTransform& InTrans)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_TransformToText");

	Params::KismetTextLibrary_Conv_TransformToText Parms{};

	Parms.InTrans = std::move(InTrans);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_Vector2dToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_Vector2dToText(const struct FVector2D& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Vector2dToText");

	Params::KismetTextLibrary_Conv_Vector2dToText Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_VectorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Conv_VectorToText(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_VectorToText");

	Params::KismetTextLibrary_Conv_VectorToText Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::EqualEqual_IgnoreCase_TextText(const class FText& A, const class FText& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_IgnoreCase_TextText");

	Params::KismetTextLibrary_EqualEqual_IgnoreCase_TextText Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.EqualEqual_TextText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::EqualEqual_TextText(const class FText& A, const class FText& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_TextText");

	Params::KismetTextLibrary_EqualEqual_TextText Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.FindTextInLocalizationTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Namespace                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutText                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::FindTextInLocalizationTable(const class FString& Namespace, const class FString& Key, class FText* OutText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindTextInLocalizationTable");

	Params::KismetTextLibrary_FindTextInLocalizationTable Parms{};

	Parms.Namespace = std::move(Namespace);
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutText != nullptr)
		*OutText = std::move(Parms.OutText);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.Format
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InPattern                                              (Parm, NativeAccessSpecifierPublic)
// TArray<struct FFormatArgumentData>      InArgs                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::Format(const class FText& InPattern, const TArray<struct FFormatArgumentData>& InArgs)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Format");

	Params::KismetTextLibrary_Format Parms{};

	Parms.InPattern = std::move(InPattern);
	Parms.InArgs = std::move(InArgs);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.GetEmptyText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::GetEmptyText()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEmptyText");

	Params::KismetTextLibrary_GetEmptyText Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.IsPolyglotDataValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPolyglotTextData                PolyglotData                                           (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsValid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ErrorMessage                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UKismetTextLibrary::IsPolyglotDataValid(const struct FPolyglotTextData& PolyglotData, bool* IsValid, class FText* ErrorMessage)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsPolyglotDataValid");

	Params::KismetTextLibrary_IsPolyglotDataValid Parms{};

	Parms.PolyglotData = std::move(PolyglotData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	if (ErrorMessage != nullptr)
		*ErrorMessage = std::move(Parms.ErrorMessage);
}


// Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::NotEqual_IgnoreCase_TextText(const class FText& A, const class FText& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_IgnoreCase_TextText");

	Params::KismetTextLibrary_NotEqual_IgnoreCase_TextText Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.NotEqual_TextText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::NotEqual_TextText(const class FText& A, const class FText& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_TextText");

	Params::KismetTextLibrary_NotEqual_TextText Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.PolyglotDataToText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPolyglotTextData                PolyglotData                                           (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::PolyglotDataToText(const struct FPolyglotTextData& PolyglotData)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PolyglotDataToText");

	Params::KismetTextLibrary_PolyglotDataToText Parms{};

	Parms.PolyglotData = std::move(PolyglotData);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.StringTableIdAndKeyFromText
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// class FName                             OutTableId                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutKey                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::StringTableIdAndKeyFromText(const class FText& Text, class FName* OutTableId, class FString* OutKey)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StringTableIdAndKeyFromText");

	Params::KismetTextLibrary_StringTableIdAndKeyFromText Parms{};

	Parms.Text = std::move(Text);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutTableId != nullptr)
		*OutTableId = Parms.OutTableId;

	if (OutKey != nullptr)
		*OutKey = std::move(Parms.OutKey);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextFromStringTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextFromStringTable(const class FName TableId, const class FString& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextFromStringTable");

	Params::KismetTextLibrary_TextFromStringTable Parms{};

	Parms.TableId = TableId;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextIsCultureInvariant
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::TextIsCultureInvariant(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextIsCultureInvariant");

	Params::KismetTextLibrary_TextIsCultureInvariant Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextIsEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::TextIsEmpty(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextIsEmpty");

	Params::KismetTextLibrary_TextIsEmpty Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextIsFromStringTable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::TextIsFromStringTable(const class FText& Text)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextIsFromStringTable");

	Params::KismetTextLibrary_TextIsFromStringTable Parms{};

	Parms.Text = std::move(Text);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextIsTransient
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetTextLibrary::TextIsTransient(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextIsTransient");

	Params::KismetTextLibrary_TextIsTransient Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextToLower
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextToLower(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextToLower");

	Params::KismetTextLibrary_TextToLower Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextToUpper
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextToUpper(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextToUpper");

	Params::KismetTextLibrary_TextToUpper Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextTrimPreceding
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextTrimPreceding(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextTrimPreceding");

	Params::KismetTextLibrary_TextTrimPreceding Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextTrimPrecedingAndTrailing(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextTrimPrecedingAndTrailing");

	Params::KismetTextLibrary_TextTrimPrecedingAndTrailing Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextTrimTrailing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetTextLibrary::TextTrimTrailing(const class FText& InText)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TextTrimTrailing");

	Params::KismetTextLibrary_TextTrimTrailing Parms{};

	Parms.InText = std::move(InText);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Abs
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Abs(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Abs");

	Params::KismetMathLibrary_Abs Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Abs_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Abs_Int(int32 A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Abs_Int");

	Params::KismetMathLibrary_Abs_Int Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Abs_Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Abs_Int64(int64 A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Abs_Int64");

	Params::KismetMathLibrary_Abs_Int64 Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Acos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Acos(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Acos");

	Params::KismetMathLibrary_Acos Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Add_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_ByteByte");

	Params::KismetMathLibrary_Add_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Add_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_DateTimeDateTime");

	Params::KismetMathLibrary_Add_DateTimeDateTime Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_DateTimeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Add_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_DateTimeTimespan");

	Params::KismetMathLibrary_Add_DateTimeTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetMathLibrary::Add_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_DoubleDouble");

	Params::KismetMathLibrary_Add_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Add_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_FloatFloat");

	Params::KismetMathLibrary_Add_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Add_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_Int64Int64");

	Params::KismetMathLibrary_Add_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Add_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_IntInt");

	Params::KismetMathLibrary_Add_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_IntPointInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Add_IntPointInt(const struct FIntPoint& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_IntPointInt");

	Params::KismetMathLibrary_Add_IntPointInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_IntPointIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Add_IntPointIntPoint(const struct FIntPoint& A, const struct FIntPoint& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_IntPointIntPoint");

	Params::KismetMathLibrary_Add_IntPointIntPoint Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Add_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_LinearColorLinearColor");

	Params::KismetMathLibrary_Add_LinearColorLinearColor Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_MatrixMatrix
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Add_MatrixMatrix(const struct FMatrix& A, const struct FMatrix& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_MatrixMatrix");

	Params::KismetMathLibrary_Add_MatrixMatrix Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Add_QuatQuat(const struct FQuat& A, const struct FQuat& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_QuatQuat");

	Params::KismetMathLibrary_Add_QuatQuat Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Add_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_TimespanTimespan");

	Params::KismetMathLibrary_Add_TimespanTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Add_Vector2DFloat(const struct FVector2D& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_Vector2DFloat");

	Params::KismetMathLibrary_Add_Vector2DFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Add_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_Vector2DVector2D");

	Params::KismetMathLibrary_Add_Vector2DVector2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Add_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_Vector4Vector4");

	Params::KismetMathLibrary_Add_Vector4Vector4 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Add_VectorFloat(const struct FVector& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_VectorFloat");

	Params::KismetMathLibrary_Add_VectorFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Add_VectorInt(const struct FVector& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_VectorInt");

	Params::KismetMathLibrary_Add_VectorInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Add_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Add_VectorVector");

	Params::KismetMathLibrary_Add_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.And_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::And_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("And_Int64Int64");

	Params::KismetMathLibrary_And_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.And_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::And_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("And_IntInt");

	Params::KismetMathLibrary_And_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Asin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Asin(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Asin");

	Params::KismetMathLibrary_Asin Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Atan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Atan(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Atan");

	Params::KismetMathLibrary_Atan Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Atan2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Atan2(float Y, float X)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Atan2");

	Params::KismetMathLibrary_Atan2 Parms{};

	Parms.Y = Y;
	Parms.X = X;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.BMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::BMax(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BMax");

	Params::KismetMathLibrary_BMax Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.BMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::BMin(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BMin");

	Params::KismetMathLibrary_BMin Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanAND
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanAND(bool A, bool B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BooleanAND");

	Params::KismetMathLibrary_BooleanAND Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanNAND
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanNAND(bool A, bool B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BooleanNAND");

	Params::KismetMathLibrary_BooleanNAND Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanNOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanNOR(bool A, bool B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BooleanNOR");

	Params::KismetMathLibrary_BooleanNOR Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanOR(bool A, bool B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BooleanOR");

	Params::KismetMathLibrary_BooleanOR Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanXOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::BooleanXOR(bool A, bool B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BooleanXOR");

	Params::KismetMathLibrary_BooleanXOR Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.BreakColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   R                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakColor(const struct FLinearColor& InColor, float* R, float* G, float* B, float* A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakColor");

	Params::KismetMathLibrary_BreakColor Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (R != nullptr)
		*R = Parms.R;

	if (G != nullptr)
		*G = Parms.G;

	if (B != nullptr)
		*B = Parms.B;

	if (A != nullptr)
		*A = Parms.A;
}


// Function Engine.KismetMathLibrary.BreakDateTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        InDateTime                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Year                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Month                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Day                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hour                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minute                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Second                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Millisecond                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakDateTime(const struct FDateTime& InDateTime, int32* Year, int32* Month, int32* Day, int32* Hour, int32* Minute, int32* Second, int32* Millisecond)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakDateTime");

	Params::KismetMathLibrary_BreakDateTime Parms{};

	Parms.InDateTime = std::move(InDateTime);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Year != nullptr)
		*Year = Parms.Year;

	if (Month != nullptr)
		*Month = Parms.Month;

	if (Day != nullptr)
		*Day = Parms.Day;

	if (Hour != nullptr)
		*Hour = Parms.Hour;

	if (Minute != nullptr)
		*Minute = Parms.Minute;

	if (Second != nullptr)
		*Second = Parms.Second;

	if (Millisecond != nullptr)
		*Millisecond = Parms.Millisecond;
}


// Function Engine.KismetMathLibrary.BreakFrameRate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFrameRate                       InFrameRate                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Numerator                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Denominator                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakFrameRate(const struct FFrameRate& InFrameRate, int32* Numerator, int32* Denominator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakFrameRate");

	Params::KismetMathLibrary_BreakFrameRate Parms{};

	Parms.InFrameRate = std::move(InFrameRate);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Numerator != nullptr)
		*Numerator = Parms.Numerator;

	if (Denominator != nullptr)
		*Denominator = Parms.Denominator;
}


// Function Engine.KismetMathLibrary.BreakQualifiedFrameTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQualifiedFrameTime              InFrameTime                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameNumber                     Frame                                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameRate                       FrameRate                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SubFrame                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakQualifiedFrameTime(const struct FQualifiedFrameTime& InFrameTime, struct FFrameNumber* Frame, struct FFrameRate* FrameRate, float* SubFrame)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakQualifiedFrameTime");

	Params::KismetMathLibrary_BreakQualifiedFrameTime Parms{};

	Parms.InFrameTime = std::move(InFrameTime);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Frame != nullptr)
		*Frame = std::move(Parms.Frame);

	if (FrameRate != nullptr)
		*FrameRate = std::move(Parms.FrameRate);

	if (SubFrame != nullptr)
		*SubFrame = Parms.SubFrame;
}


// Function Engine.KismetMathLibrary.BreakRandomStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream                    InRandomStream                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   InitialSeed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakRandomStream(const struct FRandomStream& InRandomStream, int32* InitialSeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakRandomStream");

	Params::KismetMathLibrary_BreakRandomStream Parms{};

	Parms.InRandomStream = std::move(InRandomStream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (InitialSeed != nullptr)
		*InitialSeed = Parms.InitialSeed;
}


// Function Engine.KismetMathLibrary.BreakRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakRotator(const struct FRotator& InRot, float* Roll, float* Pitch, float* Yaw)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakRotator");

	Params::KismetMathLibrary_BreakRotator Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Roll != nullptr)
		*Roll = Parms.Roll;

	if (Pitch != nullptr)
		*Pitch = Parms.Pitch;

	if (Yaw != nullptr)
		*Yaw = Parms.Yaw;
}


// Function Engine.KismetMathLibrary.BreakRotIntoAxes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakRotIntoAxes(const struct FRotator& InRot, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakRotIntoAxes");

	Params::KismetMathLibrary_BreakRotIntoAxes Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = std::move(Parms.X);

	if (Y != nullptr)
		*Y = std::move(Parms.Y);

	if (Z != nullptr)
		*Z = std::move(Parms.Z);
}


// Function Engine.KismetMathLibrary.BreakTimespan
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        InTimespan                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   days                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hours                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minutes                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seconds                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Milliseconds                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakTimespan(const struct FTimespan& InTimespan, int32* days, int32* Hours, int32* Minutes, int32* Seconds, int32* Milliseconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakTimespan");

	Params::KismetMathLibrary_BreakTimespan Parms{};

	Parms.InTimespan = std::move(InTimespan);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (days != nullptr)
		*days = Parms.days;

	if (Hours != nullptr)
		*Hours = Parms.Hours;

	if (Minutes != nullptr)
		*Minutes = Parms.Minutes;

	if (Seconds != nullptr)
		*Seconds = Parms.Seconds;

	if (Milliseconds != nullptr)
		*Milliseconds = Parms.Milliseconds;
}


// Function Engine.KismetMathLibrary.BreakTimespan2
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        InTimespan                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   days                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hours                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minutes                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seconds                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FractionNano                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakTimespan2(const struct FTimespan& InTimespan, int32* days, int32* Hours, int32* Minutes, int32* Seconds, int32* FractionNano)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakTimespan2");

	Params::KismetMathLibrary_BreakTimespan2 Parms{};

	Parms.InTimespan = std::move(InTimespan);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (days != nullptr)
		*days = Parms.days;

	if (Hours != nullptr)
		*Hours = Parms.Hours;

	if (Minutes != nullptr)
		*Minutes = Parms.Minutes;

	if (Seconds != nullptr)
		*Seconds = Parms.Seconds;

	if (FractionNano != nullptr)
		*FractionNano = Parms.FractionNano;
}


// Function Engine.KismetMathLibrary.BreakTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       InTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakTransform(const struct FTransform& InTransform, struct FVector* Location, struct FRotator* Rotation, struct FVector* Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakTransform");

	Params::KismetMathLibrary_BreakTransform Parms{};

	Parms.InTransform = std::move(InTransform);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);

	if (Scale != nullptr)
		*Scale = std::move(Parms.Scale);
}


// Function Engine.KismetMathLibrary.BreakVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector(const struct FVector& InVec, float* X, float* Y, float* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakVector");

	Params::KismetMathLibrary_BreakVector Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Z != nullptr)
		*Z = Parms.Z;
}


// Function Engine.KismetMathLibrary.BreakVector2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector2D(const struct FVector2D& InVec, float* X, float* Y)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakVector2D");

	Params::KismetMathLibrary_BreakVector2D Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;
}


// Function Engine.KismetMathLibrary.BreakVector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         InVec                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   W                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector4(const struct FVector4& InVec, float* X, float* Y, float* Z, float* W)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakVector4");

	Params::KismetMathLibrary_BreakVector4 Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Z != nullptr)
		*Z = Parms.Z;

	if (W != nullptr)
		*W = Parms.W;
}


// Function Engine.KismetMathLibrary.BreakVector_NetQuantize
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector_NetQuantize              InVec                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector_NetQuantize(const struct FVector_NetQuantize& InVec, float* X, float* Y, float* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakVector_NetQuantize");

	Params::KismetMathLibrary_BreakVector_NetQuantize Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Z != nullptr)
		*Z = Parms.Z;
}


// Function Engine.KismetMathLibrary.BreakVector_NetQuantize10
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector_NetQuantize10            InVec                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector_NetQuantize10(const struct FVector_NetQuantize10& InVec, float* X, float* Y, float* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakVector_NetQuantize10");

	Params::KismetMathLibrary_BreakVector_NetQuantize10 Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Z != nullptr)
		*Z = Parms.Z;
}


// Function Engine.KismetMathLibrary.BreakVector_NetQuantize100
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector_NetQuantize100           InVec                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector_NetQuantize100(const struct FVector_NetQuantize100& InVec, float* X, float* Y, float* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakVector_NetQuantize100");

	Params::KismetMathLibrary_BreakVector_NetQuantize100 Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Z != nullptr)
		*Z = Parms.Z;
}


// Function Engine.KismetMathLibrary.BreakVector_NetQuantizeNormal
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector_NetQuantizeNormal        InVec                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::BreakVector_NetQuantizeNormal(const struct FVector_NetQuantizeNormal& InVec, float* X, float* Y, float* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakVector_NetQuantizeNormal");

	Params::KismetMathLibrary_BreakVector_NetQuantizeNormal Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;

	if (Z != nullptr)
		*Z = Parms.Z;
}


// Function Engine.KismetMathLibrary.CInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::CInterpTo(const struct FLinearColor& Current, const struct FLinearColor& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CInterpTo");

	Params::KismetMathLibrary_CInterpTo Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Clamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Clamp(int32 Value, int32 Min_0, int32 Max_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Clamp");

	Params::KismetMathLibrary_Clamp Parms{};

	Parms.Value = Value;
	Parms.Min_0 = Min_0;
	Parms.Max_0 = Max_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampAngle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   AngleDegrees                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinAngleDegrees                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAngleDegrees                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClampAngle");

	Params::KismetMathLibrary_ClampAngle Parms{};

	Parms.AngleDegrees = AngleDegrees;
	Parms.MinAngleDegrees = MinAngleDegrees;
	Parms.MaxAngleDegrees = MaxAngleDegrees;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampAxes2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinAxisVal                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxAxisVal                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::ClampAxes2D(const struct FVector2D& A, float MinAxisVal, float MaxAxisVal)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClampAxes2D");

	Params::KismetMathLibrary_ClampAxes2D Parms{};

	Parms.A = std::move(A);
	Parms.MinAxisVal = MinAxisVal;
	Parms.MaxAxisVal = MaxAxisVal;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampAxis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::ClampAxis(float Angle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClampAxis");

	Params::KismetMathLibrary_ClampAxis Parms{};

	Parms.Angle = Angle;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::ClampInt64(int64 Value, int64 Min_0, int64 Max_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClampInt64");

	Params::KismetMathLibrary_ClampInt64 Parms{};

	Parms.Value = Value;
	Parms.Min_0 = Min_0;
	Parms.Max_0 = Max_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampVectorSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::ClampVectorSize(const struct FVector& A, float Min_0, float Max_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClampVectorSize");

	Params::KismetMathLibrary_ClampVectorSize Parms{};

	Parms.A = std::move(A);
	Parms.Min_0 = Min_0;
	Parms.Max_0 = Max_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClassIsChildOf
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>              TestClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              ParentClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::ClassIsChildOf(TSubclassOf<class UObject> TestClass, TSubclassOf<class UObject> ParentClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClassIsChildOf");

	Params::KismetMathLibrary_ClassIsChildOf Parms{};

	Parms.TestClass = TestClass;
	Parms.ParentClass = ParentClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ComposeRotators
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::ComposeRotators(const struct FRotator& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComposeRotators");

	Params::KismetMathLibrary_ComposeRotators Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ComposeTransforms
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::ComposeTransforms(const struct FTransform& A, const struct FTransform& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComposeTransforms");

	Params::KismetMathLibrary_ComposeTransforms Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_BoolToByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InBool                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Conv_BoolToByte(bool InBool)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_BoolToByte");

	Params::KismetMathLibrary_Conv_BoolToByte Parms{};

	Parms.InBool = InBool;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_BoolToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InBool                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Conv_BoolToFloat(bool InBool)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_BoolToFloat");

	Params::KismetMathLibrary_Conv_BoolToFloat Parms{};

	Parms.InBool = InBool;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_BoolToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InBool                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Conv_BoolToInt(bool InBool)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_BoolToInt");

	Params::KismetMathLibrary_Conv_BoolToInt Parms{};

	Parms.InBool = InBool;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_ByteToDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   InByte                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetMathLibrary::Conv_ByteToDouble(uint8 InByte)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ByteToDouble");

	Params::KismetMathLibrary_Conv_ByteToDouble Parms{};

	Parms.InByte = InByte;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_ByteToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   InByte                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Conv_ByteToFloat(uint8 InByte)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ByteToFloat");

	Params::KismetMathLibrary_Conv_ByteToFloat Parms{};

	Parms.InByte = InByte;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_ByteToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   InByte                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Conv_ByteToInt(uint8 InByte)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ByteToInt");

	Params::KismetMathLibrary_Conv_ByteToInt Parms{};

	Parms.InByte = InByte;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_ByteToInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   InByte                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Conv_ByteToInt64(uint8 InByte)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ByteToInt64");

	Params::KismetMathLibrary_Conv_ByteToInt64 Parms{};

	Parms.InByte = InByte;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_ColorToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FColor                           InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Conv_ColorToLinearColor(const struct FColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ColorToLinearColor");

	Params::KismetMathLibrary_Conv_ColorToLinearColor Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_DoubleToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  InDouble                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Conv_DoubleToFloat(double InDouble)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_DoubleToFloat");

	Params::KismetMathLibrary_Conv_DoubleToFloat Parms{};

	Parms.InDouble = InDouble;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_DoubleToInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  InDouble                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Conv_DoubleToInt64(double InDouble)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_DoubleToInt64");

	Params::KismetMathLibrary_Conv_DoubleToInt64 Parms{};

	Parms.InDouble = InDouble;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_FloatToDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetMathLibrary::Conv_FloatToDouble(float InFloat)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_FloatToDouble");

	Params::KismetMathLibrary_Conv_FloatToDouble Parms{};

	Parms.InFloat = InFloat;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_FloatToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Conv_FloatToLinearColor(float InFloat)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_FloatToLinearColor");

	Params::KismetMathLibrary_Conv_FloatToLinearColor Parms{};

	Parms.InFloat = InFloat;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_FloatToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_FloatToVector(float InFloat)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_FloatToVector");

	Params::KismetMathLibrary_Conv_FloatToVector Parms{};

	Parms.InFloat = InFloat;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Int64ToByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Conv_Int64ToByte(int64 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Int64ToByte");

	Params::KismetMathLibrary_Conv_Int64ToByte Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Int64ToDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetMathLibrary::Conv_Int64ToDouble(int64 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Int64ToDouble");

	Params::KismetMathLibrary_Conv_Int64ToDouble Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Int64ToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Conv_Int64ToInt(int64 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Int64ToInt");

	Params::KismetMathLibrary_Conv_Int64ToInt Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntPointToVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        InIntPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Conv_IntPointToVector2D(const struct FIntPoint& InIntPoint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntPointToVector2D");

	Params::KismetMathLibrary_Conv_IntPointToVector2D Parms{};

	Parms.InIntPoint = std::move(InIntPoint);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Conv_IntToBool(int32 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToBool");

	Params::KismetMathLibrary_Conv_IntToBool Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Conv_IntToByte(int32 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToByte");

	Params::KismetMathLibrary_Conv_IntToByte Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetMathLibrary::Conv_IntToDouble(int32 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToDouble");

	Params::KismetMathLibrary_Conv_IntToDouble Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Conv_IntToFloat(int32 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToFloat");

	Params::KismetMathLibrary_Conv_IntToFloat Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Conv_IntToInt64(int32 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToInt64");

	Params::KismetMathLibrary_Conv_IntToInt64 Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToIntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UKismetMathLibrary::Conv_IntToIntVector(int32 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToIntVector");

	Params::KismetMathLibrary_Conv_IntToIntVector Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_IntToVector(int32 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToVector");

	Params::KismetMathLibrary_Conv_IntToVector Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntVectorToVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       InIntVector                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_IntVectorToVector(const struct FIntVector& InIntVector)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntVectorToVector");

	Params::KismetMathLibrary_Conv_IntVectorToVector Parms{};

	Parms.InIntVector = std::move(InIntVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_LinearColorToColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InLinearColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InUseSRGB                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetMathLibrary::Conv_LinearColorToColor(const struct FLinearColor& InLinearColor, bool InUseSRGB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_LinearColorToColor");

	Params::KismetMathLibrary_Conv_LinearColorToColor Parms{};

	Parms.InLinearColor = std::move(InLinearColor);
	Parms.InUseSRGB = InUseSRGB;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_LinearColorToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InLinearColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_LinearColorToVector(const struct FLinearColor& InLinearColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_LinearColorToVector");

	Params::KismetMathLibrary_Conv_LinearColorToVector Parms{};

	Parms.InLinearColor = std::move(InLinearColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_MatrixToRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          InMatrix                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Conv_MatrixToRotator(const struct FMatrix& InMatrix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_MatrixToRotator");

	Params::KismetMathLibrary_Conv_MatrixToRotator Parms{};

	Parms.InMatrix = std::move(InMatrix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_MatrixToTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          InMatrix                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::Conv_MatrixToTransform(const struct FMatrix& InMatrix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_MatrixToTransform");

	Params::KismetMathLibrary_Conv_MatrixToTransform Parms{};

	Parms.InMatrix = std::move(InMatrix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_RotatorToQuaternion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Conv_RotatorToQuaternion(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_RotatorToQuaternion");

	Params::KismetMathLibrary_Conv_RotatorToQuaternion Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_RotatorToTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRotator                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::Conv_RotatorToTransform(const struct FRotator& InRotator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_RotatorToTransform");

	Params::KismetMathLibrary_Conv_RotatorToTransform Parms{};

	Parms.InRotator = std::move(InRotator);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_RotatorToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_RotatorToVector(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_RotatorToVector");

	Params::KismetMathLibrary_Conv_RotatorToVector Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_TransformToMatrix
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Conv_TransformToMatrix(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_TransformToMatrix");

	Params::KismetMathLibrary_Conv_TransformToMatrix Parms{};

	Parms.Transform = std::move(Transform);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector2DToIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        InVector2D                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Conv_Vector2DToIntPoint(const struct FVector2D& InVector2D)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Vector2DToIntPoint");

	Params::KismetMathLibrary_Conv_Vector2DToIntPoint Parms{};

	Parms.InVector2D = std::move(InVector2D);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector2DToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        InVector2D                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_Vector2DToVector(const struct FVector2D& InVector2D, float Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Vector2DToVector");

	Params::KismetMathLibrary_Conv_Vector2DToVector Parms{};

	Parms.InVector2D = std::move(InVector2D);
	Parms.Z = Z;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector4ToQuaternion
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         InVec                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Conv_Vector4ToQuaternion(const struct FVector4& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Vector4ToQuaternion");

	Params::KismetMathLibrary_Conv_Vector4ToQuaternion Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector4ToRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         InVec                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Conv_Vector4ToRotator(const struct FVector4& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Vector4ToRotator");

	Params::KismetMathLibrary_Conv_Vector4ToRotator Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector4ToVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         InVector4                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Conv_Vector4ToVector(const struct FVector4& InVector4)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Vector4ToVector");

	Params::KismetMathLibrary_Conv_Vector4ToVector Parms{};

	Parms.InVector4 = std::move(InVector4);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Conv_VectorToLinearColor(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_VectorToLinearColor");

	Params::KismetMathLibrary_Conv_VectorToLinearColor Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToQuaternion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Conv_VectorToQuaternion(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_VectorToQuaternion");

	Params::KismetMathLibrary_Conv_VectorToQuaternion Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Conv_VectorToRotator(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_VectorToRotator");

	Params::KismetMathLibrary_Conv_VectorToRotator Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::Conv_VectorToTransform(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_VectorToTransform");

	Params::KismetMathLibrary_Conv_VectorToTransform Parms{};

	Parms.InLocation = std::move(InLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Conv_VectorToVector2D(const struct FVector& InVector)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_VectorToVector2D");

	Params::KismetMathLibrary_Conv_VectorToVector2D Parms{};

	Parms.InVector = std::move(InVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ConvertTransformToRelative
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ParentTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::ConvertTransformToRelative(const struct FTransform& Transform, const struct FTransform& ParentTransform)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertTransformToRelative");

	Params::KismetMathLibrary_ConvertTransformToRelative Parms{};

	Parms.Transform = std::move(Transform);
	Parms.ParentTransform = std::move(ParentTransform);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Cos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Cos(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Cos");

	Params::KismetMathLibrary_Cos Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.CreateVectorFromYawPitch
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::CreateVectorFromYawPitch(float Yaw, float Pitch, float Length)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateVectorFromYawPitch");

	Params::KismetMathLibrary_CreateVectorFromYawPitch Parms{};

	Parms.Yaw = Yaw;
	Parms.Pitch = Pitch;
	Parms.Length = Length;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Cross_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Cross_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Cross_VectorVector");

	Params::KismetMathLibrary_Cross_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.CrossProduct2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::CrossProduct2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CrossProduct2D");

	Params::KismetMathLibrary_CrossProduct2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DateTimeFromIsoString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           IsoString                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::DateTimeFromIsoString(const class FString& IsoString, struct FDateTime* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DateTimeFromIsoString");

	Params::KismetMathLibrary_DateTimeFromIsoString Parms{};

	Parms.IsoString = std::move(IsoString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DateTimeFromString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           DateTimeString                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::DateTimeFromString(const class FString& DateTimeString, struct FDateTime* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DateTimeFromString");

	Params::KismetMathLibrary_DateTimeFromString Parms{};

	Parms.DateTimeString = std::move(DateTimeString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DateTimeMaxValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::DateTimeMaxValue()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DateTimeMaxValue");

	Params::KismetMathLibrary_DateTimeMaxValue Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DateTimeMinValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::DateTimeMinValue()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DateTimeMinValue");

	Params::KismetMathLibrary_DateTimeMinValue Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DaysInMonth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Year                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Month                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::DaysInMonth(int32 Year, int32 Month)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DaysInMonth");

	Params::KismetMathLibrary_DaysInMonth Parms{};

	Parms.Year = Year;
	Parms.Month = Month;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DaysInYear
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Year                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::DaysInYear(int32 Year)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DaysInYear");

	Params::KismetMathLibrary_DaysInYear Parms{};

	Parms.Year = Year;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegAcos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegAcos(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DegAcos");

	Params::KismetMathLibrary_DegAcos Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegAsin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegAsin(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DegAsin");

	Params::KismetMathLibrary_DegAsin Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegAtan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegAtan(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DegAtan");

	Params::KismetMathLibrary_DegAtan Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegAtan2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegAtan2(float Y, float X)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DegAtan2");

	Params::KismetMathLibrary_DegAtan2 Parms{};

	Parms.Y = Y;
	Parms.X = X;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegCos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegCos(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DegCos");

	Params::KismetMathLibrary_DegCos Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegreesToRadians
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegreesToRadians(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DegreesToRadians");

	Params::KismetMathLibrary_DegreesToRadians Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegSin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegSin(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DegSin");

	Params::KismetMathLibrary_DegSin Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegTan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DegTan(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DegTan");

	Params::KismetMathLibrary_DegTan Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Distance2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        v1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        v2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Distance2D(const struct FVector2D& v1, const struct FVector2D& v2)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Distance2D");

	Params::KismetMathLibrary_Distance2D Parms{};

	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DistanceSquared2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        v1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        v2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DistanceSquared2D(const struct FVector2D& v1, const struct FVector2D& v2)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DistanceSquared2D");

	Params::KismetMathLibrary_DistanceSquared2D Parms{};

	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Divide_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_ByteByte");

	Params::KismetMathLibrary_Divide_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetMathLibrary::Divide_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_DoubleDouble");

	Params::KismetMathLibrary_Divide_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Divide_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_FloatFloat");

	Params::KismetMathLibrary_Divide_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Divide_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_Int64Int64");

	Params::KismetMathLibrary_Divide_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Divide_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_IntInt");

	Params::KismetMathLibrary_Divide_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_IntPointInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Divide_IntPointInt(const struct FIntPoint& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_IntPointInt");

	Params::KismetMathLibrary_Divide_IntPointInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_IntPointIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Divide_IntPointIntPoint(const struct FIntPoint& A, const struct FIntPoint& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_IntPointIntPoint");

	Params::KismetMathLibrary_Divide_IntPointIntPoint Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Divide_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_LinearColorLinearColor");

	Params::KismetMathLibrary_Divide_LinearColorLinearColor Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_TimespanFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scalar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Divide_TimespanFloat(const struct FTimespan& A, float Scalar)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_TimespanFloat");

	Params::KismetMathLibrary_Divide_TimespanFloat Parms{};

	Parms.A = std::move(A);
	Parms.Scalar = Scalar;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Divide_Vector2DFloat(const struct FVector2D& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_Vector2DFloat");

	Params::KismetMathLibrary_Divide_Vector2DFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Divide_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_Vector2DVector2D");

	Params::KismetMathLibrary_Divide_Vector2DVector2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Divide_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_Vector4Vector4");

	Params::KismetMathLibrary_Divide_Vector4Vector4 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Divide_VectorFloat(const struct FVector& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_VectorFloat");

	Params::KismetMathLibrary_Divide_VectorFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Divide_VectorInt(const struct FVector& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_VectorInt");

	Params::KismetMathLibrary_Divide_VectorInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Divide_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Divide_VectorVector");

	Params::KismetMathLibrary_Divide_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Dot_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Dot_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Dot_VectorVector");

	Params::KismetMathLibrary_Dot_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DotProduct2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DotProduct2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DotProduct2D");

	Params::KismetMathLibrary_DotProduct2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   CurrentSample                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreviousSample                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinWeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::DynamicWeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float MaxDistance, float MinWeight, float MaxWeight)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DynamicWeightedMovingAverage_Float");

	Params::KismetMathLibrary_DynamicWeightedMovingAverage_Float Parms{};

	Parms.CurrentSample = CurrentSample;
	Parms.PreviousSample = PreviousSample;
	Parms.MaxDistance = MaxDistance;
	Parms.MinWeight = MinWeight;
	Parms.MaxWeight = MaxWeight;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         CurrentSample                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         PreviousSample                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinWeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::DynamicWeightedMovingAverage_FRotator(const struct FRotator& CurrentSample, const struct FRotator& PreviousSample, float MaxDistance, float MinWeight, float MaxWeight)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DynamicWeightedMovingAverage_FRotator");

	Params::KismetMathLibrary_DynamicWeightedMovingAverage_FRotator Parms{};

	Parms.CurrentSample = std::move(CurrentSample);
	Parms.PreviousSample = std::move(PreviousSample);
	Parms.MaxDistance = MaxDistance;
	Parms.MinWeight = MinWeight;
	Parms.MaxWeight = MaxWeight;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          CurrentSample                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PreviousSample                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinWeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::DynamicWeightedMovingAverage_FVector(const struct FVector& CurrentSample, const struct FVector& PreviousSample, float MaxDistance, float MinWeight, float MaxWeight)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DynamicWeightedMovingAverage_FVector");

	Params::KismetMathLibrary_DynamicWeightedMovingAverage_FVector Parms{};

	Parms.CurrentSample = std::move(CurrentSample);
	Parms.PreviousSample = std::move(PreviousSample);
	Parms.MaxDistance = MaxDistance;
	Parms.MinWeight = MinWeight;
	Parms.MaxWeight = MaxWeight;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Ease
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Steps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Ease(float A, float B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Ease");

	Params::KismetMathLibrary_Ease Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.EasingFunc = EasingFunc;
	Parms.BlendExp = BlendExp;
	Parms.Steps = Steps;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Equal_IntPointIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Equal_IntPointIntPoint(const struct FIntPoint& A, const struct FIntPoint& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Equal_IntPointIntPoint");

	Params::KismetMathLibrary_Equal_IntPointIntPoint Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_BoolBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_BoolBool(bool A, bool B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_BoolBool");

	Params::KismetMathLibrary_EqualEqual_BoolBool Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_ByteByte");

	Params::KismetMathLibrary_EqualEqual_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_ClassClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_ClassClass(class UClass* A, class UClass* B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_ClassClass");

	Params::KismetMathLibrary_EqualEqual_ClassClass Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_DateTimeDateTime");

	Params::KismetMathLibrary_EqualEqual_DateTimeDateTime Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_DoubleDouble");

	Params::KismetMathLibrary_EqualEqual_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_FloatFloat");

	Params::KismetMathLibrary_EqualEqual_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_Int64Int64");

	Params::KismetMathLibrary_EqualEqual_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_IntInt");

	Params::KismetMathLibrary_EqualEqual_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_LinearColorLinearColor");

	Params::KismetMathLibrary_EqualEqual_LinearColorLinearColor Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_MatrixMatrix
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_MatrixMatrix(const struct FMatrix& A, const struct FMatrix& B, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_MatrixMatrix");

	Params::KismetMathLibrary_EqualEqual_MatrixMatrix Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_NameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_NameName(class FName A, class FName B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_NameName");

	Params::KismetMathLibrary_EqualEqual_NameName Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_ObjectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_ObjectObject(class UObject* A, class UObject* B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_ObjectObject");

	Params::KismetMathLibrary_EqualEqual_ObjectObject Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_QuatQuat(const struct FQuat& A, const struct FQuat& B, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_QuatQuat");

	Params::KismetMathLibrary_EqualEqual_QuatQuat Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_RotatorRotator");

	Params::KismetMathLibrary_EqualEqual_RotatorRotator Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_TimespanTimespan");

	Params::KismetMathLibrary_EqualEqual_TimespanTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_TransformTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_TransformTransform");

	Params::KismetMathLibrary_EqualEqual_TransformTransform Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_Vector2DVector2D");

	Params::KismetMathLibrary_EqualEqual_Vector2DVector2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_Vector4Vector4(const struct FVector4& A, const struct FVector4& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_Vector4Vector4");

	Params::KismetMathLibrary_EqualEqual_Vector4Vector4 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_VectorVector");

	Params::KismetMathLibrary_EqualEqual_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualExactly_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualExactly_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualExactly_Vector2DVector2D");

	Params::KismetMathLibrary_EqualExactly_Vector2DVector2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualExactly_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualExactly_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualExactly_Vector4Vector4");

	Params::KismetMathLibrary_EqualExactly_Vector4Vector4 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualExactly_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::EqualExactly_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualExactly_VectorVector");

	Params::KismetMathLibrary_EqualExactly_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Exp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Exp(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Exp");

	Params::KismetMathLibrary_Exp Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FCeil
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::FCeil(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FCeil");

	Params::KismetMathLibrary_FCeil Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FCeil64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::FCeil64(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FCeil64");

	Params::KismetMathLibrary_FCeil64 Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FClamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FClamp(float Value, float Min_0, float Max_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FClamp");

	Params::KismetMathLibrary_FClamp Parms{};

	Parms.Value = Value;
	Parms.Min_0 = Min_0;
	Parms.Max_0 = Max_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FFloor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::FFloor(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FFloor");

	Params::KismetMathLibrary_FFloor Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FFloor64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::FFloor64(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FFloor64");

	Params::KismetMathLibrary_FFloor64 Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FindClosestPointOnLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineOrigin                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::FindClosestPointOnLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindClosestPointOnLine");

	Params::KismetMathLibrary_FindClosestPointOnLine Parms{};

	Parms.Point = std::move(Point);
	Parms.LineOrigin = std::move(LineOrigin);
	Parms.LineDirection = std::move(LineDirection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FindClosestPointOnSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentStart                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::FindClosestPointOnSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindClosestPointOnSegment");

	Params::KismetMathLibrary_FindClosestPointOnSegment Parms{};

	Parms.Point = std::move(Point);
	Parms.SegmentStart = std::move(SegmentStart);
	Parms.SegmentEnd = std::move(SegmentEnd);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FindLookAtRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::FindLookAtRotation(const struct FVector& Start, const struct FVector& Target)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindLookAtRotation");

	Params::KismetMathLibrary_FindLookAtRotation Parms{};

	Parms.Start = std::move(Start);
	Parms.Target = std::move(Target);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FindNearestPointsOnLineSegments
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Segment1Start                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Segment1End                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Segment2Start                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Segment2End                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Segment1Point                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Segment2Point                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::FindNearestPointsOnLineSegments(const struct FVector& Segment1Start, const struct FVector& Segment1End, const struct FVector& Segment2Start, const struct FVector& Segment2End, struct FVector* Segment1Point, struct FVector* Segment2Point)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindNearestPointsOnLineSegments");

	Params::KismetMathLibrary_FindNearestPointsOnLineSegments Parms{};

	Parms.Segment1Start = std::move(Segment1Start);
	Parms.Segment1End = std::move(Segment1End);
	Parms.Segment2Start = std::move(Segment2Start);
	Parms.Segment2End = std::move(Segment2End);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Segment1Point != nullptr)
		*Segment1Point = std::move(Parms.Segment1Point);

	if (Segment2Point != nullptr)
		*Segment2Point = std::move(Parms.Segment2Point);
}


// Function Engine.KismetMathLibrary.FInterpEaseInOut
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Exponent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FInterpEaseInOut(float A, float B, float Alpha, float Exponent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FInterpEaseInOut");

	Params::KismetMathLibrary_FInterpEaseInOut Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;
	Parms.Exponent = Exponent;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FInterpTo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FInterpTo");

	Params::KismetMathLibrary_FInterpTo Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FInterpTo_Constant
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FInterpTo_Constant(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FInterpTo_Constant");

	Params::KismetMathLibrary_FInterpTo_Constant Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FixedTurn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDesired                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDeltaRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FixedTurn(float InCurrent, float InDesired, float InDeltaRate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FixedTurn");

	Params::KismetMathLibrary_FixedTurn Parms{};

	Parms.InCurrent = InCurrent;
	Parms.InDesired = InDesired;
	Parms.InDeltaRate = InDeltaRate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FloatSpringInterp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloatSpringState                SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Stiffness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CriticalDampingFactor                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Mass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetVelocityAmount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClamp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInitializeFromTarget                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FloatSpringInterp(float Current, float Target, struct FFloatSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bClamp, float MinValue, float MaxValue, bool bInitializeFromTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FloatSpringInterp");

	Params::KismetMathLibrary_FloatSpringInterp Parms{};

	Parms.Current = Current;
	Parms.Target = Target;
	Parms.SpringState = std::move(SpringState);
	Parms.Stiffness = Stiffness;
	Parms.CriticalDampingFactor = CriticalDampingFactor;
	Parms.DeltaTime = DeltaTime;
	Parms.Mass = Mass;
	Parms.TargetVelocityAmount = TargetVelocityAmount;
	Parms.bClamp = bClamp;
	Parms.MinValue = MinValue;
	Parms.MaxValue = MaxValue;
	Parms.bInitializeFromTarget = bInitializeFromTarget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FMax(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FMax");

	Params::KismetMathLibrary_FMax Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FMin(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FMin");

	Params::KismetMathLibrary_FMin Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FMod
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Dividend                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Divisor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Remainder                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::FMod(float Dividend, float Divisor, float* Remainder)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FMod");

	Params::KismetMathLibrary_FMod Parms{};

	Parms.Dividend = Dividend;
	Parms.Divisor = Divisor;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Remainder != nullptr)
		*Remainder = Parms.Remainder;

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Fraction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Fraction(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Fraction");

	Params::KismetMathLibrary_Fraction Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromDays(float days)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FromDays");

	Params::KismetMathLibrary_FromDays Parms{};

	Parms.days = days;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromHours(float Hours)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FromHours");

	Params::KismetMathLibrary_FromHours Parms{};

	Parms.Hours = Hours;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Milliseconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromMilliseconds(float Milliseconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FromMilliseconds");

	Params::KismetMathLibrary_FromMilliseconds Parms{};

	Parms.Milliseconds = Milliseconds;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromMinutes(float Minutes)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FromMinutes");

	Params::KismetMathLibrary_FromMinutes Parms{};

	Parms.Minutes = Minutes;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::FromSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FromSeconds");

	Params::KismetMathLibrary_FromSeconds Parms{};

	Parms.Seconds = Seconds;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FTrunc
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::FTrunc(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FTrunc");

	Params::KismetMathLibrary_FTrunc Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FTrunc64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::FTrunc64(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FTrunc64");

	Params::KismetMathLibrary_FTrunc64 Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FTruncVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVector                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UKismetMathLibrary::FTruncVector(const struct FVector& InVector)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FTruncVector");

	Params::KismetMathLibrary_FTruncVector Parms{};

	Parms.InVector = std::move(InVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.FWrap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::FWrap(float Value, float Min_0, float Max_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FWrap");

	Params::KismetMathLibrary_FWrap Parms{};

	Parms.Value = Value;
	Parms.Min_0 = Min_0;
	Parms.Max_0 = Max_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetAbs2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::GetAbs2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAbs2D");

	Params::KismetMathLibrary_GetAbs2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetAbsMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetAbsMax2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAbsMax2D");

	Params::KismetMathLibrary_GetAbsMax2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetAxes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::GetAxes(const struct FRotator& A, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAxes");

	Params::KismetMathLibrary_GetAxes Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = std::move(Parms.X);

	if (Y != nullptr)
		*Y = std::move(Parms.Y);

	if (Z != nullptr)
		*Z = std::move(Parms.Z);
}


// Function Engine.KismetMathLibrary.GetAzimuthAndElevation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReferenceFrame                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Azimuth                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Elevation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::GetAzimuthAndElevation(const struct FVector& InDirection, const struct FTransform& ReferenceFrame, float* Azimuth, float* Elevation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAzimuthAndElevation");

	Params::KismetMathLibrary_GetAzimuthAndElevation Parms{};

	Parms.InDirection = std::move(InDirection);
	Parms.ReferenceFrame = std::move(ReferenceFrame);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Azimuth != nullptr)
		*Azimuth = Parms.Azimuth;

	if (Elevation != nullptr)
		*Elevation = Parms.Elevation;
}


// Function Engine.KismetMathLibrary.GetDate
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::GetDate(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDate");

	Params::KismetMathLibrary_GetDate Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDay
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetDay(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDay");

	Params::KismetMathLibrary_GetDay Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDayOfYear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetDayOfYear(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDayOfYear");

	Params::KismetMathLibrary_GetDayOfYear Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetDays(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDays");

	Params::KismetMathLibrary_GetDays Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDirectionUnitVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          To                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetDirectionUnitVector(const struct FVector& From, const struct FVector& To)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDirectionUnitVector");

	Params::KismetMathLibrary_GetDirectionUnitVector Parms{};

	Parms.From = std::move(From);
	Parms.To = std::move(To);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDuration
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::GetDuration(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDuration");

	Params::KismetMathLibrary_GetDuration Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetForwardVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetForwardVector(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetForwardVector");

	Params::KismetMathLibrary_GetForwardVector Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetHour
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetHour(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetHour");

	Params::KismetMathLibrary_GetHour Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetHour12
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetHour12(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetHour12");

	Params::KismetMathLibrary_GetHour12 Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetHours(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetHours");

	Params::KismetMathLibrary_GetHours Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetMax2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMax2D");

	Params::KismetMathLibrary_GetMax2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMaxElement
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetMaxElement(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMaxElement");

	Params::KismetMathLibrary_GetMaxElement Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMillisecond
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMillisecond(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMillisecond");

	Params::KismetMathLibrary_GetMillisecond Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMilliseconds(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMilliseconds");

	Params::KismetMathLibrary_GetMilliseconds Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMin2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetMin2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMin2D");

	Params::KismetMathLibrary_GetMin2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMinElement
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetMinElement(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMinElement");

	Params::KismetMathLibrary_GetMinElement Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMinute
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMinute(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMinute");

	Params::KismetMathLibrary_GetMinute Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMinutes(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMinutes");

	Params::KismetMathLibrary_GetMinutes Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMonth
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetMonth(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMonth");

	Params::KismetMathLibrary_GetMonth Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetPI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetPI()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPI");

	Params::KismetMathLibrary_GetPI Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetPointDistanceToLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineOrigin                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetPointDistanceToLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPointDistanceToLine");

	Params::KismetMathLibrary_GetPointDistanceToLine Parms{};

	Parms.Point = std::move(Point);
	Parms.LineOrigin = std::move(LineOrigin);
	Parms.LineDirection = std::move(LineDirection);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetPointDistanceToSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentStart                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetPointDistanceToSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPointDistanceToSegment");

	Params::KismetMathLibrary_GetPointDistanceToSegment Parms{};

	Parms.Point = std::move(Point);
	Parms.SegmentStart = std::move(SegmentStart);
	Parms.SegmentEnd = std::move(SegmentEnd);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetReflectionVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SurfaceNormal                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetReflectionVector(const struct FVector& Direction, const struct FVector& SurfaceNormal)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetReflectionVector");

	Params::KismetMathLibrary_GetReflectionVector Parms{};

	Parms.Direction = std::move(Direction);
	Parms.SurfaceNormal = std::move(SurfaceNormal);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetRightVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetRightVector(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRightVector");

	Params::KismetMathLibrary_GetRightVector Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetRotated2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleDeg                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::GetRotated2D(const struct FVector2D& A, float AngleDeg)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRotated2D");

	Params::KismetMathLibrary_GetRotated2D Parms{};

	Parms.A = std::move(A);
	Parms.AngleDeg = AngleDeg;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetSecond
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetSecond(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSecond");

	Params::KismetMathLibrary_GetSecond Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetSeconds(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSeconds");

	Params::KismetMathLibrary_GetSeconds Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetSlopeDegreeAngles
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          MyRightYAxis                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          FloorNormal                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          UpVector                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutSlopePitchDegreeAngle                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutSlopeRollDegreeAngle                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::GetSlopeDegreeAngles(const struct FVector& MyRightYAxis, const struct FVector& FloorNormal, const struct FVector& UpVector, float* OutSlopePitchDegreeAngle, float* OutSlopeRollDegreeAngle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSlopeDegreeAngles");

	Params::KismetMathLibrary_GetSlopeDegreeAngles Parms{};

	Parms.MyRightYAxis = std::move(MyRightYAxis);
	Parms.FloorNormal = std::move(FloorNormal);
	Parms.UpVector = std::move(UpVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutSlopePitchDegreeAngle != nullptr)
		*OutSlopePitchDegreeAngle = Parms.OutSlopePitchDegreeAngle;

	if (OutSlopeRollDegreeAngle != nullptr)
		*OutSlopeRollDegreeAngle = Parms.OutSlopeRollDegreeAngle;
}


// Function Engine.KismetMathLibrary.GetTAU
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTAU()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTAU");

	Params::KismetMathLibrary_GetTAU Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTimeOfDay
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::GetTimeOfDay(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTimeOfDay");

	Params::KismetMathLibrary_GetTimeOfDay Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalDays(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTotalDays");

	Params::KismetMathLibrary_GetTotalDays Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalHours(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTotalHours");

	Params::KismetMathLibrary_GetTotalHours Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalMilliseconds(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTotalMilliseconds");

	Params::KismetMathLibrary_GetTotalMilliseconds Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalMinutes(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTotalMinutes");

	Params::KismetMathLibrary_GetTotalMinutes Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GetTotalSeconds(const struct FTimespan& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTotalSeconds");

	Params::KismetMathLibrary_GetTotalSeconds Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetUpVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetUpVector(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetUpVector");

	Params::KismetMathLibrary_GetUpVector Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetVectorArrayAverage
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>                  Vectors                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GetVectorArrayAverage(const TArray<struct FVector>& Vectors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetVectorArrayAverage");

	Params::KismetMathLibrary_GetVectorArrayAverage Parms{};

	Parms.Vectors = std::move(Vectors);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetYawPitchFromVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::GetYawPitchFromVector(const struct FVector& InVec, float* Yaw, float* Pitch)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetYawPitchFromVector");

	Params::KismetMathLibrary_GetYawPitchFromVector Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Yaw != nullptr)
		*Yaw = Parms.Yaw;

	if (Pitch != nullptr)
		*Pitch = Parms.Pitch;
}


// Function Engine.KismetMathLibrary.GetYear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::GetYear(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetYear");

	Params::KismetMathLibrary_GetYear Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater_ByteByte");

	Params::KismetMathLibrary_Greater_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater_DateTimeDateTime");

	Params::KismetMathLibrary_Greater_DateTimeDateTime Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater_DoubleDouble");

	Params::KismetMathLibrary_Greater_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater_FloatFloat");

	Params::KismetMathLibrary_Greater_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater_Int64Int64");

	Params::KismetMathLibrary_Greater_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater_IntInt");

	Params::KismetMathLibrary_Greater_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Greater_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Greater_TimespanTimespan");

	Params::KismetMathLibrary_Greater_TimespanTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual_ByteByte");

	Params::KismetMathLibrary_GreaterEqual_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual_DateTimeDateTime");

	Params::KismetMathLibrary_GreaterEqual_DateTimeDateTime Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual_DoubleDouble");

	Params::KismetMathLibrary_GreaterEqual_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual_FloatFloat");

	Params::KismetMathLibrary_GreaterEqual_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual_Int64Int64");

	Params::KismetMathLibrary_GreaterEqual_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual_IntInt");

	Params::KismetMathLibrary_GreaterEqual_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::GreaterEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterEqual_TimespanTimespan");

	Params::KismetMathLibrary_GreaterEqual_TimespanTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::GreaterGreater_VectorRotator(const struct FVector& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GreaterGreater_VectorRotator");

	Params::KismetMathLibrary_GreaterGreater_VectorRotator Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.GridSnap_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GridSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::GridSnap_Float(float Location, float GridSize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GridSnap_Float");

	Params::KismetMathLibrary_GridSnap_Float Parms{};

	Parms.Location = Location;
	Parms.GridSize = GridSize;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.HSVToRGB
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   H                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   S                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::HSVToRGB(float H, float S, float V, float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HSVToRGB");

	Params::KismetMathLibrary_HSVToRGB Parms{};

	Parms.H = H;
	Parms.S = S;
	Parms.V = V;
	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.HSVToRGB_Vector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     HSV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     RGB                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::HSVToRGB_Vector(const struct FLinearColor& HSV, struct FLinearColor* RGB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HSVToRGB_Vector");

	Params::KismetMathLibrary_HSVToRGB_Vector Parms{};

	Parms.HSV = std::move(HSV);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (RGB != nullptr)
		*RGB = std::move(Parms.RGB);
}


// Function Engine.KismetMathLibrary.HSVToRGBLinear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     HSV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::HSVToRGBLinear(const struct FLinearColor& HSV)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HSVToRGBLinear");

	Params::KismetMathLibrary_HSVToRGBLinear Parms{};

	Parms.HSV = std::move(HSV);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Hypotenuse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Hypotenuse(float Width, float Height)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Hypotenuse");

	Params::KismetMathLibrary_Hypotenuse Parms{};

	Parms.Width = Width;
	Parms.Height = Height;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.InRange_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InclusiveMin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InclusiveMax                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::InRange_FloatFloat(float Value, float Min_0, float Max_0, bool InclusiveMin, bool InclusiveMax)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InRange_FloatFloat");

	Params::KismetMathLibrary_InRange_FloatFloat Parms{};

	Parms.Value = Value;
	Parms.Min_0 = Min_0;
	Parms.Max_0 = Max_0;
	Parms.InclusiveMin = InclusiveMin;
	Parms.InclusiveMax = InclusiveMax;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.InRange_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InclusiveMin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InclusiveMax                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::InRange_Int64Int64(int64 Value, int64 Min_0, int64 Max_0, bool InclusiveMin, bool InclusiveMax)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InRange_Int64Int64");

	Params::KismetMathLibrary_InRange_Int64Int64 Parms{};

	Parms.Value = Value;
	Parms.Min_0 = Min_0;
	Parms.Max_0 = Max_0;
	Parms.InclusiveMin = InclusiveMin;
	Parms.InclusiveMax = InclusiveMax;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.InRange_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InclusiveMin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InclusiveMax                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::InRange_IntInt(int32 Value, int32 Min_0, int32 Max_0, bool InclusiveMin, bool InclusiveMax)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InRange_IntInt");

	Params::KismetMathLibrary_InRange_IntInt Parms{};

	Parms.Value = Value;
	Parms.Min_0 = Min_0;
	Parms.Max_0 = Max_0;
	Parms.InclusiveMin = InclusiveMin;
	Parms.InclusiveMax = InclusiveMax;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IntPoint_Down
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::IntPoint_Down()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IntPoint_Down");

	Params::KismetMathLibrary_IntPoint_Down Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IntPoint_Left
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::IntPoint_Left()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IntPoint_Left");

	Params::KismetMathLibrary_IntPoint_Left Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IntPoint_One
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::IntPoint_One()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IntPoint_One");

	Params::KismetMathLibrary_IntPoint_One Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IntPoint_Right
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::IntPoint_Right()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IntPoint_Right");

	Params::KismetMathLibrary_IntPoint_Right Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IntPoint_Up
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::IntPoint_Up()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IntPoint_Up");

	Params::KismetMathLibrary_IntPoint_Up Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IntPoint_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::IntPoint_Zero()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IntPoint_Zero");

	Params::KismetMathLibrary_IntPoint_Zero Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.InverseTransformDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::InverseTransformDirection(const struct FTransform& T, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InverseTransformDirection");

	Params::KismetMathLibrary_InverseTransformDirection Parms{};

	Parms.T = std::move(T);
	Parms.Direction = std::move(Direction);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.InverseTransformLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::InverseTransformLocation(const struct FTransform& T, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InverseTransformLocation");

	Params::KismetMathLibrary_InverseTransformLocation Parms{};

	Parms.T = std::move(T);
	Parms.Location = std::move(Location);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.InverseTransformRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::InverseTransformRotation(const struct FTransform& T, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InverseTransformRotation");

	Params::KismetMathLibrary_InverseTransformRotation Parms{};

	Parms.T = std::move(T);
	Parms.Rotation = std::move(Rotation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.InvertTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::InvertTransform(const struct FTransform& T)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InvertTransform");

	Params::KismetMathLibrary_InvertTransform Parms{};

	Parms.T = std::move(T);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsAfternoon
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsAfternoon(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsAfternoon");

	Params::KismetMathLibrary_IsAfternoon Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsLeapYear
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Year                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsLeapYear(int32 Year)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsLeapYear");

	Params::KismetMathLibrary_IsLeapYear Parms{};

	Parms.Year = Year;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsMorning
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsMorning(const struct FDateTime& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsMorning");

	Params::KismetMathLibrary_IsMorning Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsNearlyZero2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsNearlyZero2D(const struct FVector2D& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsNearlyZero2D");

	Params::KismetMathLibrary_IsNearlyZero2D Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsPointInBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxOrigin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsPointInBox(const struct FVector& Point, const struct FVector& BoxOrigin, const struct FVector& BoxExtent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsPointInBox");

	Params::KismetMathLibrary_IsPointInBox Parms{};

	Parms.Point = std::move(Point);
	Parms.BoxOrigin = std::move(BoxOrigin);
	Parms.BoxExtent = std::move(BoxExtent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsPointInBoxWithTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       BoxWorldTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsPointInBoxWithTransform(const struct FVector& Point, const struct FTransform& BoxWorldTransform, const struct FVector& BoxExtent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsPointInBoxWithTransform");

	Params::KismetMathLibrary_IsPointInBoxWithTransform Parms{};

	Parms.Point = std::move(Point);
	Parms.BoxWorldTransform = std::move(BoxWorldTransform);
	Parms.BoxExtent = std::move(BoxExtent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsZero2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::IsZero2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsZero2D");

	Params::KismetMathLibrary_IsZero2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Lerp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Lerp(float A, float B, float Alpha)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Lerp");

	Params::KismetMathLibrary_Lerp Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.Alpha = Alpha;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less_ByteByte");

	Params::KismetMathLibrary_Less_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less_DateTimeDateTime");

	Params::KismetMathLibrary_Less_DateTimeDateTime Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less_DoubleDouble");

	Params::KismetMathLibrary_Less_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less_FloatFloat");

	Params::KismetMathLibrary_Less_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less_Int64Int64");

	Params::KismetMathLibrary_Less_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less_IntInt");

	Params::KismetMathLibrary_Less_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Less_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Less_TimespanTimespan");

	Params::KismetMathLibrary_Less_TimespanTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual_ByteByte");

	Params::KismetMathLibrary_LessEqual_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual_DateTimeDateTime");

	Params::KismetMathLibrary_LessEqual_DateTimeDateTime Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual_DoubleDouble");

	Params::KismetMathLibrary_LessEqual_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual_FloatFloat");

	Params::KismetMathLibrary_LessEqual_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual_Int64Int64");

	Params::KismetMathLibrary_LessEqual_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual_IntInt");

	Params::KismetMathLibrary_LessEqual_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LessEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessEqual_TimespanTimespan");

	Params::KismetMathLibrary_LessEqual_TimespanTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessLess_VectorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::LessLess_VectorRotator(const struct FVector& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LessLess_VectorRotator");

	Params::KismetMathLibrary_LessLess_VectorRotator Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Black
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Black()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Black");

	Params::KismetMathLibrary_LinearColor_Black Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Blue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Blue()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Blue");

	Params::KismetMathLibrary_LinearColor_Blue Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Desaturated
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDesaturation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Desaturated(const struct FLinearColor& InColor, float InDesaturation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Desaturated");

	Params::KismetMathLibrary_LinearColor_Desaturated Parms{};

	Parms.InColor = std::move(InColor);
	Parms.InDesaturation = InDesaturation;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Distance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     C1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     C2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::LinearColor_Distance(const struct FLinearColor& C1, const struct FLinearColor& C2)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Distance");

	Params::KismetMathLibrary_LinearColor_Distance Parms{};

	Parms.C1 = std::move(C1);
	Parms.C2 = std::move(C2);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_GetLuminance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::LinearColor_GetLuminance(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_GetLuminance");

	Params::KismetMathLibrary_LinearColor_GetLuminance Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_GetMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::LinearColor_GetMax(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_GetMax");

	Params::KismetMathLibrary_LinearColor_GetMax Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_GetMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::LinearColor_GetMin(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_GetMin");

	Params::KismetMathLibrary_LinearColor_GetMin Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Gray
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Gray()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Gray");

	Params::KismetMathLibrary_LinearColor_Gray Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Green
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Green()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Green");

	Params::KismetMathLibrary_LinearColor_Green Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_IsNearEqual
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LinearColor_IsNearEqual(const struct FLinearColor& A, const struct FLinearColor& B, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_IsNearEqual");

	Params::KismetMathLibrary_LinearColor_IsNearEqual Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Quantize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetMathLibrary::LinearColor_Quantize(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Quantize");

	Params::KismetMathLibrary_LinearColor_Quantize Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_QuantizeRound
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetMathLibrary::LinearColor_QuantizeRound(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_QuantizeRound");

	Params::KismetMathLibrary_LinearColor_QuantizeRound Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Red
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Red()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Red");

	Params::KismetMathLibrary_LinearColor_Red Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Set
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InOutColor                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_Set(struct FLinearColor& InOutColor, const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Set");

	Params::KismetMathLibrary_LinearColor_Set Parms{};

	Parms.InOutColor = std::move(InOutColor);
	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	InOutColor = std::move(Parms.InOutColor);
}


// Function Engine.KismetMathLibrary.LinearColor_SetFromHSV
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InOutColor                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   H                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   S                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetFromHSV(struct FLinearColor& InOutColor, float H, float S, float V, float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_SetFromHSV");

	Params::KismetMathLibrary_LinearColor_SetFromHSV Parms{};

	Parms.InOutColor = std::move(InOutColor);
	Parms.H = H;
	Parms.S = S;
	Parms.V = V;
	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	InOutColor = std::move(Parms.InOutColor);
}


// Function Engine.KismetMathLibrary.LinearColor_SetFromPow22
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InOutColor                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           InColor                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetFromPow22(struct FLinearColor& InOutColor, const struct FColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_SetFromPow22");

	Params::KismetMathLibrary_LinearColor_SetFromPow22 Parms{};

	Parms.InOutColor = std::move(InOutColor);
	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	InOutColor = std::move(Parms.InOutColor);
}


// Function Engine.KismetMathLibrary.LinearColor_SetFromSRGB
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InOutColor                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           InSRGB                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetFromSRGB(struct FLinearColor& InOutColor, const struct FColor& InSRGB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_SetFromSRGB");

	Params::KismetMathLibrary_LinearColor_SetFromSRGB Parms{};

	Parms.InOutColor = std::move(InOutColor);
	Parms.InSRGB = std::move(InSRGB);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	InOutColor = std::move(Parms.InOutColor);
}


// Function Engine.KismetMathLibrary.LinearColor_SetRandomHue
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InOutColor                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetRandomHue(struct FLinearColor& InOutColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_SetRandomHue");

	Params::KismetMathLibrary_LinearColor_SetRandomHue Parms{};

	Parms.InOutColor = std::move(InOutColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	InOutColor = std::move(Parms.InOutColor);
}


// Function Engine.KismetMathLibrary.LinearColor_SetRGBA
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InOutColor                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetRGBA(struct FLinearColor& InOutColor, float R, float G, float B, float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_SetRGBA");

	Params::KismetMathLibrary_LinearColor_SetRGBA Parms{};

	Parms.InOutColor = std::move(InOutColor);
	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	InOutColor = std::move(Parms.InOutColor);
}


// Function Engine.KismetMathLibrary.LinearColor_SetTemperature
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InOutColor                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTemperature                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::LinearColor_SetTemperature(struct FLinearColor& InOutColor, float InTemperature)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_SetTemperature");

	Params::KismetMathLibrary_LinearColor_SetTemperature Parms{};

	Parms.InOutColor = std::move(InOutColor);
	Parms.InTemperature = InTemperature;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	InOutColor = std::move(Parms.InOutColor);
}


// Function Engine.KismetMathLibrary.LinearColor_ToNewOpacity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InOpacity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_ToNewOpacity(const struct FLinearColor& InColor, float InOpacity)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_ToNewOpacity");

	Params::KismetMathLibrary_LinearColor_ToNewOpacity Parms{};

	Parms.InColor = std::move(InColor);
	Parms.InOpacity = InOpacity;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_ToRGBE
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InLinearColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UKismetMathLibrary::LinearColor_ToRGBE(const struct FLinearColor& InLinearColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_ToRGBE");

	Params::KismetMathLibrary_LinearColor_ToRGBE Parms{};

	Parms.InLinearColor = std::move(InLinearColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Transparent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Transparent()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Transparent");

	Params::KismetMathLibrary_LinearColor_Transparent Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_White
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_White()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_White");

	Params::KismetMathLibrary_LinearColor_White Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Yellow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColor_Yellow()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColor_Yellow");

	Params::KismetMathLibrary_LinearColor_Yellow Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColorLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColorLerp(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColorLerp");

	Params::KismetMathLibrary_LinearColorLerp Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::LinearColorLerpUsingHSV(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinearColorLerpUsingHSV");

	Params::KismetMathLibrary_LinearColorLerpUsingHSV Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinePlaneIntersection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          LineStart                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineEnd                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                           APlane                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   T                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Intersection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LinePlaneIntersection(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FPlane& APlane, float* T, struct FVector* Intersection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinePlaneIntersection");

	Params::KismetMathLibrary_LinePlaneIntersection Parms{};

	Parms.LineStart = std::move(LineStart);
	Parms.LineEnd = std::move(LineEnd);
	Parms.APlane = std::move(APlane);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (T != nullptr)
		*T = Parms.T;

	if (Intersection != nullptr)
		*Intersection = std::move(Parms.Intersection);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          LineStart                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineEnd                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneOrigin                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   T                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Intersection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::LinePlaneIntersection_OriginNormal(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal, float* T, struct FVector* Intersection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LinePlaneIntersection_OriginNormal");

	Params::KismetMathLibrary_LinePlaneIntersection_OriginNormal Parms{};

	Parms.LineStart = std::move(LineStart);
	Parms.LineEnd = std::move(LineEnd);
	Parms.PlaneOrigin = std::move(PlaneOrigin);
	Parms.PlaneNormal = std::move(PlaneNormal);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (T != nullptr)
		*T = Parms.T;

	if (Intersection != nullptr)
		*Intersection = std::move(Parms.Intersection);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Log
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Base                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Log(float A, float Base)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Log");

	Params::KismetMathLibrary_Log Parms{};

	Parms.A = A;
	Parms.Base = Base;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Loge
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Loge(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Loge");

	Params::KismetMathLibrary_Loge Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UKismetMathLibrary::MakeBox(const struct FVector& Min_0, const struct FVector& Max_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeBox");

	Params::KismetMathLibrary_MakeBox Parms{};

	Parms.Min_0 = std::move(Min_0);
	Parms.Max_0 = std::move(Max_0);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeBox2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBox2D UKismetMathLibrary::MakeBox2D(const struct FVector2D& Min_0, const struct FVector2D& Max_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeBox2D");

	Params::KismetMathLibrary_MakeBox2D Parms{};

	Parms.Min_0 = std::move(Min_0);
	Parms.Max_0 = std::move(Max_0);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::MakeColor(float R, float G, float B, float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeColor");

	Params::KismetMathLibrary_MakeColor Parms{};

	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Year                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Month                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Day                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hour                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minute                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Second                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Millisecond                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::MakeDateTime(int32 Year, int32 Month, int32 Day, int32 Hour, int32 Minute, int32 Second, int32 Millisecond)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeDateTime");

	Params::KismetMathLibrary_MakeDateTime Parms{};

	Parms.Year = Year;
	Parms.Month = Month;
	Parms.Day = Day;
	Parms.Hour = Hour;
	Parms.Minute = Minute;
	Parms.Second = Second;
	Parms.Millisecond = Millisecond;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeFrameRate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Numerator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Denominator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameRate                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFrameRate UKismetMathLibrary::MakeFrameRate(int32 Numerator, int32 Denominator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeFrameRate");

	Params::KismetMathLibrary_MakeFrameRate Parms{};

	Parms.Numerator = Numerator;
	Parms.Denominator = Denominator;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakePlaneFromPointAndNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal_0                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPlane UKismetMathLibrary::MakePlaneFromPointAndNormal(const struct FVector& Point, const struct FVector& Normal_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakePlaneFromPointAndNormal");

	Params::KismetMathLibrary_MakePlaneFromPointAndNormal Parms{};

	Parms.Point = std::move(Point);
	Parms.Normal_0 = std::move(Normal_0);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakePulsatingValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InCurrentTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPulsesPerSecond                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPhase                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakePulsatingValue");

	Params::KismetMathLibrary_MakePulsatingValue Parms{};

	Parms.InCurrentTime = InCurrentTime;
	Parms.InPulsesPerSecond = InPulsesPerSecond;
	Parms.InPhase = InPhase;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeQualifiedFrameTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFrameNumber                     Frame                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameRate                       FrameRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SubFrame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQualifiedFrameTime              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQualifiedFrameTime UKismetMathLibrary::MakeQualifiedFrameTime(const struct FFrameNumber& Frame, const struct FFrameRate& FrameRate, float SubFrame)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeQualifiedFrameTime");

	Params::KismetMathLibrary_MakeQualifiedFrameTime Parms{};

	Parms.Frame = std::move(Frame);
	Parms.FrameRate = std::move(FrameRate);
	Parms.SubFrame = SubFrame;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRandomStream
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InitialSeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRandomStream UKismetMathLibrary::MakeRandomStream(int32 InitialSeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRandomStream");

	Params::KismetMathLibrary_MakeRandomStream Parms{};

	Parms.InitialSeed = InitialSeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRelativeTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       RelativeTo                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::MakeRelativeTransform(const struct FTransform& A, const struct FTransform& RelativeTo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRelativeTransform");

	Params::KismetMathLibrary_MakeRelativeTransform Parms{};

	Parms.A = std::move(A);
	Parms.RelativeTo = std::move(RelativeTo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotationFromAxes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Forward                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Up                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotationFromAxes(const struct FVector& Forward, const struct FVector& Right, const struct FVector& Up)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotationFromAxes");

	Params::KismetMathLibrary_MakeRotationFromAxes Parms{};

	Parms.Forward = std::move(Forward);
	Parms.Right = std::move(Right);
	Parms.Up = std::move(Up);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotator(float Roll, float Pitch, float Yaw)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotator");

	Params::KismetMathLibrary_MakeRotator Parms{};

	Parms.Roll = Roll;
	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          X                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromX(const struct FVector& X)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromX");

	Params::KismetMathLibrary_MakeRotFromX Parms{};

	Parms.X = std::move(X);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromXY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          X                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Y                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromXY(const struct FVector& X, const struct FVector& Y)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromXY");

	Params::KismetMathLibrary_MakeRotFromXY Parms{};

	Parms.X = std::move(X);
	Parms.Y = std::move(Y);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromXZ
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          X                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Z                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromXZ(const struct FVector& X, const struct FVector& Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromXZ");

	Params::KismetMathLibrary_MakeRotFromXZ Parms{};

	Parms.X = std::move(X);
	Parms.Z = std::move(Z);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Y                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromY(const struct FVector& Y)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromY");

	Params::KismetMathLibrary_MakeRotFromY Parms{};

	Parms.Y = std::move(Y);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromYX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Y                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          X                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromYX(const struct FVector& Y, const struct FVector& X)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromYX");

	Params::KismetMathLibrary_MakeRotFromYX Parms{};

	Parms.Y = std::move(Y);
	Parms.X = std::move(X);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromYZ
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Y                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Z                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromYZ(const struct FVector& Y, const struct FVector& Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromYZ");

	Params::KismetMathLibrary_MakeRotFromYZ Parms{};

	Parms.Y = std::move(Y);
	Parms.Z = std::move(Z);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromZ
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Z                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromZ(const struct FVector& Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromZ");

	Params::KismetMathLibrary_MakeRotFromZ Parms{};

	Parms.Z = std::move(Z);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromZX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Z                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          X                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromZX(const struct FVector& Z, const struct FVector& X)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromZX");

	Params::KismetMathLibrary_MakeRotFromZX Parms{};

	Parms.Z = std::move(Z);
	Parms.X = std::move(X);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromZY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Z                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Y                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::MakeRotFromZY(const struct FVector& Z, const struct FVector& Y)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeRotFromZY");

	Params::KismetMathLibrary_MakeRotFromZY Parms{};

	Parms.Z = std::move(Z);
	Parms.Y = std::move(Y);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Milliseconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::MakeTimespan(int32 days, int32 Hours, int32 Minutes, int32 Seconds, int32 Milliseconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeTimespan");

	Params::KismetMathLibrary_MakeTimespan Parms{};

	Parms.days = days;
	Parms.Hours = Hours;
	Parms.Minutes = Minutes;
	Parms.Seconds = Seconds;
	Parms.Milliseconds = Milliseconds;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeTimespan2
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Hours                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minutes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FractionNano                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::MakeTimespan2(int32 days, int32 Hours, int32 Minutes, int32 Seconds, int32 FractionNano)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeTimespan2");

	Params::KismetMathLibrary_MakeTimespan2 Parms{};

	Parms.days = days;
	Parms.Hours = Hours;
	Parms.Minutes = Minutes;
	Parms.Seconds = Seconds;
	Parms.FractionNano = FractionNano;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::MakeTransform(const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeTransform");

	Params::KismetMathLibrary_MakeTransform Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::MakeVector(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeVector");

	Params::KismetMathLibrary_MakeVector Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::MakeVector2D(float X, float Y)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeVector2D");

	Params::KismetMathLibrary_MakeVector2D Parms{};

	Parms.X = X;
	Parms.Y = Y;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector4
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   W                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::MakeVector4(float X, float Y, float Z, float W)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeVector4");

	Params::KismetMathLibrary_MakeVector4 Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.W = W;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector_NetQuantize
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector_NetQuantize UKismetMathLibrary::MakeVector_NetQuantize(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeVector_NetQuantize");

	Params::KismetMathLibrary_MakeVector_NetQuantize Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector_NetQuantize10
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize10            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector_NetQuantize10 UKismetMathLibrary::MakeVector_NetQuantize10(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeVector_NetQuantize10");

	Params::KismetMathLibrary_MakeVector_NetQuantize10 Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector_NetQuantize100
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector_NetQuantize100 UKismetMathLibrary::MakeVector_NetQuantize100(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeVector_NetQuantize100");

	Params::KismetMathLibrary_MakeVector_NetQuantize100 Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector_NetQuantizeNormal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector_NetQuantizeNormal UKismetMathLibrary::MakeVector_NetQuantizeNormal(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeVector_NetQuantizeNormal");

	Params::KismetMathLibrary_MakeVector_NetQuantizeNormal Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MapRangeClamped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRangeA                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRangeB                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutRangeA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutRangeB                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MapRangeClamped");

	Params::KismetMathLibrary_MapRangeClamped Parms{};

	Parms.Value = Value;
	Parms.InRangeA = InRangeA;
	Parms.InRangeB = InRangeB;
	Parms.OutRangeA = OutRangeA;
	Parms.OutRangeB = OutRangeB;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MapRangeUnclamped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRangeA                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRangeB                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutRangeA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutRangeB                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MapRangeUnclamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MapRangeUnclamped");

	Params::KismetMathLibrary_MapRangeUnclamped Parms{};

	Parms.Value = Value;
	Parms.InRangeA = InRangeA;
	Parms.InRangeB = InRangeB;
	Parms.OutRangeA = OutRangeA;
	Parms.OutRangeB = OutRangeB;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_ApplyScale
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_ApplyScale(const struct FMatrix& M, float Scale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_ApplyScale");

	Params::KismetMathLibrary_Matrix_ApplyScale Parms{};

	Parms.M = std::move(M);
	Parms.Scale = Scale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_ConcatenateTranslation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Translation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_ConcatenateTranslation(const struct FMatrix& M, const struct FVector& Translation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_ConcatenateTranslation");

	Params::KismetMathLibrary_Matrix_ConcatenateTranslation Parms{};

	Parms.M = std::move(M);
	Parms.Translation = std::move(Translation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_ContainsNaN
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Matrix_ContainsNaN(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_ContainsNaN");

	Params::KismetMathLibrary_Matrix_ContainsNaN Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetColumn
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EMatrixColumns                          Column                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Matrix_GetColumn(const struct FMatrix& M, EMatrixColumns Column)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetColumn");

	Params::KismetMathLibrary_Matrix_GetColumn Parms{};

	Parms.M = std::move(M);
	Parms.Column = Column;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetDeterminant
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Matrix_GetDeterminant(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetDeterminant");

	Params::KismetMathLibrary_Matrix_GetDeterminant Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumBottomPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlane                           OutPlane                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Matrix_GetFrustumBottomPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetFrustumBottomPlane");

	Params::KismetMathLibrary_Matrix_GetFrustumBottomPlane Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPlane != nullptr)
		*OutPlane = std::move(Parms.OutPlane);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumFarPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlane                           OutPlane                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Matrix_GetFrustumFarPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetFrustumFarPlane");

	Params::KismetMathLibrary_Matrix_GetFrustumFarPlane Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPlane != nullptr)
		*OutPlane = std::move(Parms.OutPlane);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumLeftPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlane                           OutPlane                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Matrix_GetFrustumLeftPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetFrustumLeftPlane");

	Params::KismetMathLibrary_Matrix_GetFrustumLeftPlane Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPlane != nullptr)
		*OutPlane = std::move(Parms.OutPlane);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumNearPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlane                           OutPlane                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Matrix_GetFrustumNearPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetFrustumNearPlane");

	Params::KismetMathLibrary_Matrix_GetFrustumNearPlane Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPlane != nullptr)
		*OutPlane = std::move(Parms.OutPlane);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumRightPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlane                           OutPlane                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Matrix_GetFrustumRightPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetFrustumRightPlane");

	Params::KismetMathLibrary_Matrix_GetFrustumRightPlane Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPlane != nullptr)
		*OutPlane = std::move(Parms.OutPlane);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumTopPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlane                           OutPlane                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Matrix_GetFrustumTopPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetFrustumTopPlane");

	Params::KismetMathLibrary_Matrix_GetFrustumTopPlane Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPlane != nullptr)
		*OutPlane = std::move(Parms.OutPlane);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetInverse
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_GetInverse(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetInverse");

	Params::KismetMathLibrary_Matrix_GetInverse Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetMatrixWithoutScale
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_GetMatrixWithoutScale(const struct FMatrix& M, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetMatrixWithoutScale");

	Params::KismetMathLibrary_Matrix_GetMatrixWithoutScale Parms{};

	Parms.M = std::move(M);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetMaximumAxisScale
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Matrix_GetMaximumAxisScale(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetMaximumAxisScale");

	Params::KismetMathLibrary_Matrix_GetMaximumAxisScale Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetOrigin
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          InMatrix                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Matrix_GetOrigin(const struct FMatrix& InMatrix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetOrigin");

	Params::KismetMathLibrary_Matrix_GetOrigin Parms{};

	Parms.InMatrix = std::move(InMatrix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Matrix_GetRotator(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetRotator");

	Params::KismetMathLibrary_Matrix_GetRotator Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetRotDeterminant
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Matrix_GetRotDeterminant(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetRotDeterminant");

	Params::KismetMathLibrary_Matrix_GetRotDeterminant Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetScaledAxes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Matrix_GetScaledAxes(const struct FMatrix& M, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetScaledAxes");

	Params::KismetMathLibrary_Matrix_GetScaledAxes Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = std::move(Parms.X);

	if (Y != nullptr)
		*Y = std::move(Parms.Y);

	if (Z != nullptr)
		*Z = std::move(Parms.Z);
}


// Function Engine.KismetMathLibrary.Matrix_GetScaledAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAxis                                   Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Matrix_GetScaledAxis(const struct FMatrix& M, EAxis Axis)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetScaledAxis");

	Params::KismetMathLibrary_Matrix_GetScaledAxis Parms{};

	Parms.M = std::move(M);
	Parms.Axis = Axis;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetScaleVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Matrix_GetScaleVector(const struct FMatrix& M, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetScaleVector");

	Params::KismetMathLibrary_Matrix_GetScaleVector Parms{};

	Parms.M = std::move(M);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetTransposeAdjoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_GetTransposeAdjoint(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetTransposeAdjoint");

	Params::KismetMathLibrary_Matrix_GetTransposeAdjoint Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetTransposed
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_GetTransposed(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetTransposed");

	Params::KismetMathLibrary_Matrix_GetTransposed Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetUnitAxes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Z                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Matrix_GetUnitAxes(const struct FMatrix& M, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetUnitAxes");

	Params::KismetMathLibrary_Matrix_GetUnitAxes Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = std::move(Parms.X);

	if (Y != nullptr)
		*Y = std::move(Parms.Y);

	if (Z != nullptr)
		*Z = std::move(Parms.Z);
}


// Function Engine.KismetMathLibrary.Matrix_GetUnitAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAxis                                   Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Matrix_GetUnitAxis(const struct FMatrix& M, EAxis Axis)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_GetUnitAxis");

	Params::KismetMathLibrary_Matrix_GetUnitAxis Parms{};

	Parms.M = std::move(M);
	Parms.Axis = Axis;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_Identity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_Identity()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_Identity");

	Params::KismetMathLibrary_Matrix_Identity Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_InverseTransformPosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Matrix_InverseTransformPosition(const struct FMatrix& M, const struct FVector& V)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_InverseTransformPosition");

	Params::KismetMathLibrary_Matrix_InverseTransformPosition Parms{};

	Parms.M = std::move(M);
	Parms.V = std::move(V);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_InverseTransformVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Matrix_InverseTransformVector(const struct FMatrix& M, const struct FVector& V)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_InverseTransformVector");

	Params::KismetMathLibrary_Matrix_InverseTransformVector Parms{};

	Parms.M = std::move(M);
	Parms.V = std::move(V);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_Mirror
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAxis                                   MirrorAxis                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAxis                                   FlipAxis                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_Mirror(const struct FMatrix& M, EAxis MirrorAxis, EAxis FlipAxis)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_Mirror");

	Params::KismetMathLibrary_Matrix_Mirror Parms{};

	Parms.M = std::move(M);
	Parms.MirrorAxis = MirrorAxis;
	Parms.FlipAxis = FlipAxis;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_RemoveScaling
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatrix                          M                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Matrix_RemoveScaling(struct FMatrix& M, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_RemoveScaling");

	Params::KismetMathLibrary_Matrix_RemoveScaling Parms{};

	Parms.M = std::move(M);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	M = std::move(Parms.M);
}


// Function Engine.KismetMathLibrary.Matrix_RemoveTranslation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_RemoveTranslation(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_RemoveTranslation");

	Params::KismetMathLibrary_Matrix_RemoveTranslation Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_ScaleTranslation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale3D                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Matrix_ScaleTranslation(const struct FMatrix& M, const struct FVector& Scale3D)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_ScaleTranslation");

	Params::KismetMathLibrary_Matrix_ScaleTranslation Parms{};

	Parms.M = std::move(M);
	Parms.Scale3D = std::move(Scale3D);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_SetAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatrix                          M                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAxis                                   Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AxisVector                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Matrix_SetAxis(struct FMatrix& M, EAxis Axis, const struct FVector& AxisVector)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_SetAxis");

	Params::KismetMathLibrary_Matrix_SetAxis Parms{};

	Parms.M = std::move(M);
	Parms.Axis = Axis;
	Parms.AxisVector = std::move(AxisVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	M = std::move(Parms.M);
}


// Function Engine.KismetMathLibrary.Matrix_SetColumn
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatrix                          M                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EMatrixColumns                          Column                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Matrix_SetColumn(struct FMatrix& M, EMatrixColumns Column, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_SetColumn");

	Params::KismetMathLibrary_Matrix_SetColumn Parms{};

	Parms.M = std::move(M);
	Parms.Column = Column;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	M = std::move(Parms.M);
}


// Function Engine.KismetMathLibrary.Matrix_SetOrigin
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatrix                          M                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          NewOrigin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Matrix_SetOrigin(struct FMatrix& M, const struct FVector& NewOrigin)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_SetOrigin");

	Params::KismetMathLibrary_Matrix_SetOrigin Parms{};

	Parms.M = std::move(M);
	Parms.NewOrigin = std::move(NewOrigin);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	M = std::move(Parms.M);
}


// Function Engine.KismetMathLibrary.Matrix_ToQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Matrix_ToQuat(const struct FMatrix& M)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_ToQuat");

	Params::KismetMathLibrary_Matrix_ToQuat Parms{};

	Parms.M = std::move(M);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_TransformPosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Matrix_TransformPosition(const struct FMatrix& M, const struct FVector& V)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_TransformPosition");

	Params::KismetMathLibrary_Matrix_TransformPosition Parms{};

	Parms.M = std::move(M);
	Parms.V = std::move(V);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_TransformVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Matrix_TransformVector(const struct FMatrix& M, const struct FVector& V)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_TransformVector");

	Params::KismetMathLibrary_Matrix_TransformVector Parms{};

	Parms.M = std::move(M);
	Parms.V = std::move(V);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_TransformVector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          M                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector4                         V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Matrix_TransformVector4(const struct FMatrix& M, const struct FVector4& V)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Matrix_TransformVector4");

	Params::KismetMathLibrary_Matrix_TransformVector4 Parms{};

	Parms.M = std::move(M);
	Parms.V = std::move(V);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Max
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Max(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Max");

	Params::KismetMathLibrary_Max Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MaxInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::MaxInt64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MaxInt64");

	Params::KismetMathLibrary_MaxInt64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MaxOfByteArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                           ByteArray                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   IndexOfMaxValue                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   MaxValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MaxOfByteArray(const TArray<uint8>& ByteArray, int32* IndexOfMaxValue, uint8* MaxValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MaxOfByteArray");

	Params::KismetMathLibrary_MaxOfByteArray Parms{};

	Parms.ByteArray = std::move(ByteArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = Parms.IndexOfMaxValue;

	if (MaxValue != nullptr)
		*MaxValue = Parms.MaxValue;
}


// Function Engine.KismetMathLibrary.MaxOfFloatArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                           FloatArray                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   IndexOfMaxValue                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MaxOfFloatArray(const TArray<float>& FloatArray, int32* IndexOfMaxValue, float* MaxValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MaxOfFloatArray");

	Params::KismetMathLibrary_MaxOfFloatArray Parms{};

	Parms.FloatArray = std::move(FloatArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = Parms.IndexOfMaxValue;

	if (MaxValue != nullptr)
		*MaxValue = Parms.MaxValue;
}


// Function Engine.KismetMathLibrary.MaxOfIntArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           IntArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   IndexOfMaxValue                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MaxOfIntArray(const TArray<int32>& IntArray, int32* IndexOfMaxValue, int32* MaxValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MaxOfIntArray");

	Params::KismetMathLibrary_MaxOfIntArray Parms{};

	Parms.IntArray = std::move(IntArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = Parms.IndexOfMaxValue;

	if (MaxValue != nullptr)
		*MaxValue = Parms.MaxValue;
}


// Function Engine.KismetMathLibrary.Min
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Min(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Min");

	Params::KismetMathLibrary_Min Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MinimumAreaRectangle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  InVerts                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          SampleSurfaceNormal                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutRectCenter                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutRectRotation                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OutSideLengthX                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutSideLengthY                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebugDraw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MinimumAreaRectangle(class UObject* WorldContextObject, const TArray<struct FVector>& InVerts, const struct FVector& SampleSurfaceNormal, struct FVector* OutRectCenter, struct FRotator* OutRectRotation, float* OutSideLengthX, float* OutSideLengthY, bool bDebugDraw)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MinimumAreaRectangle");

	Params::KismetMathLibrary_MinimumAreaRectangle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InVerts = std::move(InVerts);
	Parms.SampleSurfaceNormal = std::move(SampleSurfaceNormal);
	Parms.bDebugDraw = bDebugDraw;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutRectCenter != nullptr)
		*OutRectCenter = std::move(Parms.OutRectCenter);

	if (OutRectRotation != nullptr)
		*OutRectRotation = std::move(Parms.OutRectRotation);

	if (OutSideLengthX != nullptr)
		*OutSideLengthX = Parms.OutSideLengthX;

	if (OutSideLengthY != nullptr)
		*OutSideLengthY = Parms.OutSideLengthY;
}


// Function Engine.KismetMathLibrary.MinInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::MinInt64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MinInt64");

	Params::KismetMathLibrary_MinInt64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MinOfByteArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                           ByteArray                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   IndexOfMinValue                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   MinValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MinOfByteArray(const TArray<uint8>& ByteArray, int32* IndexOfMinValue, uint8* MinValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MinOfByteArray");

	Params::KismetMathLibrary_MinOfByteArray Parms{};

	Parms.ByteArray = std::move(ByteArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = Parms.IndexOfMinValue;

	if (MinValue != nullptr)
		*MinValue = Parms.MinValue;
}


// Function Engine.KismetMathLibrary.MinOfFloatArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                           FloatArray                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   IndexOfMinValue                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MinOfFloatArray(const TArray<float>& FloatArray, int32* IndexOfMinValue, float* MinValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MinOfFloatArray");

	Params::KismetMathLibrary_MinOfFloatArray Parms{};

	Parms.FloatArray = std::move(FloatArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = Parms.IndexOfMinValue;

	if (MinValue != nullptr)
		*MinValue = Parms.MinValue;
}


// Function Engine.KismetMathLibrary.MinOfIntArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           IntArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   IndexOfMinValue                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::MinOfIntArray(const TArray<int32>& IntArray, int32* IndexOfMinValue, int32* MinValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MinOfIntArray");

	Params::KismetMathLibrary_MinOfIntArray Parms{};

	Parms.IntArray = std::move(IntArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = Parms.IndexOfMinValue;

	if (MinValue != nullptr)
		*MinValue = Parms.MinValue;
}


// Function Engine.KismetMathLibrary.MirrorVectorByNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InNormal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::MirrorVectorByNormal(const struct FVector& InVect, const struct FVector& InNormal)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MirrorVectorByNormal");

	Params::KismetMathLibrary_MirrorVectorByNormal Parms{};

	Parms.InVect = std::move(InVect);
	Parms.InNormal = std::move(InNormal);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Multiply_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_ByteByte");

	Params::KismetMathLibrary_Multiply_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetMathLibrary::Multiply_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_DoubleDouble");

	Params::KismetMathLibrary_Multiply_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Multiply_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_FloatFloat");

	Params::KismetMathLibrary_Multiply_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Multiply_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_Int64Int64");

	Params::KismetMathLibrary_Multiply_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_IntFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Multiply_IntFloat(int32 A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_IntFloat");

	Params::KismetMathLibrary_Multiply_IntFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Multiply_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_IntInt");

	Params::KismetMathLibrary_Multiply_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_IntPointInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Multiply_IntPointInt(const struct FIntPoint& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_IntPointInt");

	Params::KismetMathLibrary_Multiply_IntPointInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_IntPointIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Multiply_IntPointIntPoint(const struct FIntPoint& A, const struct FIntPoint& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_IntPointIntPoint");

	Params::KismetMathLibrary_Multiply_IntPointIntPoint Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_LinearColorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Multiply_LinearColorFloat(const struct FLinearColor& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_LinearColorFloat");

	Params::KismetMathLibrary_Multiply_LinearColorFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Multiply_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_LinearColorLinearColor");

	Params::KismetMathLibrary_Multiply_LinearColorLinearColor Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_MatrixFloat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Multiply_MatrixFloat(const struct FMatrix& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_MatrixFloat");

	Params::KismetMathLibrary_Multiply_MatrixFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_MatrixMatrix
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMatrix UKismetMathLibrary::Multiply_MatrixMatrix(const struct FMatrix& A, const struct FMatrix& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_MatrixMatrix");

	Params::KismetMathLibrary_Multiply_MatrixMatrix Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Multiply_QuatQuat(const struct FQuat& A, const struct FQuat& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_QuatQuat");

	Params::KismetMathLibrary_Multiply_QuatQuat Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_RotatorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Multiply_RotatorFloat(const struct FRotator& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_RotatorFloat");

	Params::KismetMathLibrary_Multiply_RotatorFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_RotatorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Multiply_RotatorInt(const struct FRotator& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_RotatorInt");

	Params::KismetMathLibrary_Multiply_RotatorInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_TimespanFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scalar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Multiply_TimespanFloat(const struct FTimespan& A, float Scalar)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_TimespanFloat");

	Params::KismetMathLibrary_Multiply_TimespanFloat Parms{};

	Parms.A = std::move(A);
	Parms.Scalar = Scalar;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Multiply_Vector2DFloat(const struct FVector2D& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_Vector2DFloat");

	Params::KismetMathLibrary_Multiply_Vector2DFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Multiply_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_Vector2DVector2D");

	Params::KismetMathLibrary_Multiply_Vector2DVector2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Multiply_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_Vector4Vector4");

	Params::KismetMathLibrary_Multiply_Vector4Vector4 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Multiply_VectorFloat(const struct FVector& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_VectorFloat");

	Params::KismetMathLibrary_Multiply_VectorFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Multiply_VectorInt(const struct FVector& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_VectorInt");

	Params::KismetMathLibrary_Multiply_VectorInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Multiply_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Multiply_VectorVector");

	Params::KismetMathLibrary_Multiply_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MultiplyByPi
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MultiplyByPi(float Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MultiplyByPi");

	Params::KismetMathLibrary_MultiplyByPi Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Base                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Exp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::MultiplyMultiply_FloatFloat(float Base, float Exp)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MultiplyMultiply_FloatFloat");

	Params::KismetMathLibrary_MultiplyMultiply_FloatFloat Parms{};

	Parms.Base = Base;
	Parms.Exp = Exp;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NearlyEqual_FloatFloat");

	Params::KismetMathLibrary_NearlyEqual_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   LocationTolerance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RotationTolerance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale3DTolerance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NearlyEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NearlyEqual_TransformTransform");

	Params::KismetMathLibrary_NearlyEqual_TransformTransform Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.LocationTolerance = LocationTolerance;
	Parms.RotationTolerance = RotationTolerance;
	Parms.Scale3DTolerance = Scale3DTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Negated2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Negated2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Negated2D");

	Params::KismetMathLibrary_Negated2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NegateRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::NegateRotator(const struct FRotator& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NegateRotator");

	Params::KismetMathLibrary_NegateRotator Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NegateVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::NegateVector(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NegateVector");

	Params::KismetMathLibrary_NegateVector Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Normal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Normal(const struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Normal");

	Params::KismetMathLibrary_Normal Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Normal2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Normal2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Normal2D");

	Params::KismetMathLibrary_Normal2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Normalize2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Normalize2D(struct FVector2D& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Normalize2D");

	Params::KismetMathLibrary_Normalize2D Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.NormalizeAxis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::NormalizeAxis(float Angle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NormalizeAxis");

	Params::KismetMathLibrary_NormalizeAxis Parms{};

	Parms.Angle = Angle;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NormalizedDeltaRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::NormalizedDeltaRotator(const struct FRotator& A, const struct FRotator& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NormalizedDeltaRotator");

	Params::KismetMathLibrary_NormalizedDeltaRotator Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NormalizeToRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RangeMin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RangeMax                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::NormalizeToRange(float Value, float RangeMin, float RangeMax)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NormalizeToRange");

	Params::KismetMathLibrary_NormalizeToRange Parms{};

	Parms.Value = Value;
	Parms.RangeMin = RangeMin;
	Parms.RangeMax = RangeMax;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NormalSafe2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::NormalSafe2D(const struct FVector2D& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NormalSafe2D");

	Params::KismetMathLibrary_NormalSafe2D Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Not_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Not_Int(int32 A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Not_Int");

	Params::KismetMathLibrary_Not_Int Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Not_Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Not_Int64(int64 A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Not_Int64");

	Params::KismetMathLibrary_Not_Int64 Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Not_PreBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Not_PreBool(bool A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Not_PreBool");

	Params::KismetMathLibrary_Not_PreBool Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_BoolBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_BoolBool(bool A, bool B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_BoolBool");

	Params::KismetMathLibrary_NotEqual_BoolBool Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_ByteByte");

	Params::KismetMathLibrary_NotEqual_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_ClassClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_ClassClass(class UClass* A, class UClass* B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_ClassClass");

	Params::KismetMathLibrary_NotEqual_ClassClass Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_DateTimeDateTime");

	Params::KismetMathLibrary_NotEqual_DateTimeDateTime Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_DoubleDouble");

	Params::KismetMathLibrary_NotEqual_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_FloatFloat");

	Params::KismetMathLibrary_NotEqual_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_Int64Int64");

	Params::KismetMathLibrary_NotEqual_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_IntInt");

	Params::KismetMathLibrary_NotEqual_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_IntPointIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_IntPointIntPoint(const struct FIntPoint& A, const struct FIntPoint& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_IntPointIntPoint");

	Params::KismetMathLibrary_NotEqual_IntPointIntPoint Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_LinearColorLinearColor");

	Params::KismetMathLibrary_NotEqual_LinearColorLinearColor Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_MatrixMatrix
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_MatrixMatrix(const struct FMatrix& A, const struct FMatrix& B, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_MatrixMatrix");

	Params::KismetMathLibrary_NotEqual_MatrixMatrix Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_NameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_NameName(class FName A, class FName B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_NameName");

	Params::KismetMathLibrary_NotEqual_NameName Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_ObjectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_ObjectObject(class UObject* A, class UObject* B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_ObjectObject");

	Params::KismetMathLibrary_NotEqual_ObjectObject Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_QuatQuat(const struct FQuat& A, const struct FQuat& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_QuatQuat");

	Params::KismetMathLibrary_NotEqual_QuatQuat Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_RotatorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_RotatorRotator");

	Params::KismetMathLibrary_NotEqual_RotatorRotator Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_TimespanTimespan");

	Params::KismetMathLibrary_NotEqual_TimespanTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_Vector2DVector2D");

	Params::KismetMathLibrary_NotEqual_Vector2DVector2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_Vector4Vector4(const struct FVector4& A, const struct FVector4& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_Vector4Vector4");

	Params::KismetMathLibrary_NotEqual_Vector4Vector4 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ErrorTolerance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_VectorVector");

	Params::KismetMathLibrary_NotEqual_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.ErrorTolerance = ErrorTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqualExactly_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqualExactly_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqualExactly_Vector2DVector2D");

	Params::KismetMathLibrary_NotEqualExactly_Vector2DVector2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqualExactly_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqualExactly_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqualExactly_Vector4Vector4");

	Params::KismetMathLibrary_NotEqualExactly_Vector4Vector4 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqualExactly_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::NotEqualExactly_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqualExactly_VectorVector");

	Params::KismetMathLibrary_NotEqualExactly_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Now
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Now()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Now");

	Params::KismetMathLibrary_Now Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Or_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Or_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Or_Int64Int64");

	Params::KismetMathLibrary_Or_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Or_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Or_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Or_IntInt");

	Params::KismetMathLibrary_Or_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Percent_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Percent_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Percent_ByteByte");

	Params::KismetMathLibrary_Percent_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Percent_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Percent_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Percent_FloatFloat");

	Params::KismetMathLibrary_Percent_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Percent_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Percent_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Percent_IntInt");

	Params::KismetMathLibrary_Percent_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.PerlinNoise1D
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::PerlinNoise1D(const float Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PerlinNoise1D");

	Params::KismetMathLibrary_PerlinNoise1D Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.PointsAreCoplanar
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::PointsAreCoplanar(const TArray<struct FVector>& Points, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointsAreCoplanar");

	Params::KismetMathLibrary_PointsAreCoplanar Parms{};

	Parms.Points = std::move(Points);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ProjectPointOnToPlane
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneBase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::ProjectPointOnToPlane(const struct FVector& Point, const struct FVector& PlaneBase, const struct FVector& PlaneNormal)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectPointOnToPlane");

	Params::KismetMathLibrary_ProjectPointOnToPlane Parms{};

	Parms.Point = std::move(Point);
	Parms.PlaneBase = std::move(PlaneBase);
	Parms.PlaneNormal = std::move(PlaneNormal);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ProjectVectorOnToPlane
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::ProjectVectorOnToPlane(const struct FVector& V, const struct FVector& PlaneNormal)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectVectorOnToPlane");

	Params::KismetMathLibrary_ProjectVectorOnToPlane Parms{};

	Parms.V = std::move(V);
	Parms.PlaneNormal = std::move(PlaneNormal);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ProjectVectorOnToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::ProjectVectorOnToVector(const struct FVector& V, const struct FVector& Target)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectVectorOnToVector");

	Params::KismetMathLibrary_ProjectVectorOnToVector Parms{};

	Parms.V = std::move(V);
	Parms.Target = std::move(Target);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_AngularDistance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Quat_AngularDistance(const struct FQuat& A, const struct FQuat& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_AngularDistance");

	Params::KismetMathLibrary_Quat_AngularDistance Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_EnforceShortestArcWith
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            A                                                      (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Quat_EnforceShortestArcWith(struct FQuat& A, const struct FQuat& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_EnforceShortestArcWith");

	Params::KismetMathLibrary_Quat_EnforceShortestArcWith Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Quat_Euler
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_Euler(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Euler");

	Params::KismetMathLibrary_Quat_Euler Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Exp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Exp(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Exp");

	Params::KismetMathLibrary_Quat_Exp Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetAngle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Quat_GetAngle(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_GetAngle");

	Params::KismetMathLibrary_Quat_GetAngle Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetAxisX
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_GetAxisX(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_GetAxisX");

	Params::KismetMathLibrary_Quat_GetAxisX Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetAxisY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_GetAxisY(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_GetAxisY");

	Params::KismetMathLibrary_Quat_GetAxisY Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetAxisZ
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_GetAxisZ(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_GetAxisZ");

	Params::KismetMathLibrary_Quat_GetAxisZ Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetRotationAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_GetRotationAxis(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_GetRotationAxis");

	Params::KismetMathLibrary_Quat_GetRotationAxis Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Identity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Identity()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Identity");

	Params::KismetMathLibrary_Quat_Identity Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Inversed
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Inversed(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Inversed");

	Params::KismetMathLibrary_Quat_Inversed Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_IsFinite
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Quat_IsFinite(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_IsFinite");

	Params::KismetMathLibrary_Quat_IsFinite Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_IsIdentity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Quat_IsIdentity(const struct FQuat& Q, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_IsIdentity");

	Params::KismetMathLibrary_Quat_IsIdentity Parms{};

	Parms.Q = std::move(Q);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_IsNonFinite
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Quat_IsNonFinite(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_IsNonFinite");

	Params::KismetMathLibrary_Quat_IsNonFinite Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_IsNormalized
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Quat_IsNormalized(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_IsNormalized");

	Params::KismetMathLibrary_Quat_IsNormalized Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Log
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Log(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Log");

	Params::KismetMathLibrary_Quat_Log Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_MakeFromEuler
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Euler                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_MakeFromEuler(const struct FVector& Euler)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_MakeFromEuler");

	Params::KismetMathLibrary_Quat_MakeFromEuler Parms{};

	Parms.Euler = std::move(Euler);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Normalize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            Q                                                      (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Quat_Normalize(struct FQuat& Q, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Normalize");

	Params::KismetMathLibrary_Quat_Normalize Parms{};

	Parms.Q = std::move(Q);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Q = std::move(Parms.Q);
}


// Function Engine.KismetMathLibrary.Quat_Normalized
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Quat_Normalized(const struct FQuat& Q, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Normalized");

	Params::KismetMathLibrary_Quat_Normalized Parms{};

	Parms.Q = std::move(Q);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_RotateVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          V                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_RotateVector(const struct FQuat& Q, const struct FVector& V)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_RotateVector");

	Params::KismetMathLibrary_Quat_RotateVector Parms{};

	Parms.Q = std::move(Q);
	Parms.V = std::move(V);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Rotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::Quat_Rotator(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Rotator");

	Params::KismetMathLibrary_Quat_Rotator Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_SetComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            Q                                                      (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   W                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Quat_SetComponents(struct FQuat& Q, float X, float Y, float Z, float W)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_SetComponents");

	Params::KismetMathLibrary_Quat_SetComponents Parms{};

	Parms.Q = std::move(Q);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.W = W;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Q = std::move(Parms.Q);
}


// Function Engine.KismetMathLibrary.Quat_SetFromEuler
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            Q                                                      (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Euler                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Quat_SetFromEuler(struct FQuat& Q, const struct FVector& Euler)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_SetFromEuler");

	Params::KismetMathLibrary_Quat_SetFromEuler Parms{};

	Parms.Q = std::move(Q);
	Parms.Euler = std::move(Euler);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Q = std::move(Parms.Q);
}


// Function Engine.KismetMathLibrary.Quat_Size
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Quat_Size(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_Size");

	Params::KismetMathLibrary_Quat_Size Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_SizeSquared
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Quat_SizeSquared(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_SizeSquared");

	Params::KismetMathLibrary_Quat_SizeSquared Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_UnrotateVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          V                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_UnrotateVector(const struct FQuat& Q, const struct FVector& V)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_UnrotateVector");

	Params::KismetMathLibrary_Quat_UnrotateVector Parms{};

	Parms.Q = std::move(Q);
	Parms.V = std::move(V);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_VectorForward
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_VectorForward(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_VectorForward");

	Params::KismetMathLibrary_Quat_VectorForward Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_VectorRight
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_VectorRight(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_VectorRight");

	Params::KismetMathLibrary_Quat_VectorRight Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_VectorUp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            Q                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Quat_VectorUp(const struct FQuat& Q)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Quat_VectorUp");

	Params::KismetMathLibrary_Quat_VectorUp Parms{};

	Parms.Q = std::move(Q);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.QuaternionSpringInterp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                            Current                                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            Target                                                 (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuaternionSpringState           SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Stiffness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CriticalDampingFactor                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Mass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetVelocityAmount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInitializeFromTarget                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::QuaternionSpringInterp(const struct FQuat& Current, const struct FQuat& Target, struct FQuaternionSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bInitializeFromTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("QuaternionSpringInterp");

	Params::KismetMathLibrary_QuaternionSpringInterp Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.SpringState = std::move(SpringState);
	Parms.Stiffness = Stiffness;
	Parms.CriticalDampingFactor = CriticalDampingFactor;
	Parms.DeltaTime = DeltaTime;
	Parms.Mass = Mass;
	Parms.TargetVelocityAmount = TargetVelocityAmount;
	Parms.bInitializeFromTarget = bInitializeFromTarget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RadiansToDegrees
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RadiansToDegrees(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RadiansToDegrees");

	Params::KismetMathLibrary_RadiansToDegrees Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::RandomBool()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomBool");

	Params::KismetMathLibrary_RandomBool Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomBoolFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::RandomBoolFromStream(const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomBoolFromStream");

	Params::KismetMathLibrary_RandomBoolFromStream Parms{};

	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomBoolWithWeight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::RandomBoolWithWeight(float Weight)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomBoolWithWeight");

	Params::KismetMathLibrary_RandomBoolWithWeight Parms{};

	Parms.Weight = Weight;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomBoolWithWeightFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::RandomBoolWithWeightFromStream(float Weight, const struct FRandomStream& RandomStream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomBoolWithWeightFromStream");

	Params::KismetMathLibrary_RandomBoolWithWeightFromStream Parms{};

	Parms.Weight = Weight;
	Parms.RandomStream = std::move(RandomStream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RandomFloat()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomFloat");

	Params::KismetMathLibrary_RandomFloat Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomFloatFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RandomFloatFromStream(const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomFloatFromStream");

	Params::KismetMathLibrary_RandomFloatFromStream Parms{};

	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomFloatInRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RandomFloatInRange(float Min, float Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomFloatInRange");

	Params::KismetMathLibrary_RandomFloatInRange Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::RandomFloatInRangeFromStream(float Min, float Max, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomFloatInRangeFromStream");

	Params::KismetMathLibrary_RandomFloatInRangeFromStream Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::RandomInteger(int32 Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomInteger");

	Params::KismetMathLibrary_RandomInteger Parms{};

	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomInteger64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::RandomInteger64(int64 Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomInteger64");

	Params::KismetMathLibrary_RandomInteger64 Parms{};

	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomInteger64InRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::RandomInteger64InRange(int64 Min, int64 Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomInteger64InRange");

	Params::KismetMathLibrary_RandomInteger64InRange Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomIntegerFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::RandomIntegerFromStream(int32 Max, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomIntegerFromStream");

	Params::KismetMathLibrary_RandomIntegerFromStream Parms{};

	Parms.Max = Max;
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomIntegerInRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::RandomIntegerInRange(int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomIntegerInRange");

	Params::KismetMathLibrary_RandomIntegerInRange Parms{};

	Parms.Min = Min;
	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::RandomIntegerInRangeFromStream(int32 Min, int32 Max, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomIntegerInRangeFromStream");

	Params::KismetMathLibrary_RandomIntegerInRangeFromStream Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomPointInBoundingBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Center                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HalfSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomPointInBoundingBox(const struct FVector& Center, const struct FVector& HalfSize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomPointInBoundingBox");

	Params::KismetMathLibrary_RandomPointInBoundingBox Parms{};

	Parms.Center = std::move(Center);
	Parms.HalfSize = std::move(HalfSize);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomPointInBoundingBoxFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Center                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HalfSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomPointInBoundingBoxFromStream(const struct FVector& Center, const struct FVector& HalfSize, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomPointInBoundingBoxFromStream");

	Params::KismetMathLibrary_RandomPointInBoundingBoxFromStream Parms{};

	Parms.Center = std::move(Center);
	Parms.HalfSize = std::move(HalfSize);
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bRoll                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RandomRotator(bool bRoll)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomRotator");

	Params::KismetMathLibrary_RandomRotator Parms{};

	Parms.bRoll = bRoll;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomRotatorFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bRoll                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RandomRotatorFromStream(bool bRoll, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomRotatorFromStream");

	Params::KismetMathLibrary_RandomRotatorFromStream Parms{};

	Parms.bRoll = bRoll;
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVector()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVector");

	Params::KismetMathLibrary_RandomUnitVector Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorFromStream(const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorFromStream");

	Params::KismetMathLibrary_RandomUnitVectorFromStream Parms{};

	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ConeDir                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngleInDegrees                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInDegrees(const struct FVector& ConeDir, float ConeHalfAngleInDegrees)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorInConeInDegrees");

	Params::KismetMathLibrary_RandomUnitVectorInConeInDegrees Parms{};

	Parms.ConeDir = std::move(ConeDir);
	Parms.ConeHalfAngleInDegrees = ConeHalfAngleInDegrees;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegreesFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ConeDir                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngleInDegrees                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInDegreesFromStream(const struct FVector& ConeDir, float ConeHalfAngleInDegrees, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorInConeInDegreesFromStream");

	Params::KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream Parms{};

	Parms.ConeDir = std::move(ConeDir);
	Parms.ConeHalfAngleInDegrees = ConeHalfAngleInDegrees;
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ConeDir                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngleInRadians                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInRadians(const struct FVector& ConeDir, float ConeHalfAngleInRadians)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorInConeInRadians");

	Params::KismetMathLibrary_RandomUnitVectorInConeInRadians Parms{};

	Parms.ConeDir = std::move(ConeDir);
	Parms.ConeHalfAngleInRadians = ConeHalfAngleInRadians;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadiansFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ConeDir                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngleInRadians                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInConeInRadiansFromStream(const struct FVector& ConeDir, float ConeHalfAngleInRadians, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorInConeInRadiansFromStream");

	Params::KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream Parms{};

	Parms.ConeDir = std::move(ConeDir);
	Parms.ConeHalfAngleInRadians = ConeHalfAngleInRadians;
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ConeDir                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxYawInDegrees                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPitchInDegrees                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInDegrees(const struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorInEllipticalConeInDegrees");

	Params::KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees Parms{};

	Parms.ConeDir = std::move(ConeDir);
	Parms.MaxYawInDegrees = MaxYawInDegrees;
	Parms.MaxPitchInDegrees = MaxPitchInDegrees;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegreesFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ConeDir                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxYawInDegrees                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPitchInDegrees                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInDegreesFromStream(const struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorInEllipticalConeInDegreesFromStream");

	Params::KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream Parms{};

	Parms.ConeDir = std::move(ConeDir);
	Parms.MaxYawInDegrees = MaxYawInDegrees;
	Parms.MaxPitchInDegrees = MaxPitchInDegrees;
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ConeDir                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxYawInRadians                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPitchInRadians                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInRadians(const struct FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorInEllipticalConeInRadians");

	Params::KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians Parms{};

	Parms.ConeDir = std::move(ConeDir);
	Parms.MaxYawInRadians = MaxYawInRadians;
	Parms.MaxPitchInRadians = MaxPitchInRadians;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadiansFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ConeDir                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxYawInRadians                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPitchInRadians                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RandomUnitVectorInEllipticalConeInRadiansFromStream(const struct FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomUnitVectorInEllipticalConeInRadiansFromStream");

	Params::KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream Parms{};

	Parms.ConeDir = std::move(ConeDir);
	Parms.MaxYawInRadians = MaxYawInRadians;
	Parms.MaxPitchInRadians = MaxPitchInRadians;
	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.REase
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShortestPath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Steps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::REase(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath, EEasingFunc EasingFunc, float BlendExp, int32 Steps)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("REase");

	Params::KismetMathLibrary_REase Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;
	Parms.bShortestPath = bShortestPath;
	Parms.EasingFunc = EasingFunc;
	Parms.BlendExp = BlendExp;
	Parms.Steps = Steps;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ResetFloatSpringState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFloatSpringState                SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ResetFloatSpringState(struct FFloatSpringState& SpringState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ResetFloatSpringState");

	Params::KismetMathLibrary_ResetFloatSpringState Parms{};

	Parms.SpringState = std::move(SpringState);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);
}


// Function Engine.KismetMathLibrary.ResetQuaternionSpringState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FQuaternionSpringState           SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ResetQuaternionSpringState(struct FQuaternionSpringState& SpringState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ResetQuaternionSpringState");

	Params::KismetMathLibrary_ResetQuaternionSpringState Parms{};

	Parms.SpringState = std::move(SpringState);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);
}


// Function Engine.KismetMathLibrary.ResetRandomStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ResetRandomStream(const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ResetRandomStream");

	Params::KismetMathLibrary_ResetRandomStream Parms{};

	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetMathLibrary.ResetVectorSpringState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVectorSpringState               SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ResetVectorSpringState(struct FVectorSpringState& SpringState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ResetVectorSpringState");

	Params::KismetMathLibrary_ResetVectorSpringState Parms{};

	Parms.SpringState = std::move(SpringState);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);
}


// Function Engine.KismetMathLibrary.RGBLinearToHSV
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     RGB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::RGBLinearToHSV(const struct FLinearColor& RGB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RGBLinearToHSV");

	Params::KismetMathLibrary_RGBLinearToHSV Parms{};

	Parms.RGB = std::move(RGB);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RGBToHSV
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   H                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   S                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   V                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   A                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::RGBToHSV(const struct FLinearColor& InColor, float* H, float* S, float* V, float* A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RGBToHSV");

	Params::KismetMathLibrary_RGBToHSV Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (H != nullptr)
		*H = Parms.H;

	if (S != nullptr)
		*S = Parms.S;

	if (V != nullptr)
		*V = Parms.V;

	if (A != nullptr)
		*A = Parms.A;
}


// Function Engine.KismetMathLibrary.RGBToHSV_Vector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     RGB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     HSV                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::RGBToHSV_Vector(const struct FLinearColor& RGB, struct FLinearColor* HSV)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RGBToHSV_Vector");

	Params::KismetMathLibrary_RGBToHSV_Vector Parms{};

	Parms.RGB = std::move(RGB);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (HSV != nullptr)
		*HSV = std::move(Parms.HSV);
}


// Function Engine.KismetMathLibrary.RInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RInterpTo");

	Params::KismetMathLibrary_RInterpTo Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RInterpTo_Constant(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RInterpTo_Constant");

	Params::KismetMathLibrary_RInterpTo_Constant Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShortestPath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RLerp(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RLerp");

	Params::KismetMathLibrary_RLerp Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;
	Parms.bShortestPath = bShortestPath;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RotateAngleAxis
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleDeg                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::RotateAngleAxis(const struct FVector& InVect, float AngleDeg, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RotateAngleAxis");

	Params::KismetMathLibrary_RotateAngleAxis Parms{};

	Parms.InVect = std::move(InVect);
	Parms.AngleDeg = AngleDeg;
	Parms.Axis = std::move(Axis);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::RotatorFromAxisAndAngle(const struct FVector& Axis, float Angle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RotatorFromAxisAndAngle");

	Params::KismetMathLibrary_RotatorFromAxisAndAngle Parms{};

	Parms.Axis = std::move(Axis);
	Parms.Angle = Angle;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Round
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Round(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Round");

	Params::KismetMathLibrary_Round Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Round64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Round64(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Round64");

	Params::KismetMathLibrary_Round64 Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SafeDivide
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::SafeDivide(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SafeDivide");

	Params::KismetMathLibrary_SafeDivide Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SeedRandomStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream                    Stream                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetMathLibrary::SeedRandomStream(struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SeedRandomStream");

	Params::KismetMathLibrary_SeedRandomStream Parms{};

	Parms.Stream = std::move(Stream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Stream = std::move(Parms.Stream);
}


// Function Engine.KismetMathLibrary.SelectClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSelectA                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UKismetMathLibrary::SelectClass(class UClass* A, class UClass* B, bool bSelectA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectClass");

	Params::KismetMathLibrary_SelectClass Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bSelectA = bSelectA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPickA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::SelectColor(const struct FLinearColor& A, const struct FLinearColor& B, bool bPickA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectColor");

	Params::KismetMathLibrary_SelectColor Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.bPickA = bPickA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPickA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::SelectFloat(float A, float B, bool bPickA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectFloat");

	Params::KismetMathLibrary_SelectFloat Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPickA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::SelectInt(int32 A, int32 B, bool bPickA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectInt");

	Params::KismetMathLibrary_SelectInt Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bPickA = bPickA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSelectA                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetMathLibrary::SelectObject(class UObject* A, class UObject* B, bool bSelectA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectObject");

	Params::KismetMathLibrary_SelectObject Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.bSelectA = bSelectA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPickA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::SelectRotator(const struct FRotator& A, const struct FRotator& B, bool bPickA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectRotator");

	Params::KismetMathLibrary_SelectRotator Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.bPickA = bPickA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPickA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetMathLibrary::SelectString(const class FString& A, const class FString& B, bool bPickA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectString");

	Params::KismetMathLibrary_SelectString Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.bPickA = bPickA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPickA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::SelectTransform(const struct FTransform& A, const struct FTransform& B, bool bPickA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectTransform");

	Params::KismetMathLibrary_SelectTransform Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.bPickA = bPickA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPickA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::SelectVector(const struct FVector& A, const struct FVector& B, bool bPickA)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SelectVector");

	Params::KismetMathLibrary_SelectVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.bPickA = bPickA;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Set2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Set2D(struct FVector2D& A, float X, float Y)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Set2D");

	Params::KismetMathLibrary_Set2D Parms{};

	Parms.A = std::move(A);
	Parms.X = X;
	Parms.Y = Y;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.SetFloatSpringStateVelocity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFloatSpringState                SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::SetFloatSpringStateVelocity(struct FFloatSpringState& SpringState, float Velocity)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetFloatSpringStateVelocity");

	Params::KismetMathLibrary_SetFloatSpringStateVelocity Parms{};

	Parms.SpringState = std::move(SpringState);
	Parms.Velocity = Velocity;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);
}


// Function Engine.KismetMathLibrary.SetQuaternionSpringStateAngularVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuaternionSpringState           SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          AngularVelocity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::SetQuaternionSpringStateAngularVelocity(struct FQuaternionSpringState& SpringState, const struct FVector& AngularVelocity)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetQuaternionSpringStateAngularVelocity");

	Params::KismetMathLibrary_SetQuaternionSpringStateAngularVelocity Parms{};

	Parms.SpringState = std::move(SpringState);
	Parms.AngularVelocity = std::move(AngularVelocity);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);
}


// Function Engine.KismetMathLibrary.SetRandomStreamSeed
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream                    Stream                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   NewSeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::SetRandomStreamSeed(struct FRandomStream& Stream, int32 NewSeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetRandomStreamSeed");

	Params::KismetMathLibrary_SetRandomStreamSeed Parms{};

	Parms.Stream = std::move(Stream);
	Parms.NewSeed = NewSeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Stream = std::move(Parms.Stream);
}


// Function Engine.KismetMathLibrary.SetVectorSpringStateVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVectorSpringState               SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::SetVectorSpringStateVelocity(struct FVectorSpringState& SpringState, const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetVectorSpringStateVelocity");

	Params::KismetMathLibrary_SetVectorSpringStateVelocity Parms{};

	Parms.SpringState = std::move(SpringState);
	Parms.Velocity = std::move(Velocity);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);
}


// Function Engine.KismetMathLibrary.SignOfFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::SignOfFloat(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SignOfFloat");

	Params::KismetMathLibrary_SignOfFloat Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SignOfInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::SignOfInteger(int32 A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SignOfInteger");

	Params::KismetMathLibrary_SignOfInteger Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.SignOfInteger64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::SignOfInteger64(int64 A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SignOfInteger64");

	Params::KismetMathLibrary_SignOfInteger64 Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Sin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Sin(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Sin");

	Params::KismetMathLibrary_Sin Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Spherical2DToUnitCartesian
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Spherical2DToUnitCartesian(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Spherical2DToUnitCartesian");

	Params::KismetMathLibrary_Spherical2DToUnitCartesian Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Sqrt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Sqrt(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Sqrt");

	Params::KismetMathLibrary_Sqrt Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Square
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Square(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Square");

	Params::KismetMathLibrary_Square Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetMathLibrary::Subtract_ByteByte(uint8 A, uint8 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_ByteByte");

	Params::KismetMathLibrary_Subtract_ByteByte Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Subtract_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_DateTimeDateTime");

	Params::KismetMathLibrary_Subtract_DateTimeDateTime Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Subtract_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_DateTimeTimespan");

	Params::KismetMathLibrary_Subtract_DateTimeTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_DoubleDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetMathLibrary::Subtract_DoubleDouble(double A, double B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_DoubleDouble");

	Params::KismetMathLibrary_Subtract_DoubleDouble Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Subtract_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_FloatFloat");

	Params::KismetMathLibrary_Subtract_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Subtract_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_Int64Int64");

	Params::KismetMathLibrary_Subtract_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Subtract_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_IntInt");

	Params::KismetMathLibrary_Subtract_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_IntPointInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Subtract_IntPointInt(const struct FIntPoint& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_IntPointInt");

	Params::KismetMathLibrary_Subtract_IntPointInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_IntPointIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UKismetMathLibrary::Subtract_IntPointIntPoint(const struct FIntPoint& A, const struct FIntPoint& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_IntPointIntPoint");

	Params::KismetMathLibrary_Subtract_IntPointIntPoint Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UKismetMathLibrary::Subtract_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_LinearColorLinearColor");

	Params::KismetMathLibrary_Subtract_LinearColorLinearColor Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_QuatQuat
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                            A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FQuat UKismetMathLibrary::Subtract_QuatQuat(const struct FQuat& A, const struct FQuat& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_QuatQuat");

	Params::KismetMathLibrary_Subtract_QuatQuat Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::Subtract_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_TimespanTimespan");

	Params::KismetMathLibrary_Subtract_TimespanTimespan Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Subtract_Vector2DFloat(const struct FVector2D& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_Vector2DFloat");

	Params::KismetMathLibrary_Subtract_Vector2DFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Subtract_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_Vector2DVector2D");

	Params::KismetMathLibrary_Subtract_Vector2DVector2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_Vector4Vector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Subtract_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_Vector4Vector4");

	Params::KismetMathLibrary_Subtract_Vector4Vector4 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Subtract_VectorFloat(const struct FVector& A, float B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_VectorFloat");

	Params::KismetMathLibrary_Subtract_VectorFloat Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Subtract_VectorInt(const struct FVector& A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_VectorInt");

	Params::KismetMathLibrary_Subtract_VectorInt Parms{};

	Parms.A = std::move(A);
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Subtract_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Subtract_VectorVector");

	Params::KismetMathLibrary_Subtract_VectorVector Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Tan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Tan(float A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Tan");

	Params::KismetMathLibrary_Tan Parms{};

	Parms.A = A;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TEase
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Steps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::TEase(const struct FTransform& A, const struct FTransform& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TEase");

	Params::KismetMathLibrary_TEase Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;
	Parms.EasingFunc = EasingFunc;
	Parms.BlendExp = BlendExp;
	Parms.Steps = Steps;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanFromString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           TimespanString                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        Result                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::TimespanFromString(const class FString& TimespanString, struct FTimespan* Result)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TimespanFromString");

	Params::KismetMathLibrary_TimespanFromString Parms{};

	Parms.TimespanString = std::move(TimespanString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanMaxValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::TimespanMaxValue()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TimespanMaxValue");

	Params::KismetMathLibrary_TimespanMaxValue Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanMinValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::TimespanMinValue()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TimespanMinValue");

	Params::KismetMathLibrary_TimespanMinValue Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanRatio
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::TimespanRatio(const struct FTimespan& A, const struct FTimespan& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TimespanRatio");

	Params::KismetMathLibrary_TimespanRatio Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanZeroValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UKismetMathLibrary::TimespanZeroValue()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TimespanZeroValue");

	Params::KismetMathLibrary_TimespanZeroValue Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TInterpTo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       Current                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::TInterpTo(const struct FTransform& Current, const struct FTransform& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TInterpTo");

	Params::KismetMathLibrary_TInterpTo Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TLerp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       B                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELerpInterpolationMode                  InterpMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKismetMathLibrary::TLerp(const struct FTransform& A, const struct FTransform& B, float Alpha, ELerpInterpolationMode InterpMode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TLerp");

	Params::KismetMathLibrary_TLerp Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;
	Parms.InterpMode = InterpMode;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Today
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::Today()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Today");

	Params::KismetMathLibrary_Today Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ToDirectionAndLength2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutDir                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutLength                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::ToDirectionAndLength2D(const struct FVector2D& A, struct FVector2D* OutDir, float* OutLength)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ToDirectionAndLength2D");

	Params::KismetMathLibrary_ToDirectionAndLength2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutDir != nullptr)
		*OutDir = std::move(Parms.OutDir);

	if (OutLength != nullptr)
		*OutLength = Parms.OutLength;
}


// Function Engine.KismetMathLibrary.ToRounded2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::ToRounded2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ToRounded2D");

	Params::KismetMathLibrary_ToRounded2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.ToSign2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::ToSign2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ToSign2D");

	Params::KismetMathLibrary_ToSign2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Transform_Determinant
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Transform_Determinant(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Transform_Determinant");

	Params::KismetMathLibrary_Transform_Determinant Parms{};

	Parms.Transform = std::move(Transform);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TransformDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::TransformDirection(const struct FTransform& T, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformDirection");

	Params::KismetMathLibrary_TransformDirection Parms{};

	Parms.T = std::move(T);
	Parms.Direction = std::move(Direction);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TransformLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::TransformLocation(const struct FTransform& T, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformLocation");

	Params::KismetMathLibrary_TransformLocation Parms{};

	Parms.T = std::move(T);
	Parms.Location = std::move(Location);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TransformRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       T                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::TransformRotation(const struct FTransform& T, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformRotation");

	Params::KismetMathLibrary_TransformRotation Parms{};

	Parms.T = std::move(T);
	Parms.Rotation = std::move(Rotation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.TransformVector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          Matrix                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector4                         Vec4                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::TransformVector4(const struct FMatrix& Matrix, const struct FVector4& Vec4)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransformVector4");

	Params::KismetMathLibrary_TransformVector4 Parms{};

	Parms.Matrix = std::move(Matrix);
	Parms.Vec4 = std::move(Vec4);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.UtcNow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKismetMathLibrary::UtcNow()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UtcNow");

	Params::KismetMathLibrary_UtcNow Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VEase
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunc                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Steps                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VEase(const struct FVector& A, const struct FVector& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32 Steps)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VEase");

	Params::KismetMathLibrary_VEase Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;
	Parms.EasingFunc = EasingFunc;
	Parms.BlendExp = BlendExp;
	Parms.Steps = Steps;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2D_One
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2D_One()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector2D_One");

	Params::KismetMathLibrary_Vector2D_One Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2D_Unit45Deg
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2D_Unit45Deg()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector2D_Unit45Deg");

	Params::KismetMathLibrary_Vector2D_Unit45Deg Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2D_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2D_Zero()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector2D_Zero");

	Params::KismetMathLibrary_Vector2D_Zero Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2DInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2DInterpTo(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector2DInterpTo");

	Params::KismetMathLibrary_Vector2DInterpTo Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector2DInterpTo_Constant(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector2DInterpTo_Constant");

	Params::KismetMathLibrary_Vector2DInterpTo_Constant Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Assign
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                         A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         InVector                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector4_Assign(struct FVector4& A, const struct FVector4& InVector)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_Assign");

	Params::KismetMathLibrary_Vector4_Assign Parms{};

	Parms.A = std::move(A);
	Parms.InVector = std::move(InVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Vector4_CrossProduct3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_CrossProduct3(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_CrossProduct3");

	Params::KismetMathLibrary_Vector4_CrossProduct3 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_DotProduct
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_DotProduct(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_DotProduct");

	Params::KismetMathLibrary_Vector4_DotProduct Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_DotProduct3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_DotProduct3(const struct FVector4& A, const struct FVector4& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_DotProduct3");

	Params::KismetMathLibrary_Vector4_DotProduct3 Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsNAN
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsNAN(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_IsNAN");

	Params::KismetMathLibrary_Vector4_IsNAN Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsNearlyZero3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsNearlyZero3(const struct FVector4& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_IsNearlyZero3");

	Params::KismetMathLibrary_Vector4_IsNearlyZero3 Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsNormal3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsNormal3(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_IsNormal3");

	Params::KismetMathLibrary_Vector4_IsNormal3 Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsUnit3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SquaredLenthTolerance                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsUnit3(const struct FVector4& A, float SquaredLenthTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_IsUnit3");

	Params::KismetMathLibrary_Vector4_IsUnit3 Parms{};

	Parms.A = std::move(A);
	Parms.SquaredLenthTolerance = SquaredLenthTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsZero
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector4_IsZero(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_IsZero");

	Params::KismetMathLibrary_Vector4_IsZero Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_MirrorByVector3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         SurfaceNormal                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_MirrorByVector3(const struct FVector4& Direction, const struct FVector4& SurfaceNormal)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_MirrorByVector3");

	Params::KismetMathLibrary_Vector4_MirrorByVector3 Parms{};

	Parms.Direction = std::move(Direction);
	Parms.SurfaceNormal = std::move(SurfaceNormal);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Negated
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_Negated(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_Negated");

	Params::KismetMathLibrary_Vector4_Negated Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Normal3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_Normal3(const struct FVector4& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_Normal3");

	Params::KismetMathLibrary_Vector4_Normal3 Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Normalize3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                         A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector4_Normalize3(struct FVector4& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_Normalize3");

	Params::KismetMathLibrary_Vector4_Normalize3 Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Vector4_NormalUnsafe3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_NormalUnsafe3(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_NormalUnsafe3");

	Params::KismetMathLibrary_Vector4_NormalUnsafe3 Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Set
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                         A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   W                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector4_Set(struct FVector4& A, float X, float Y, float Z, float W)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_Set");

	Params::KismetMathLibrary_Vector4_Set Parms{};

	Parms.A = std::move(A);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.W = W;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Vector4_Size
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_Size(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_Size");

	Params::KismetMathLibrary_Vector4_Size Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Size3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_Size3(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_Size3");

	Params::KismetMathLibrary_Vector4_Size3 Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_SizeSquared
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_SizeSquared(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_SizeSquared");

	Params::KismetMathLibrary_Vector4_SizeSquared Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_SizeSquared3
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector4_SizeSquared3(const struct FVector4& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_SizeSquared3");

	Params::KismetMathLibrary_Vector4_SizeSquared3 Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UKismetMathLibrary::Vector4_Zero()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector4_Zero");

	Params::KismetMathLibrary_Vector4_Zero Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_AddBounded
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InAddVect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_AddBounded(struct FVector& A, const struct FVector& InAddVect, float InRadius)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_AddBounded");

	Params::KismetMathLibrary_Vector_AddBounded Parms{};

	Parms.A = std::move(A);
	Parms.InAddVect = std::move(InAddVect);
	Parms.InRadius = InRadius;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Vector_Assign
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InVector                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_Assign(struct FVector& A, const struct FVector& InVector)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Assign");

	Params::KismetMathLibrary_Vector_Assign Parms{};

	Parms.A = std::move(A);
	Parms.InVector = std::move(InVector);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Vector_Backward
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Backward()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Backward");

	Params::KismetMathLibrary_Vector_Backward Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_BoundedToBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InBoxMin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InBoxMax                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_BoundedToBox(const struct FVector& InVect, const struct FVector& InBoxMin, const struct FVector& InBoxMax)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_BoundedToBox");

	Params::KismetMathLibrary_Vector_BoundedToBox Parms{};

	Parms.InVect = std::move(InVect);
	Parms.InBoxMin = std::move(InBoxMin);
	Parms.InBoxMax = std::move(InBoxMax);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_BoundedToCube
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_BoundedToCube(const struct FVector& InVect, float InRadius)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_BoundedToCube");

	Params::KismetMathLibrary_Vector_BoundedToCube Parms{};

	Parms.InVect = std::move(InVect);
	Parms.InRadius = InRadius;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ClampSize2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ClampSize2D(const struct FVector& A, float Min, float Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_ClampSize2D");

	Params::KismetMathLibrary_Vector_ClampSize2D Parms{};

	Parms.A = std::move(A);
	Parms.Min = Min;
	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ClampSizeMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ClampSizeMax(const struct FVector& A, float Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_ClampSizeMax");

	Params::KismetMathLibrary_Vector_ClampSizeMax Parms{};

	Parms.A = std::move(A);
	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ClampSizeMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ClampSizeMax2D(const struct FVector& A, float Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_ClampSizeMax2D");

	Params::KismetMathLibrary_Vector_ClampSizeMax2D Parms{};

	Parms.A = std::move(A);
	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ComponentMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ComponentMax(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_ComponentMax");

	Params::KismetMathLibrary_Vector_ComponentMax Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ComponentMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ComponentMin(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_ComponentMin");

	Params::KismetMathLibrary_Vector_ComponentMin Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_CosineAngle2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_CosineAngle2D(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_CosineAngle2D");

	Params::KismetMathLibrary_Vector_CosineAngle2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Distance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          v1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          v2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_Distance(const struct FVector& v1, const struct FVector& v2)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Distance");

	Params::KismetMathLibrary_Vector_Distance Parms{};

	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Distance2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          v1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          v2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_Distance2D(const struct FVector& v1, const struct FVector& v2)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Distance2D");

	Params::KismetMathLibrary_Vector_Distance2D Parms{};

	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Distance2DSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          v1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          v2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_Distance2DSquared(const struct FVector& v1, const struct FVector& v2)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Distance2DSquared");

	Params::KismetMathLibrary_Vector_Distance2DSquared Parms{};

	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_DistanceSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          v1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          v2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_DistanceSquared(const struct FVector& v1, const struct FVector& v2)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_DistanceSquared");

	Params::KismetMathLibrary_Vector_DistanceSquared Parms{};

	Parms.v1 = std::move(v1);
	Parms.v2 = std::move(v2);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Down
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Down()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Down");

	Params::KismetMathLibrary_Vector_Down Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Forward
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Forward()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Forward");

	Params::KismetMathLibrary_Vector_Forward Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetAbs
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_GetAbs(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_GetAbs");

	Params::KismetMathLibrary_Vector_GetAbs Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetAbsMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_GetAbsMax(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_GetAbsMax");

	Params::KismetMathLibrary_Vector_GetAbsMax Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetAbsMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_GetAbsMin(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_GetAbsMin");

	Params::KismetMathLibrary_Vector_GetAbsMin Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetProjection
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_GetProjection(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_GetProjection");

	Params::KismetMathLibrary_Vector_GetProjection Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetSignVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_GetSignVector(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_GetSignVector");

	Params::KismetMathLibrary_Vector_GetSignVector Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_HeadingAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::Vector_HeadingAngle(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_HeadingAngle");

	Params::KismetMathLibrary_Vector_HeadingAngle Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsNAN
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsNAN(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_IsNAN");

	Params::KismetMathLibrary_Vector_IsNAN Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsNearlyZero
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsNearlyZero(const struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_IsNearlyZero");

	Params::KismetMathLibrary_Vector_IsNearlyZero Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsNormal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsNormal(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_IsNormal");

	Params::KismetMathLibrary_Vector_IsNormal Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsUniform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsUniform(const struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_IsUniform");

	Params::KismetMathLibrary_Vector_IsUniform Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsUnit
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SquaredLenthTolerance                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsUnit(const struct FVector& A, float SquaredLenthTolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_IsUnit");

	Params::KismetMathLibrary_Vector_IsUnit Parms{};

	Parms.A = std::move(A);
	Parms.SquaredLenthTolerance = SquaredLenthTolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsZero
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetMathLibrary::Vector_IsZero(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_IsZero");

	Params::KismetMathLibrary_Vector_IsZero Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Left
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Left()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Left");

	Params::KismetMathLibrary_Vector_Left Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_MirrorByPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                           InPlane                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_MirrorByPlane(const struct FVector& A, const struct FPlane& InPlane)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_MirrorByPlane");

	Params::KismetMathLibrary_Vector_MirrorByPlane Parms{};

	Parms.A = std::move(A);
	Parms.InPlane = std::move(InPlane);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Normal2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Normal2D(const struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Normal2D");

	Params::KismetMathLibrary_Vector_Normal2D Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Normalize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_Normalize(struct FVector& A, float Tolerance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Normalize");

	Params::KismetMathLibrary_Vector_Normalize Parms{};

	Parms.A = std::move(A);
	Parms.Tolerance = Tolerance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Vector_NormalUnsafe
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_NormalUnsafe(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_NormalUnsafe");

	Params::KismetMathLibrary_Vector_NormalUnsafe Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_One
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_One()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_One");

	Params::KismetMathLibrary_Vector_One Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ProjectOnToNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          V                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InNormal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ProjectOnToNormal(const struct FVector& V, const struct FVector& InNormal)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_ProjectOnToNormal");

	Params::KismetMathLibrary_Vector_ProjectOnToNormal Parms{};

	Parms.V = std::move(V);
	Parms.InNormal = std::move(InNormal);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Reciprocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Reciprocal(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Reciprocal");

	Params::KismetMathLibrary_Vector_Reciprocal Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Right
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Right()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Right");

	Params::KismetMathLibrary_Vector_Right Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Set
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_Set(struct FVector& A, float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Set");

	Params::KismetMathLibrary_Vector_Set Parms{};

	Parms.A = std::move(A);
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Vector_SnappedToGrid
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InGridSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_SnappedToGrid(const struct FVector& InVect, float InGridSize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_SnappedToGrid");

	Params::KismetMathLibrary_Vector_SnappedToGrid Parms{};

	Parms.InVect = std::move(InVect);
	Parms.InGridSize = InGridSize;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ToDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ToDegrees(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_ToDegrees");

	Params::KismetMathLibrary_Vector_ToDegrees Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ToRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_ToRadians(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_ToRadians");

	Params::KismetMathLibrary_Vector_ToRadians Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_UnitCartesianToSpherical
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetMathLibrary::Vector_UnitCartesianToSpherical(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_UnitCartesianToSpherical");

	Params::KismetMathLibrary_Vector_UnitCartesianToSpherical Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_UnwindEuler
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          A                                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetMathLibrary::Vector_UnwindEuler(struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_UnwindEuler");

	Params::KismetMathLibrary_Vector_UnwindEuler Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	A = std::move(Parms.A);
}


// Function Engine.KismetMathLibrary.Vector_Up
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Up()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Up");

	Params::KismetMathLibrary_Vector_Up Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::Vector_Zero()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Vector_Zero");

	Params::KismetMathLibrary_Vector_Zero Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VectorSpringInterp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVectorSpringState               SpringState                                            (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Stiffness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CriticalDampingFactor                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Mass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetVelocityAmount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bClamp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MinValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          MaxValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInitializeFromTarget                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VectorSpringInterp(const struct FVector& Current, const struct FVector& Target, struct FVectorSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bClamp, const struct FVector& MinValue, const struct FVector& MaxValue, bool bInitializeFromTarget)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VectorSpringInterp");

	Params::KismetMathLibrary_VectorSpringInterp Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.SpringState = std::move(SpringState);
	Parms.Stiffness = Stiffness;
	Parms.CriticalDampingFactor = CriticalDampingFactor;
	Parms.DeltaTime = DeltaTime;
	Parms.Mass = Mass;
	Parms.TargetVelocityAmount = TargetVelocityAmount;
	Parms.bClamp = bClamp;
	Parms.MinValue = std::move(MinValue);
	Parms.MaxValue = std::move(MaxValue);
	Parms.bInitializeFromTarget = bInitializeFromTarget;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SpringState = std::move(Parms.SpringState);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VInterpTo(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VInterpTo");

	Params::KismetMathLibrary_VInterpTo Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VInterpTo_Constant(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VInterpTo_Constant");

	Params::KismetMathLibrary_VInterpTo_Constant Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::VLerp(const struct FVector& A, const struct FVector& B, float Alpha)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VLerp");

	Params::KismetMathLibrary_VLerp Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSize(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VSize");

	Params::KismetMathLibrary_VSize Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSize2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSize2D(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VSize2D");

	Params::KismetMathLibrary_VSize2D Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSize2DSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSize2DSquared(const struct FVector2D& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VSize2DSquared");

	Params::KismetMathLibrary_VSize2DSquared Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSizeSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSizeSquared(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VSizeSquared");

	Params::KismetMathLibrary_VSizeSquared Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSizeXY
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSizeXY(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VSizeXY");

	Params::KismetMathLibrary_VSizeXY Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSizeXYSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::VSizeXYSquared(const struct FVector& A)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("VSizeXYSquared");

	Params::KismetMathLibrary_VSizeXYSquared Parms{};

	Parms.A = std::move(A);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.WeightedMovingAverage_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   CurrentSample                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreviousSample                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetMathLibrary::WeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float Weight)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("WeightedMovingAverage_Float");

	Params::KismetMathLibrary_WeightedMovingAverage_Float Parms{};

	Parms.CurrentSample = CurrentSample;
	Parms.PreviousSample = PreviousSample;
	Parms.Weight = Weight;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.WeightedMovingAverage_FRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         CurrentSample                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         PreviousSample                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKismetMathLibrary::WeightedMovingAverage_FRotator(const struct FRotator& CurrentSample, const struct FRotator& PreviousSample, float Weight)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("WeightedMovingAverage_FRotator");

	Params::KismetMathLibrary_WeightedMovingAverage_FRotator Parms{};

	Parms.CurrentSample = std::move(CurrentSample);
	Parms.PreviousSample = std::move(PreviousSample);
	Parms.Weight = Weight;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.WeightedMovingAverage_FVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          CurrentSample                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PreviousSample                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKismetMathLibrary::WeightedMovingAverage_FVector(const struct FVector& CurrentSample, const struct FVector& PreviousSample, float Weight)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("WeightedMovingAverage_FVector");

	Params::KismetMathLibrary_WeightedMovingAverage_FVector Parms{};

	Parms.CurrentSample = std::move(CurrentSample);
	Parms.PreviousSample = std::move(PreviousSample);
	Parms.Weight = Weight;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.wrap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::wrap(int32 Value, int32 Min, int32 Max)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("wrap");

	Params::KismetMathLibrary_wrap Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Xor_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetMathLibrary::Xor_Int64Int64(int64 A, int64 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Xor_Int64Int64");

	Params::KismetMathLibrary_Xor_Int64Int64 Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetMathLibrary.Xor_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetMathLibrary::Xor_IntInt(int32 A, int32 B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Xor_IntInt");

	Params::KismetMathLibrary_Xor_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetKeysFromStringTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetStringTableLibrary::GetKeysFromStringTable(const class FName TableId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetKeysFromStringTable");

	Params::KismetStringTableLibrary_GetKeysFromStringTable Parms{};

	Parms.TableId = TableId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetMetaDataIdsFromStringTableEntry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UKismetStringTableLibrary::GetMetaDataIdsFromStringTableEntry(const class FName TableId, const class FString& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMetaDataIdsFromStringTableEntry");

	Params::KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry Parms{};

	Parms.TableId = TableId;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetRegisteredStringTables
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UKismetStringTableLibrary::GetRegisteredStringTables()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRegisteredStringTables");

	Params::KismetStringTableLibrary_GetRegisteredStringTables Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetTableEntryMetaData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MetaDataId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringTableLibrary::GetTableEntryMetaData(const class FName TableId, const class FString& Key, const class FName MetaDataId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTableEntryMetaData");

	Params::KismetStringTableLibrary_GetTableEntryMetaData Parms{};

	Parms.TableId = TableId;
	Parms.Key = std::move(Key);
	Parms.MetaDataId = MetaDataId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetTableEntrySourceString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringTableLibrary::GetTableEntrySourceString(const class FName TableId, const class FString& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTableEntrySourceString");

	Params::KismetStringTableLibrary_GetTableEntrySourceString Parms{};

	Parms.TableId = TableId;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetTableNamespace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringTableLibrary::GetTableNamespace(const class FName TableId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTableNamespace");

	Params::KismetStringTableLibrary_GetTableNamespace Parms{};

	Parms.TableId = TableId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.IsRegisteredTableEntry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringTableLibrary::IsRegisteredTableEntry(const class FName TableId, const class FString& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsRegisteredTableEntry");

	Params::KismetStringTableLibrary_IsRegisteredTableEntry Parms{};

	Parms.TableId = TableId;
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.IsRegisteredTableId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TableId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringTableLibrary::IsRegisteredTableId(const class FName TableId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsRegisteredTableId");

	Params::KismetStringTableLibrary_IsRegisteredTableId Parms{};

	Parms.TableId = TableId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ExponentialHeightFog.OnRep_bEnabled
// (Native, Public)

void AExponentialHeightFog::OnRep_bEnabled()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_bEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetDirectionalInscatteringColor(const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDirectionalInscatteringColor");

	Params::ExponentialHeightFogComponent_SetDirectionalInscatteringColor Parms{};

	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetDirectionalInscatteringExponent(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDirectionalInscatteringExponent");

	Params::ExponentialHeightFogComponent_SetDirectionalInscatteringExponent Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetDirectionalInscatteringStartDistance(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDirectionalInscatteringStartDistance");

	Params::ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetFogCutoffDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogCutoffDistance(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFogCutoffDistance");

	Params::ExponentialHeightFogComponent_SetFogCutoffDistance Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetFogDensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogDensity(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFogDensity");

	Params::ExponentialHeightFogComponent_SetFogDensity Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogHeightFalloff(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFogHeightFalloff");

	Params::ExponentialHeightFogComponent_SetFogHeightFalloff Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogInscatteringColor(const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFogInscatteringColor");

	Params::ExponentialHeightFogComponent_SetFogInscatteringColor Parms{};

	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFogMaxOpacity(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFogMaxOpacity");

	Params::ExponentialHeightFogComponent_SetFogMaxOpacity Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetFullyDirectionalInscatteringColorDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetFullyDirectionalInscatteringColorDistance(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFullyDirectionalInscatteringColorDistance");

	Params::ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureCube*                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetInscatteringColorCubemap(class UTextureCube* Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInscatteringColorCubemap");

	Params::ExponentialHeightFogComponent_SetInscatteringColorCubemap Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemapAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetInscatteringColorCubemapAngle(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInscatteringColorCubemapAngle");

	Params::ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringTextureTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetInscatteringTextureTint(const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInscatteringTextureTint");

	Params::ExponentialHeightFogComponent_SetInscatteringTextureTint Parms{};

	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetNonDirectionalInscatteringColorDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetNonDirectionalInscatteringColorDistance(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNonDirectionalInscatteringColorDistance");

	Params::ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetStartDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetStartDistance(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStartDistance");

	Params::ExponentialHeightFogComponent_SetStartDistance Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFog(bool bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumetricFog");

	Params::ExponentialHeightFogComponent_SetVolumetricFog Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogAlbedo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                           NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogAlbedo(const struct FColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumetricFogAlbedo");

	Params::ExponentialHeightFogComponent_SetVolumetricFogAlbedo Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogDistance(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumetricFogDistance");

	Params::ExponentialHeightFogComponent_SetVolumetricFogDistance Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogEmissive
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogEmissive(const struct FLinearColor& NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumetricFogEmissive");

	Params::ExponentialHeightFogComponent_SetVolumetricFogEmissive Parms{};

	Parms.NewValue = std::move(NewValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogExtinctionScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogExtinctionScale(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumetricFogExtinctionScale");

	Params::ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogScatteringDistribution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExponentialHeightFogComponent::SetVolumetricFogScatteringDistribution(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumetricFogScatteringDistribution");

	Params::ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TypedElementWorldInterface.CanDeleteElement
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::CanDeleteElement(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanDeleteElement");

	Params::TypedElementWorldInterface_CanDeleteElement Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.CanDuplicateElement
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::CanDuplicateElement(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanDuplicateElement");

	Params::TypedElementWorldInterface_CanDuplicateElement Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.CanEditElement
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::CanEditElement(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanEditElement");

	Params::TypedElementWorldInterface_CanEditElement Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.CanMoveElement
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETypedElementWorldType                  InWorldType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::CanMoveElement(const struct FTypedElementHandle& InElementHandle, const ETypedElementWorldType InWorldType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanMoveElement");

	Params::TypedElementWorldInterface_CanMoveElement Parms{};

	Parms.InElementHandle = std::move(InElementHandle);
	Parms.InWorldType = InWorldType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.DeleteElement
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTypedElementSelectionSet*        InSelectionSet                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTypedElementDeletionOptions     InDeletionOptions                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::DeleteElement(const struct FTypedElementHandle& InElementHandle, class UWorld* InWorld, class UTypedElementSelectionSet* InSelectionSet, const struct FTypedElementDeletionOptions& InDeletionOptions)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DeleteElement");

	Params::TypedElementWorldInterface_DeleteElement Parms{};

	Parms.InElementHandle = std::move(InElementHandle);
	Parms.InWorld = InWorld;
	Parms.InSelectionSet = InSelectionSet;
	Parms.InDeletionOptions = std::move(InDeletionOptions);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.DuplicateElement
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocationOffset                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTypedElementHandle              ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTypedElementHandle ITypedElementWorldInterface::DuplicateElement(const struct FTypedElementHandle& InElementHandle, class UWorld* InWorld, const struct FVector& InLocationOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DuplicateElement");

	Params::TypedElementWorldInterface_DuplicateElement Parms{};

	Parms.InElementHandle = std::move(InElementHandle);
	Parms.InWorld = InWorld;
	Parms.InLocationOffset = std::move(InLocationOffset);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.GetBounds
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBoxSphereBounds                 OutBounds                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::GetBounds(const struct FTypedElementHandle& InElementHandle, struct FBoxSphereBounds* OutBounds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBounds");

	Params::TypedElementWorldInterface_GetBounds Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (OutBounds != nullptr)
		*OutBounds = std::move(Parms.OutBounds);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.GetOwnerLevel
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* ITypedElementWorldInterface::GetOwnerLevel(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwnerLevel");

	Params::TypedElementWorldInterface_GetOwnerLevel Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.GetOwnerWorld
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* ITypedElementWorldInterface::GetOwnerWorld(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOwnerWorld");

	Params::TypedElementWorldInterface_GetOwnerWorld Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.GetPivotOffset
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutPivotOffset                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::GetPivotOffset(const struct FTypedElementHandle& InElementHandle, struct FVector* OutPivotOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPivotOffset");

	Params::TypedElementWorldInterface_GetPivotOffset Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (OutPivotOffset != nullptr)
		*OutPivotOffset = std::move(Parms.OutPivotOffset);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.GetRelativeTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::GetRelativeTransform(const struct FTypedElementHandle& InElementHandle, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetRelativeTransform");

	Params::TypedElementWorldInterface_GetRelativeTransform Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.GetWorldTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::GetWorldTransform(const struct FTypedElementHandle& InElementHandle, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldTransform");

	Params::TypedElementWorldInterface_GetWorldTransform Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.IsTemplateElement
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::IsTemplateElement(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsTemplateElement");

	Params::TypedElementWorldInterface_IsTemplateElement Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.NotifyMovementEnded
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITypedElementWorldInterface::NotifyMovementEnded(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NotifyMovementEnded");

	Params::TypedElementWorldInterface_NotifyMovementEnded Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TypedElementWorldInterface.NotifyMovementOngoing
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITypedElementWorldInterface::NotifyMovementOngoing(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NotifyMovementOngoing");

	Params::TypedElementWorldInterface_NotifyMovementOngoing Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TypedElementWorldInterface.NotifyMovementStarted
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITypedElementWorldInterface::NotifyMovementStarted(const struct FTypedElementHandle& InElementHandle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("NotifyMovementStarted");

	Params::TypedElementWorldInterface_NotifyMovementStarted Parms{};

	Parms.InElementHandle = std::move(InElementHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TypedElementWorldInterface.SetPivotOffset
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InPivotOffset                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::SetPivotOffset(const struct FTypedElementHandle& InElementHandle, const struct FVector& InPivotOffset)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPivotOffset");

	Params::TypedElementWorldInterface_SetPivotOffset Parms{};

	Parms.InElementHandle = std::move(InElementHandle);
	Parms.InPivotOffset = std::move(InPivotOffset);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.SetRelativeTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::SetRelativeTransform(const struct FTypedElementHandle& InElementHandle, const struct FTransform& InTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRelativeTransform");

	Params::TypedElementWorldInterface_SetRelativeTransform Parms{};

	Parms.InElementHandle = std::move(InElementHandle);
	Parms.InTransform = std::move(InTransform);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TypedElementWorldInterface.SetWorldTransform
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTypedElementHandle              InElementHandle                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITypedElementWorldInterface::SetWorldTransform(const struct FTypedElementHandle& InElementHandle, const struct FTransform& InTransform)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWorldTransform");

	Params::TypedElementWorldInterface_SetWorldTransform Parms{};

	Parms.InElementHandle = std::move(InElementHandle);
	Parms.InTransform = std::move(InTransform);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.ActivateReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReverbEffect*                    ReverbEffect                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::ActivateReverbEffect(const class UObject* WorldContextObject, class UReverbEffect* ReverbEffect, class FName TagName, float Priority, float Volume, float FadeTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ActivateReverbEffect");

	Params::GameplayStatics_ActivateReverbEffect Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ReverbEffect = ReverbEffect;
	Parms.TagName = TagName;
	Parms.Priority = Priority;
	Parms.Volume = Volume;
	Parms.FadeTime = FadeTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.AnnounceAccessibleString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           AnnouncementString                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::AnnounceAccessibleString(const class FString& AnnouncementString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AnnounceAccessibleString");

	Params::GameplayStatics_AnnounceAccessibleString Parms{};

	Parms.AnnouncementString = std::move(AnnouncementString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.ApplyDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ApplyDamage");

	Params::GameplayStatics_ApplyDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.BaseDamage = BaseDamage;
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.ApplyPointDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitFromDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ApplyPointDamage");

	Params::GameplayStatics_ApplyPointDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.BaseDamage = BaseDamage;
	Parms.HitFromDirection = std::move(HitFromDirection);
	Parms.HitInfo = std::move(HitInfo);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.ApplyRadialDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoFullDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::ApplyRadialDamage(const class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ApplyRadialDamage");

	Params::GameplayStatics_ApplyRadialDamage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageRadius = DamageRadius;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.bDoFullDamage = bDoFullDamage;
	Parms.DamagePreventionChannel = DamagePreventionChannel;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinimumDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageInnerRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageOuterRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageFalloff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::ApplyRadialDamageWithFalloff(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ApplyRadialDamageWithFalloff");

	Params::GameplayStatics_ApplyRadialDamageWithFalloff Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.MinimumDamage = MinimumDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageInnerRadius = DamageInnerRadius;
	Parms.DamageOuterRadius = DamageOuterRadius;
	Parms.DamageFalloff = DamageFalloff;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.DamagePreventionChannel = DamagePreventionChannel;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.AreAnyListenersWithinRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::AreAnyListenersWithinRange(const class UObject* WorldContextObject, const struct FVector& Location, float MaximumRange)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AreAnyListenersWithinRange");

	Params::GameplayStatics_AreAnyListenersWithinRange Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.MaximumRange = MaximumRange;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.AreSubtitlesEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::AreSubtitlesEnabled()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AreSubtitlesEnabled");

	Params::GameplayStatics_AreSubtitlesEnabled Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnActorCollisionHandlingMethod      CollisionHandlingOverride                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::BeginDeferredActorSpawnFromClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BeginDeferredActorSpawnFromClass");

	Params::GameplayStatics_BeginDeferredActorSpawnFromClass Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CollisionHandlingOverride = CollisionHandlingOverride;
	Parms.Owner = Owner;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprint*                       Blueprint                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bNoCollisionFail                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::BeginSpawningActorFromBlueprint(const class UObject* WorldContextObject, const class UBlueprint* Blueprint, const struct FTransform& SpawnTransform, bool bNoCollisionFail)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BeginSpawningActorFromBlueprint");

	Params::GameplayStatics_BeginSpawningActorFromBlueprint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Blueprint = Blueprint;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.bNoCollisionFail = bNoCollisionFail;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_Advanced
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPredictProjectilePathParams     PredictParams                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPredictProjectilePathResult     PredictResult                                          (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::Blueprint_PredictProjectilePath_Advanced(const class UObject* WorldContextObject, const struct FPredictProjectilePathParams& PredictParams, struct FPredictProjectilePathResult* PredictResult)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Blueprint_PredictProjectilePath_Advanced");

	Params::GameplayStatics_Blueprint_PredictProjectilePath_Advanced Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PredictParams = std::move(PredictParams);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PredictResult != nullptr)
		*PredictResult = std::move(Parms.PredictResult);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByObjectType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutPathPositions                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          OutLastTraceDestination                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartPos                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTracePath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ProjectileRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawDebugTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SimFrequency                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSimTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideGravityZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::Blueprint_PredictProjectilePath_ByObjectType(const class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Blueprint_PredictProjectilePath_ByObjectType");

	Params::GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPos = std::move(StartPos);
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.bTracePath = bTracePath;
	Parms.ProjectileRadius = ProjectileRadius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.DrawDebugTime = DrawDebugTime;
	Parms.SimFrequency = SimFrequency;
	Parms.MaxSimTime = MaxSimTime;
	Parms.OverrideGravityZ = OverrideGravityZ;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (OutPathPositions != nullptr)
		*OutPathPositions = std::move(Parms.OutPathPositions);

	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = std::move(Parms.OutLastTraceDestination);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByTraceChannel
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutPathPositions                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          OutLastTraceDestination                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartPos                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTracePath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ProjectileRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawDebugTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SimFrequency                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSimTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideGravityZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::Blueprint_PredictProjectilePath_ByTraceChannel(const class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Blueprint_PredictProjectilePath_ByTraceChannel");

	Params::GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPos = std::move(StartPos);
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.bTracePath = bTracePath;
	Parms.ProjectileRadius = ProjectileRadius;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.DrawDebugTime = DrawDebugTime;
	Parms.SimFrequency = SimFrequency;
	Parms.MaxSimTime = MaxSimTime;
	Parms.OverrideGravityZ = OverrideGravityZ;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (OutPathPositions != nullptr)
		*OutPathPositions = std::move(Parms.OutPathPositions);

	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = std::move(Parms.OutLastTraceDestination);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TossVelocity                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideGravityZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESuggestProjVelocityTraceOption         TraceOption                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CollisionRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFavorHighArc                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawDebug                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::BlueprintSuggestProjectileVelocity(const class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BlueprintSuggestProjectileVelocity");

	Params::GameplayStatics_BlueprintSuggestProjectileVelocity Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.LaunchSpeed = LaunchSpeed;
	Parms.OverrideGravityZ = OverrideGravityZ;
	Parms.TraceOption = TraceOption;
	Parms.CollisionRadius = CollisionRadius;
	Parms.bFavorHighArc = bFavorHighArc;
	Parms.bDrawDebug = bDrawDebug;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (TossVelocity != nullptr)
		*TossVelocity = std::move(Parms.TossVelocity);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.BreakHitResult
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bBlockingHit                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInitialOverlap                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactNormal                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                PhysMat                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              HitComponent                                           (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             HitBoneName                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HitItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ElementIndex                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FaceIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceStart                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceEnd                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::BreakHitResult(const struct FHitResult& Hit, bool* bBlockingHit, bool* bInitialOverlap, float* Time, float* Distance, struct FVector* Location, struct FVector* ImpactPoint, struct FVector* Normal, struct FVector* ImpactNormal, class UPhysicalMaterial** PhysMat, class AActor** HitActor, class UPrimitiveComponent** HitComponent, class FName* HitBoneName, class FName* BoneName, int32* HitItem, int32* ElementIndex, int32* FaceIndex, struct FVector* TraceStart, struct FVector* TraceEnd)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakHitResult");

	Params::GameplayStatics_BreakHitResult Parms{};

	Parms.Hit = std::move(Hit);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (bBlockingHit != nullptr)
		*bBlockingHit = Parms.bBlockingHit;

	if (bInitialOverlap != nullptr)
		*bInitialOverlap = Parms.bInitialOverlap;

	if (Time != nullptr)
		*Time = Parms.Time;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (ImpactPoint != nullptr)
		*ImpactPoint = std::move(Parms.ImpactPoint);

	if (Normal != nullptr)
		*Normal = std::move(Parms.Normal);

	if (ImpactNormal != nullptr)
		*ImpactNormal = std::move(Parms.ImpactNormal);

	if (PhysMat != nullptr)
		*PhysMat = Parms.PhysMat;

	if (HitActor != nullptr)
		*HitActor = Parms.HitActor;

	if (HitComponent != nullptr)
		*HitComponent = Parms.HitComponent;

	if (HitBoneName != nullptr)
		*HitBoneName = Parms.HitBoneName;

	if (BoneName != nullptr)
		*BoneName = Parms.BoneName;

	if (HitItem != nullptr)
		*HitItem = Parms.HitItem;

	if (ElementIndex != nullptr)
		*ElementIndex = Parms.ElementIndex;

	if (FaceIndex != nullptr)
		*FaceIndex = Parms.FaceIndex;

	if (TraceStart != nullptr)
		*TraceStart = std::move(Parms.TraceStart);

	if (TraceEnd != nullptr)
		*TraceEnd = std::move(Parms.TraceEnd);
}


// Function Engine.GameplayStatics.CancelAsyncLoading
// (Final, Native, Static, Public, BlueprintCallable)

void UGameplayStatics::CancelAsyncLoading()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CancelAsyncLoading");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.GameplayStatics.ClearSoundMixClassOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                        InSoundMixModifier                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundClass*                      InSoundClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::ClearSoundMixClassOverride(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float FadeOutTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClearSoundMixClassOverride");

	Params::GameplayStatics_ClearSoundMixClassOverride Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMixModifier = InSoundMixModifier;
	Parms.InSoundClass = InSoundClass;
	Parms.FadeOutTime = FadeOutTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.ClearSoundMixModifiers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::ClearSoundMixModifiers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ClearSoundMixModifiers");

	Params::GameplayStatics_ClearSoundMixModifiers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.CreatePlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnPlayerController                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UGameplayStatics::CreatePlayer(const class UObject* WorldContextObject, int32 ControllerId, bool bSpawnPlayerController)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreatePlayer");

	Params::GameplayStatics_CreatePlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ControllerId = ControllerId;
	Parms.bSpawnPlayerController = bSpawnPlayerController;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.CreateSaveGameObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class USaveGame>            SaveGameClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UGameplayStatics::CreateSaveGameObject(TSubclassOf<class USaveGame> SaveGameClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateSaveGameObject");

	Params::GameplayStatics_CreateSaveGameObject Parms{};

	Parms.SaveGameClass = SaveGameClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.CreateSound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistAcrossLevelTransition                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::CreateSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateSound2D");

	Params::GameplayStatics_CreateSound2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.DeactivateReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::DeactivateReverbEffect(const class UObject* WorldContextObject, class FName TagName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DeactivateReverbEffect");

	Params::GameplayStatics_DeactivateReverbEffect Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TagName = TagName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.DeleteGameInSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::DeleteGameInSlot(const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DeleteGameInSlot");

	Params::GameplayStatics_DeleteGameInSlot Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.DeprojectScreenToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::DeprojectScreenToWorld(class APlayerController* Player, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DeprojectScreenToWorld");

	Params::GameplayStatics_DeprojectScreenToWorld Parms{};

	Parms.Player = Player;
	Parms.ScreenPosition = std::move(ScreenPosition);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (WorldPosition != nullptr)
		*WorldPosition = std::move(Parms.WorldPosition);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.DoesSaveGameExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::DoesSaveGameExist(const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DoesSaveGameExist");

	Params::GameplayStatics_DoesSaveGameExist Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.EnableLiveStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::EnableLiveStreaming(bool Enable)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EnableLiveStreaming");

	Params::GameplayStatics_EnableLiveStreaming Parms{};

	Parms.Enable = Enable;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.FindCollisionUV
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   UVChannel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        UV                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::FindCollisionUV(const struct FHitResult& Hit, int32 UVChannel, struct FVector2D* UV)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindCollisionUV");

	Params::GameplayStatics_FindCollisionUV Parms{};

	Parms.Hit = std::move(Hit);
	Parms.UVChannel = UVChannel;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (UV != nullptr)
		*UV = std::move(Parms.UV);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.FindNearestActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToCheck                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::FindNearestActor(const struct FVector& Origin, const TArray<class AActor*>& ActorsToCheck, float* Distance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindNearestActor");

	Params::GameplayStatics_FindNearestActor Parms{};

	Parms.Origin = std::move(Origin);
	Parms.ActorsToCheck = std::move(ActorsToCheck);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.FinishSpawningActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::FinishSpawningActor(class AActor* Actor, const struct FTransform& SpawnTransform)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FinishSpawningActor");

	Params::GameplayStatics_FinishSpawningActor Parms{};

	Parms.Actor = Actor;
	Parms.SpawnTransform = std::move(SpawnTransform);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.FlushLevelStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::FlushLevelStreaming(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FlushLevelStreaming");

	Params::GameplayStatics_FlushLevelStreaming Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.GetAccurateRealTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Seconds                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PartialSeconds                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAccurateRealTime(int32* Seconds, float* PartialSeconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAccurateRealTime");

	Params::GameplayStatics_GetAccurateRealTime Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Seconds != nullptr)
		*Seconds = Parms.Seconds;

	if (PartialSeconds != nullptr)
		*PartialSeconds = Parms.PartialSeconds;
}


// Function Engine.GameplayStatics.GetActorArrayAverageLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameplayStatics::GetActorArrayAverageLocation(const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetActorArrayAverageLocation");

	Params::GameplayStatics_GetActorArrayAverageLocation Parms{};

	Parms.Actors = std::move(Actors);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetActorArrayBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bOnlyCollidingComponents                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::GetActorArrayBounds(const TArray<class AActor*>& Actors, bool bOnlyCollidingComponents, struct FVector* Center, struct FVector* BoxExtent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetActorArrayBounds");

	Params::GameplayStatics_GetActorArrayBounds Parms{};

	Parms.Actors = std::move(Actors);
	Parms.bOnlyCollidingComponents = bOnlyCollidingComponents;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Center != nullptr)
		*Center = std::move(Parms.Center);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);
}


// Function Engine.GameplayStatics.GetActorOfClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGameplayStatics::GetActorOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetActorOfClass");

	Params::GameplayStatics_GetActorOfClass Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetAllActorsOfClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAllActorsOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllActorsOfClass");

	Params::GameplayStatics_GetAllActorsOfClass Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Engine.GameplayStatics.GetAllActorsOfClassWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAllActorsOfClassWithTag(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, class FName Tag, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllActorsOfClassWithTag");

	Params::GameplayStatics_GetAllActorsOfClassWithTag Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.Tag = Tag;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Engine.GameplayStatics.GetAllActorsWithInterface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           Interface                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAllActorsWithInterface(const class UObject* WorldContextObject, TSubclassOf<class IInterface> Interface, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllActorsWithInterface");

	Params::GameplayStatics_GetAllActorsWithInterface Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Interface = Interface;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Engine.GameplayStatics.GetAllActorsWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayStatics::GetAllActorsWithTag(const class UObject* WorldContextObject, class FName Tag, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAllActorsWithTag");

	Params::GameplayStatics_GetAllActorsWithTag Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Tag = Tag;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Engine.GameplayStatics.GetAudioTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetAudioTimeSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAudioTimeSeconds");

	Params::GameplayStatics_GetAudioTimeSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetClosestListenerLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaximumRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowAttenuationOverride                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ListenerPosition                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::GetClosestListenerLocation(const class UObject* WorldContextObject, const struct FVector& Location, float MaximumRange, const bool bAllowAttenuationOverride, struct FVector* ListenerPosition)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetClosestListenerLocation");

	Params::GameplayStatics_GetClosestListenerLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.MaximumRange = MaximumRange;
	Parms.bAllowAttenuationOverride = bAllowAttenuationOverride;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (ListenerPosition != nullptr)
		*ListenerPosition = std::move(Parms.ListenerPosition);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetCurrentLevelName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemovePrefixString                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameplayStatics::GetCurrentLevelName(const class UObject* WorldContextObject, bool bRemovePrefixString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentLevelName");

	Params::GameplayStatics_GetCurrentLevelName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bRemovePrefixString = bRemovePrefixString;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetCurrentReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UReverbEffect*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UReverbEffect* UGameplayStatics::GetCurrentReverbEffect(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentReverbEffect");

	Params::GameplayStatics_GetCurrentReverbEffect Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetEnableWorldRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::GetEnableWorldRendering(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEnableWorldRendering");

	Params::GameplayStatics_GetEnableWorldRendering Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameInstance* UGameplayStatics::GetGameInstance(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameInstance");

	Params::GameplayStatics_GetGameInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameModeBase*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameModeBase* UGameplayStatics::GetGameMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameMode");

	Params::GameplayStatics_GetGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameStateBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameStateBase* UGameplayStatics::GetGameState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameState");

	Params::GameplayStatics_GetGameState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetGlobalTimeDilation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetGlobalTimeDilation(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGlobalTimeDilation");

	Params::GameplayStatics_GetGlobalTimeDilation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetIntOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetIntOption(const class FString& Options, const class FString& Key, int32 DefaultValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetIntOption");

	Params::GameplayStatics_GetIntOption Parms{};

	Parms.Options = std::move(Options);
	Parms.Key = std::move(Key);
	Parms.DefaultValue = DefaultValue;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetKeyValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Pair                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::GetKeyValue(const class FString& Pair, class FString* Key, class FString* Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetKeyValue");

	Params::GameplayStatics_GetKeyValue Parms{};

	Parms.Pair = std::move(Pair);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Key != nullptr)
		*Key = std::move(Parms.Key);

	if (Value != nullptr)
		*Value = std::move(Parms.Value);
}


// Function Engine.GameplayStatics.GetMaxAudioChannelCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetMaxAudioChannelCount(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMaxAudioChannelCount");

	Params::GameplayStatics_GetMaxAudioChannelCount Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetNumLocalPlayerControllers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetNumLocalPlayerControllers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetNumLocalPlayerControllers");

	Params::GameplayStatics_GetNumLocalPlayerControllers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetNumPlayerControllers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetNumPlayerControllers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetNumPlayerControllers");

	Params::GameplayStatics_GetNumPlayerControllers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetNumPlayerStates
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetNumPlayerStates(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetNumPlayerStates");

	Params::GameplayStatics_GetNumPlayerStates Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetObjectClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UGameplayStatics::GetObjectClass(const class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetObjectClass");

	Params::GameplayStatics_GetObjectClass Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlatformName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameplayStatics::GetPlatformName()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlatformName");

	Params::GameplayStatics_GetPlatformName Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerCameraManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerCameraManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerCameraManager* UGameplayStatics::GetPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerCameraManager");

	Params::GameplayStatics_GetPlayerCameraManager Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UGameplayStatics::GetPlayerCharacter(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerCharacter");

	Params::GameplayStatics_GetPlayerCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UGameplayStatics::GetPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerController");

	Params::GameplayStatics_GetPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerControllerFromID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UGameplayStatics::GetPlayerControllerFromID(const class UObject* WorldContextObject, int32 ControllerId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerControllerFromID");

	Params::GameplayStatics_GetPlayerControllerFromID Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ControllerId = ControllerId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerControllerID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GetPlayerControllerID(class APlayerController* Player)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerControllerID");

	Params::GameplayStatics_GetPlayerControllerID Parms{};

	Parms.Player = Player;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UGameplayStatics::GetPlayerPawn(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerPawn");

	Params::GameplayStatics_GetPlayerPawn Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerStateIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* UGameplayStatics::GetPlayerState(const class UObject* WorldContextObject, int32 PlayerStateIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerState");

	Params::GameplayStatics_GetPlayerState Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerStateIndex = PlayerStateIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerStateFromUniqueNetID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUniqueNetIdRepl                 UniqueId                                               (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* UGameplayStatics::GetPlayerStateFromUniqueNetID(const class UObject* WorldContextObject, const struct FUniqueNetIdRepl& UniqueId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlayerStateFromUniqueNetID");

	Params::GameplayStatics_GetPlayerStateFromUniqueNetID Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.UniqueId = std::move(UniqueId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetRealTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetRealTimeSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRealTimeSeconds");

	Params::GameplayStatics_GetRealTimeSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetStreamingLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PackageName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreaming*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreaming* UGameplayStatics::GetStreamingLevel(const class UObject* WorldContextObject, class FName PackageName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetStreamingLevel");

	Params::GameplayStatics_GetStreamingLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PackageName = PackageName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetSurfaceType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface UGameplayStatics::GetSurfaceType(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSurfaceType");

	Params::GameplayStatics_GetSurfaceType Parms{};

	Parms.Hit = std::move(Hit);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetTimeSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetTimeSeconds");

	Params::GameplayStatics_GetTimeSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetUnpausedTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetUnpausedTimeSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetUnpausedTimeSeconds");

	Params::GameplayStatics_GetUnpausedTimeSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetViewportMouseCaptureMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMouseCaptureMode                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMouseCaptureMode UGameplayStatics::GetViewportMouseCaptureMode(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetViewportMouseCaptureMode");

	Params::GameplayStatics_GetViewportMouseCaptureMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetViewProjectionMatrix
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMinimalViewInfo                 DesiredView                                            (Parm, NativeAccessSpecifierPublic)
// struct FMatrix                          ViewMatrix                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ProjectionMatrix                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FMatrix                          ViewProjectionMatrix                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGameplayStatics::GetViewProjectionMatrix(const struct FMinimalViewInfo& DesiredView, struct FMatrix* ViewMatrix, struct FMatrix* ProjectionMatrix, struct FMatrix* ViewProjectionMatrix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetViewProjectionMatrix");

	Params::GameplayStatics_GetViewProjectionMatrix Parms{};

	Parms.DesiredView = std::move(DesiredView);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (ViewMatrix != nullptr)
		*ViewMatrix = std::move(Parms.ViewMatrix);

	if (ProjectionMatrix != nullptr)
		*ProjectionMatrix = std::move(Parms.ProjectionMatrix);

	if (ViewProjectionMatrix != nullptr)
		*ViewProjectionMatrix = std::move(Parms.ViewProjectionMatrix);
}


// Function Engine.GameplayStatics.GetWorldDeltaSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayStatics::GetWorldDeltaSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetWorldDeltaSeconds");

	Params::GameplayStatics_GetWorldDeltaSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GetWorldOriginLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UGameplayStatics::GetWorldOriginLocation(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetWorldOriginLocation");

	Params::GameplayStatics_GetWorldOriginLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.GrassOverlappingSphereCount
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      StaticMesh                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CenterPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayStatics::GrassOverlappingSphereCount(const class UObject* WorldContextObject, const class UStaticMesh* StaticMesh, const struct FVector& CenterPosition, float Radius)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GrassOverlappingSphereCount");

	Params::GameplayStatics_GrassOverlappingSphereCount Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StaticMesh = StaticMesh;
	Parms.CenterPosition = std::move(CenterPosition);
	Parms.Radius = Radius;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.HasLaunchOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           OptionToCheck                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::HasLaunchOption(const class FString& OptionToCheck)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HasLaunchOption");

	Params::GameplayStatics_HasLaunchOption Parms{};

	Parms.OptionToCheck = std::move(OptionToCheck);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.HasOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::HasOption(const class FString& Options, const class FString& InKey)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HasOption");

	Params::GameplayStatics_HasOption Parms{};

	Parms.Options = std::move(Options);
	Parms.InKey = std::move(InKey);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.IsGamePaused
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::IsGamePaused(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsGamePaused");

	Params::GameplayStatics_IsGamePaused Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.IsSplitscreenForceDisabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::IsSplitscreenForceDisabled(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsSplitscreenForceDisabled");

	Params::GameplayStatics_IsSplitscreenForceDisabled Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.LoadGameFromSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UGameplayStatics::LoadGameFromSlot(const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadGameFromSlot");

	Params::GameplayStatics_LoadGameFromSlot Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.LoadStreamLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LevelName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMakeVisibleAfterLoad                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBlockOnLoad                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGameplayStatics::LoadStreamLevel(const class UObject* WorldContextObject, class FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadStreamLevel");

	Params::GameplayStatics_LoadStreamLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;
	Parms.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	Parms.bShouldBlockOnLoad = bShouldBlockOnLoad;
	Parms.LatentInfo = std::move(LatentInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.LoadStreamLevelBySoftObjectPtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            Level                                                  (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMakeVisibleAfterLoad                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBlockOnLoad                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGameplayStatics::LoadStreamLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<class UWorld> Level, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadStreamLevelBySoftObjectPtr");

	Params::GameplayStatics_LoadStreamLevelBySoftObjectPtr Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Level = Level;
	Parms.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	Parms.bShouldBlockOnLoad = bShouldBlockOnLoad;
	Parms.LatentInfo = std::move(LatentInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.MakeHitResult
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bBlockingHit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInitialOverlap                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ImpactNormal                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                PhysMat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             HitBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HitItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ElementIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FaceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UGameplayStatics::MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, float Distance, const struct FVector& Location, const struct FVector& ImpactPoint, const struct FVector& Normal, const struct FVector& ImpactNormal, class UPhysicalMaterial* PhysMat, class AActor* HitActor, class UPrimitiveComponent* HitComponent, class FName HitBoneName, class FName BoneName, int32 HitItem, int32 ElementIndex, int32 FaceIndex, const struct FVector& TraceStart, const struct FVector& TraceEnd)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeHitResult");

	Params::GameplayStatics_MakeHitResult Parms{};

	Parms.bBlockingHit = bBlockingHit;
	Parms.bInitialOverlap = bInitialOverlap;
	Parms.Time = Time;
	Parms.Distance = Distance;
	Parms.Location = std::move(Location);
	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.Normal = std::move(Normal);
	Parms.ImpactNormal = std::move(ImpactNormal);
	Parms.PhysMat = PhysMat;
	Parms.HitActor = HitActor;
	Parms.HitComponent = HitComponent;
	Parms.HitBoneName = HitBoneName;
	Parms.BoneName = BoneName;
	Parms.HitItem = HitItem;
	Parms.ElementIndex = ElementIndex;
	Parms.FaceIndex = FaceIndex;
	Parms.TraceStart = std::move(TraceStart);
	Parms.TraceEnd = std::move(TraceEnd);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.OpenLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LevelName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAbsolute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::OpenLevel(const class UObject* WorldContextObject, class FName LevelName, bool bAbsolute, const class FString& Options)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("OpenLevel");

	Params::GameplayStatics_OpenLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;
	Parms.bAbsolute = bAbsolute;
	Parms.Options = std::move(Options);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.OpenLevelBySoftObjectPtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            Level                                                  (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAbsolute                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::OpenLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<class UWorld> Level, bool bAbsolute, const class FString& Options)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("OpenLevelBySoftObjectPtr");

	Params::GameplayStatics_OpenLevelBySoftObjectPtr Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Level = Level;
	Parms.bAbsolute = bAbsolute;
	Parms.Options = std::move(Options);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.ParseOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGameplayStatics::ParseOption(const class FString& Options, const class FString& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ParseOption");

	Params::GameplayStatics_ParseOption Parms{};

	Parms.Options = std::move(Options);
	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.PlayDialogue2D
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueWave*                    Dialogue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext                 Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlayDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PlayDialogue2D");

	Params::GameplayStatics_PlayDialogue2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Dialogue = Dialogue;
	Parms.Context = std::move(Context);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.PlayDialogueAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueWave*                    Dialogue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext                 Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlayDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PlayDialogueAtLocation");

	Params::GameplayStatics_PlayDialogueAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Dialogue = Dialogue;
	Parms.Context = std::move(Context);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.PlaySound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsUISound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlaySound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, class AActor* OwningActor, bool bIsUISound)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PlaySound2D");

	Params::GameplayStatics_PlaySound2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.OwningActor = OwningActor;
	Parms.bIsUISound = bIsUISound;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.PlaySoundAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInitialActiveSoundParams*        InitialParams                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlaySoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class AActor* OwningActor, class UInitialActiveSoundParams* InitialParams)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PlaySoundAtLocation");

	Params::GameplayStatics_PlaySoundAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.OwningActor = OwningActor;
	Parms.InitialParams = InitialParams;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.PlayWorldCameraShake
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCameraShakeBase>     Shake                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Epicenter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InnerRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OuterRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOrientShakeTowardsEpicenter                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PlayWorldCameraShake(const class UObject* WorldContextObject, TSubclassOf<class UCameraShakeBase> Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PlayWorldCameraShake");

	Params::GameplayStatics_PlayWorldCameraShake Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Shake = Shake;
	Parms.Epicenter = std::move(Epicenter);
	Parms.InnerRadius = InnerRadius;
	Parms.OuterRadius = OuterRadius;
	Parms.Falloff = Falloff;
	Parms.bOrientShakeTowardsEpicenter = bOrientShakeTowardsEpicenter;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.PopSoundMixModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                        InSoundMixModifier                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PopSoundMixModifier(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PopSoundMixModifier");

	Params::GameplayStatics_PopSoundMixModifier Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMixModifier = InSoundMixModifier;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.PrimeAllSoundsInSoundClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundClass*                      InSoundClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PrimeAllSoundsInSoundClass(class USoundClass* InSoundClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PrimeAllSoundsInSoundClass");

	Params::GameplayStatics_PrimeAllSoundsInSoundClass Parms{};

	Parms.InSoundClass = InSoundClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.PrimeSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       InSound                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PrimeSound(class USoundBase* InSound)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PrimeSound");

	Params::GameplayStatics_PrimeSound Parms{};

	Parms.InSound = InSound;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.ProjectWorldToScreen
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPosition                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerViewportRelative                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::ProjectWorldToScreen(class APlayerController* Player, const struct FVector& WorldPosition, struct FVector2D* ScreenPosition, bool bPlayerViewportRelative)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ProjectWorldToScreen");

	Params::GameplayStatics_ProjectWorldToScreen Parms{};

	Parms.Player = Player;
	Parms.WorldPosition = std::move(WorldPosition);
	Parms.bPlayerViewportRelative = bPlayerViewportRelative;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (ScreenPosition != nullptr)
		*ScreenPosition = std::move(Parms.ScreenPosition);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.PushSoundMixModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                        InSoundMixModifier                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::PushSoundMixModifier(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PushSoundMixModifier");

	Params::GameplayStatics_PushSoundMixModifier Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMixModifier = InSoundMixModifier;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.RebaseLocalOriginOntoZero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameplayStatics::RebaseLocalOriginOntoZero(class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RebaseLocalOriginOntoZero");

	Params::GameplayStatics_RebaseLocalOriginOntoZero Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.RebaseZeroOriginOntoLocal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGameplayStatics::RebaseZeroOriginOntoLocal(class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RebaseZeroOriginOntoLocal");

	Params::GameplayStatics_RebaseZeroOriginOntoLocal Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.RemovePlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestroyPawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::RemovePlayer(class APlayerController* Player, bool bDestroyPawn)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RemovePlayer");

	Params::GameplayStatics_RemovePlayer Parms{};

	Parms.Player = Player;
	Parms.bDestroyPawn = bDestroyPawn;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SaveGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USaveGame*                        SaveGameObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::SaveGameToSlot(class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SaveGameToSlot");

	Params::GameplayStatics_SaveGameToSlot Parms{};

	Parms.SaveGameObject = SaveGameObject;
	Parms.SlotName = std::move(SlotName);
	Parms.UserIndex = UserIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SetBaseSoundMix
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                        InSoundMix                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetBaseSoundMix(const class UObject* WorldContextObject, class USoundMix* InSoundMix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetBaseSoundMix");

	Params::GameplayStatics_SetBaseSoundMix Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMix = InSoundMix;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetEnableWorldRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetEnableWorldRendering(const class UObject* WorldContextObject, bool bEnable)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetEnableWorldRendering");

	Params::GameplayStatics_SetEnableWorldRendering Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bEnable = bEnable;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetForceDisableSplitscreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetForceDisableSplitscreen(const class UObject* WorldContextObject, bool bDisable)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetForceDisableSplitscreen");

	Params::GameplayStatics_SetForceDisableSplitscreen Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bDisable = bDisable;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetGamePaused
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPaused                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::SetGamePaused(const class UObject* WorldContextObject, bool bPaused)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetGamePaused");

	Params::GameplayStatics_SetGamePaused Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bPaused = bPaused;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SetGlobalListenerFocusParameters
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FocusAzimuthScale                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NonFocusAzimuthScale                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FocusDistanceScale                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NonFocusDistanceScale                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FocusVolumeScale                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NonFocusVolumeScale                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FocusPriorityScale                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NonFocusPriorityScale                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetGlobalListenerFocusParameters(const class UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetGlobalListenerFocusParameters");

	Params::GameplayStatics_SetGlobalListenerFocusParameters Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FocusAzimuthScale = FocusAzimuthScale;
	Parms.NonFocusAzimuthScale = NonFocusAzimuthScale;
	Parms.FocusDistanceScale = FocusDistanceScale;
	Parms.NonFocusDistanceScale = NonFocusDistanceScale;
	Parms.FocusVolumeScale = FocusVolumeScale;
	Parms.NonFocusVolumeScale = NonFocusVolumeScale;
	Parms.FocusPriorityScale = FocusPriorityScale;
	Parms.NonFocusPriorityScale = NonFocusPriorityScale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetGlobalPitchModulation
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchModulation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetGlobalPitchModulation(const class UObject* WorldContextObject, float PitchModulation, float TimeSec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetGlobalPitchModulation");

	Params::GameplayStatics_SetGlobalPitchModulation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PitchModulation = PitchModulation;
	Parms.TimeSec = TimeSec;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetGlobalTimeDilation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeDilation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetGlobalTimeDilation(const class UObject* WorldContextObject, float TimeDilation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetGlobalTimeDilation");

	Params::GameplayStatics_SetGlobalTimeDilation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TimeDilation = TimeDilation;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetMaxAudioChannelsScaled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxChannelCountScale                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetMaxAudioChannelsScaled(const class UObject* WorldContextObject, float MaxChannelCountScale)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetMaxAudioChannelsScaled");

	Params::GameplayStatics_SetMaxAudioChannelsScaled Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MaxChannelCountScale = MaxChannelCountScale;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetPlayerControllerID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetPlayerControllerID(class APlayerController* Player, int32 ControllerId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetPlayerControllerID");

	Params::GameplayStatics_SetPlayerControllerID Parms{};

	Parms.Player = Player;
	Parms.ControllerId = ControllerId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetSoundClassDistanceScale
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundClass*                      SoundClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAttenuationScale                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetSoundClassDistanceScale(const class UObject* WorldContextObject, class USoundClass* SoundClass, float DistanceAttenuationScale, float TimeSec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetSoundClassDistanceScale");

	Params::GameplayStatics_SetSoundClassDistanceScale Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SoundClass = SoundClass;
	Parms.DistanceAttenuationScale = DistanceAttenuationScale;
	Parms.TimeSec = TimeSec;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetSoundMixClassOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundMix*                        InSoundMixModifier                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundClass*                      InSoundClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeInTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bApplyToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetSoundMixClassOverride(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetSoundMixClassOverride");

	Params::GameplayStatics_SetSoundMixClassOverride Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InSoundMixModifier = InSoundMixModifier;
	Parms.InSoundClass = InSoundClass;
	Parms.Volume = Volume;
	Parms.Pitch = Pitch;
	Parms.FadeInTime = FadeInTime;
	Parms.bApplyToChildren = bApplyToChildren;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetSubtitlesEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetSubtitlesEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetSubtitlesEnabled");

	Params::GameplayStatics_SetSubtitlesEnabled Parms{};

	Parms.bEnabled = bEnabled;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetViewportMouseCaptureMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMouseCaptureMode                       MouseCaptureMode                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetViewportMouseCaptureMode(const class UObject* WorldContextObject, const EMouseCaptureMode MouseCaptureMode)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetViewportMouseCaptureMode");

	Params::GameplayStatics_SetViewportMouseCaptureMode Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.MouseCaptureMode = MouseCaptureMode;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SetWorldOriginLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::SetWorldOriginLocation(const class UObject* WorldContextObject, const struct FIntVector& NewLocation)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetWorldOriginLocation");

	Params::GameplayStatics_SetWorldOriginLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NewLocation = std::move(NewLocation);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.SpawnDecalAtLocation
// (Final, BlueprintCosmetic, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               DecalMaterial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DecalSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   LifeSpan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDecalComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalComponent* UGameplayStatics::SpawnDecalAtLocation(const class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnDecalAtLocation");

	Params::GameplayStatics_SpawnDecalAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DecalMaterial = DecalMaterial;
	Parms.DecalSize = std::move(DecalSize);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LifeSpan = LifeSpan;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDecalAttached
// (Final, BlueprintCosmetic, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               DecalMaterial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DecalSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeSpan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDecalComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalComponent* UGameplayStatics::SpawnDecalAttached(class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, float LifeSpan)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnDecalAttached");

	Params::GameplayStatics_SpawnDecalAttached Parms{};

	Parms.DecalMaterial = DecalMaterial;
	Parms.DecalSize = std::move(DecalSize);
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.LifeSpan = LifeSpan;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDialogue2D
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueWave*                    Dialogue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext                 Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnDialogue2D");

	Params::GameplayStatics_SpawnDialogue2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Dialogue = Dialogue;
	Parms.Context = std::move(Context);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDialogueAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDialogueWave*                    Dialogue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext                 Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnDialogueAtLocation");

	Params::GameplayStatics_SpawnDialogueAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Dialogue = Dialogue;
	Parms.Context = std::move(Context);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDialogueAttached
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDialogueWave*                    Dialogue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDialogueContext                 Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnDialogueAttached(class UDialogueWave* Dialogue, const struct FDialogueContext& Context, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnDialogueAttached");

	Params::GameplayStatics_SpawnDialogueAttached Parms{};

	Parms.Dialogue = Dialogue;
	Parms.Context = std::move(Context);
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnEmitterAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  EmitterTemplate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPSCPoolMethod                          PoolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivateSystem                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UGameplayStatics::SpawnEmitterAtLocation(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivateSystem)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnEmitterAtLocation");

	Params::GameplayStatics_SpawnEmitterAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EmitterTemplate = EmitterTemplate;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.PoolingMethod = PoolingMethod;
	Parms.bAutoActivateSystem = bAutoActivateSystem;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnEmitterAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleSystem*                  EmitterTemplate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPSCPoolMethod                          PoolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoActivate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UGameplayStatics::SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, EAttachLocation LocationType, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnEmitterAttached");

	Params::GameplayStatics_SpawnEmitterAttached Parms{};

	Parms.EmitterTemplate = EmitterTemplate;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Scale = std::move(Scale);
	Parms.LocationType = LocationType;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.PoolingMethod = PoolingMethod;
	Parms.bAutoActivate = bAutoActivate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnForceFeedbackAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IntensityMultiplier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackAttenuation*        AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UForceFeedbackComponent* UGameplayStatics::SpawnForceFeedbackAtLocation(const class UObject* WorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, const struct FVector& Location, const struct FRotator& Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnForceFeedbackAtLocation");

	Params::GameplayStatics_SpawnForceFeedbackAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.bLooping = bLooping;
	Parms.IntensityMultiplier = IntensityMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnForceFeedbackAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IntensityMultiplier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackAttenuation*        AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UForceFeedbackComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UForceFeedbackComponent* UGameplayStatics::SpawnForceFeedbackAttached(class UForceFeedbackEffect* ForceFeedbackEffect, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnForceFeedbackAttached");

	Params::GameplayStatics_SpawnForceFeedbackAttached Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.bLooping = bLooping;
	Parms.IntensityMultiplier = IntensityMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UObject>              ObjectClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UGameplayStatics::SpawnObject(TSubclassOf<class UObject> ObjectClass, class UObject* Outer_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnObject");

	Params::GameplayStatics_SpawnObject Parms{};

	Parms.ObjectClass = ObjectClass;
	Parms.Outer_0 = Outer_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnSound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPersistAcrossLevelTransition                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnSound2D");

	Params::GameplayStatics_SpawnSound2D Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnSoundAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnSoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnSoundAtLocation");

	Params::GameplayStatics_SpawnSoundAtLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Sound = Sound;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnSoundAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UGameplayStatics::SpawnSoundAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SpawnSoundAttached");

	Params::GameplayStatics_SpawnSoundAttached Parms{};

	Parms.Sound = Sound;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.bAutoDestroy = bAutoDestroy;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.SuggestProjectileVelocity_CustomArc
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutLaunchVelocity                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartPos                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndPos                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideGravityZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArcParam                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayStatics::SuggestProjectileVelocity_CustomArc(const class UObject* WorldContextObject, struct FVector* OutLaunchVelocity, const struct FVector& StartPos, const struct FVector& EndPos, float OverrideGravityZ, float ArcParam)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SuggestProjectileVelocity_CustomArc");

	Params::GameplayStatics_SuggestProjectileVelocity_CustomArc Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPos = std::move(StartPos);
	Parms.EndPos = std::move(EndPos);
	Parms.OverrideGravityZ = OverrideGravityZ;
	Parms.ArcParam = ArcParam;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutLaunchVelocity != nullptr)
		*OutLaunchVelocity = std::move(Parms.OutLaunchVelocity);

	return Parms.ReturnValue;
}


// Function Engine.GameplayStatics.UnloadStreamLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LevelName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bShouldBlockOnUnload                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::UnloadStreamLevel(const class UObject* WorldContextObject, class FName LevelName, const struct FLatentActionInfo& LatentInfo, bool bShouldBlockOnUnload)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnloadStreamLevel");

	Params::GameplayStatics_UnloadStreamLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = LevelName;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.bShouldBlockOnUnload = bShouldBlockOnUnload;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.UnloadStreamLevelBySoftObjectPtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            Level                                                  (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bShouldBlockOnUnload                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::UnloadStreamLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<class UWorld> Level, const struct FLatentActionInfo& LatentInfo, bool bShouldBlockOnUnload)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnloadStreamLevelBySoftObjectPtr");

	Params::GameplayStatics_UnloadStreamLevelBySoftObjectPtr Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Level = Level;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.bShouldBlockOnUnload = bShouldBlockOnUnload;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.GameplayStatics.UnRetainAllSoundsInSoundClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundClass*                      InSoundClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayStatics::UnRetainAllSoundsInSoundClass(class USoundClass* InSoundClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnRetainAllSoundsInSoundClass");

	Params::GameplayStatics_UnRetainAllSoundsInSoundClass Parms{};

	Parms.InSoundClass = InSoundClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.LevelStreaming.CreateInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UniqueInstanceName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreaming*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreaming* ULevelStreaming::CreateInstance(const class FString& UniqueInstanceName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CreateInstance");

	Params::LevelStreaming_CreateInstance Parms{};

	Parms.UniqueInstanceName = std::move(UniqueInstanceName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelStreaming.GetLevelScriptActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALevelScriptActor*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALevelScriptActor* ULevelStreaming::GetLevelScriptActor()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLevelScriptActor");

	Params::LevelStreaming_GetLevelScriptActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelStreaming.SetIsRequestingUnloadAndRemoval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsRequestingUnloadAndRemoval                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetIsRequestingUnloadAndRemoval(bool bInIsRequestingUnloadAndRemoval)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIsRequestingUnloadAndRemoval");

	Params::LevelStreaming_SetIsRequestingUnloadAndRemoval Parms{};

	Parms.bInIsRequestingUnloadAndRemoval = bInIsRequestingUnloadAndRemoval;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LevelStreaming.SetLevelLODIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetLevelLODIndex(int32 LODIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLevelLODIndex");

	Params::LevelStreaming_SetLevelLODIndex Parms{};

	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LevelStreaming.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewPriority                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetPriority(int32 NewPriority)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPriority");

	Params::LevelStreaming_SetPriority Parms{};

	Parms.NewPriority = NewPriority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LevelStreaming.SetShouldBeLoaded
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInShouldBeLoaded                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetShouldBeLoaded(bool bInShouldBeLoaded)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShouldBeLoaded");

	Params::LevelStreaming_SetShouldBeLoaded Parms{};

	Parms.bInShouldBeLoaded = bInShouldBeLoaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LevelStreaming.SetShouldBeVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInShouldBeVisible                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelStreaming::SetShouldBeVisible(bool bInShouldBeVisible)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetShouldBeVisible");

	Params::LevelStreaming_SetShouldBeVisible Parms{};

	Parms.bInShouldBeVisible = bInShouldBeVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.LevelStreaming.GetIsRequestingUnloadAndRemoval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::GetIsRequestingUnloadAndRemoval() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIsRequestingUnloadAndRemoval");

	Params::LevelStreaming_GetIsRequestingUnloadAndRemoval Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelStreaming.GetLoadedLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULevel*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* ULevelStreaming::GetLoadedLevel() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLoadedLevel");

	Params::LevelStreaming_GetLoadedLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelStreaming.GetWorldAssetPackageFName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULevelStreaming::GetWorldAssetPackageFName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWorldAssetPackageFName");

	Params::LevelStreaming_GetWorldAssetPackageFName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelStreaming.IsLevelLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::IsLevelLoaded() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsLevelLoaded");

	Params::LevelStreaming_IsLevelLoaded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelStreaming.IsLevelVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::IsLevelVisible() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsLevelVisible");

	Params::LevelStreaming_IsLevelVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelStreaming.IsStreamingStatePending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::IsStreamingStatePending() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsStreamingStatePending");

	Params::LevelStreaming_IsStreamingStatePending Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LevelStreaming.ShouldBeLoaded
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULevelStreaming::ShouldBeLoaded() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShouldBeLoaded");

	Params::LevelStreaming_ShouldBeLoaded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.HealthSnapshotBlueprintLibrary.LogPerformanceSnapshot
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SnapshotTitle                                          (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetStats                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthSnapshotBlueprintLibrary::LogPerformanceSnapshot(const class FString& SnapshotTitle, bool bResetStats)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LogPerformanceSnapshot");

	Params::HealthSnapshotBlueprintLibrary_LogPerformanceSnapshot Parms{};

	Parms.SnapshotTitle = std::move(SnapshotTitle);
	Parms.bResetStats = bResetStats;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.HealthSnapshotBlueprintLibrary.StartPerformanceSnapshots
// (Final, Exec, Native, Static, Public, BlueprintCallable)

void UHealthSnapshotBlueprintLibrary::StartPerformanceSnapshots()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StartPerformanceSnapshots");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.HealthSnapshotBlueprintLibrary.StopPerformanceSnapshots
// (Final, Exec, Native, Static, Public, BlueprintCallable)

void UHealthSnapshotBlueprintLibrary::StopPerformanceSnapshots()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StopPerformanceSnapshots");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.PhysicsConstraintComponent.BreakConstraint
// (Final, Native, Public, BlueprintCallable)

void UPhysicsConstraintComponent::BreakConstraint()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BreakConstraint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PhysicsConstraintComponent.GetConstrainedComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OutComponent1                                          (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutBoneName1                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OutComponent2                                          (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutBoneName2                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::GetConstrainedComponents(class UPrimitiveComponent** OutComponent1, class FName* OutBoneName1, class UPrimitiveComponent** OutComponent2, class FName* OutBoneName2)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConstrainedComponents");

	Params::PhysicsConstraintComponent_GetConstrainedComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutComponent1 != nullptr)
		*OutComponent1 = Parms.OutComponent1;

	if (OutBoneName1 != nullptr)
		*OutBoneName1 = Parms.OutBoneName1;

	if (OutComponent2 != nullptr)
		*OutComponent2 = Parms.OutComponent2;

	if (OutBoneName2 != nullptr)
		*OutBoneName2 = Parms.OutBoneName2;
}


// Function Engine.PhysicsConstraintComponent.GetConstraint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FConstraintInstanceAccessor      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FConstraintInstanceAccessor UPhysicsConstraintComponent::GetConstraint()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConstraint");

	Params::PhysicsConstraintComponent_GetConstraint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsConstraintComponent.GetConstraintForce
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          OutLinearForce                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutAngularForce                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::GetConstraintForce(struct FVector* OutLinearForce, struct FVector* OutAngularForce)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetConstraintForce");

	Params::PhysicsConstraintComponent_GetConstraintForce Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutLinearForce != nullptr)
		*OutLinearForce = std::move(Parms.OutLinearForce);

	if (OutAngularForce != nullptr)
		*OutAngularForce = std::move(Parms.OutAngularForce);
}


// Function Engine.PhysicsConstraintComponent.IsBroken
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPhysicsConstraintComponent::IsBroken()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsBroken");

	Params::PhysicsConstraintComponent_IsBroken Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsConstraintComponent.SetAngularBreakable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAngularBreakable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularBreakThreshold                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularBreakable(bool bAngularBreakable, float AngularBreakThreshold)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularBreakable");

	Params::PhysicsConstraintComponent_SetAngularBreakable Parms{};

	Parms.bAngularBreakable = bAngularBreakable;
	Parms.AngularBreakThreshold = AngularBreakThreshold;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularDriveMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAngularDriveMode                       DriveMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularDriveMode(EAngularDriveMode DriveMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularDriveMode");

	Params::PhysicsConstraintComponent_SetAngularDriveMode Parms{};

	Parms.DriveMode = DriveMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PositionStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VelocityStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForceLimit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularDriveParams");

	Params::PhysicsConstraintComponent_SetAngularDriveParams Parms{};

	Parms.PositionStrength = PositionStrength;
	Parms.VelocityStrength = VelocityStrength;
	Parms.InForceLimit = InForceLimit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableSwingDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableTwistDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularOrientationDrive");

	Params::PhysicsConstraintComponent_SetAngularOrientationDrive Parms{};

	Parms.bEnableSwingDrive = bEnableSwingDrive;
	Parms.bEnableTwistDrive = bEnableTwistDrive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         InPosTarget                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularOrientationTarget(const struct FRotator& InPosTarget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularOrientationTarget");

	Params::PhysicsConstraintComponent_SetAngularOrientationTarget Parms{};

	Parms.InPosTarget = std::move(InPosTarget);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularPlasticity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAngularPlasticity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularPlasticityThreshold                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularPlasticity(bool bAngularPlasticity, float AngularPlasticityThreshold)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularPlasticity");

	Params::PhysicsConstraintComponent_SetAngularPlasticity Parms{};

	Parms.bAngularPlasticity = bAngularPlasticity;
	Parms.AngularPlasticityThreshold = AngularPlasticityThreshold;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAngularConstraintMotion                MotionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing1LimitAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularSwing1Limit(EAngularConstraintMotion MotionType, float Swing1LimitAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularSwing1Limit");

	Params::PhysicsConstraintComponent_SetAngularSwing1Limit Parms{};

	Parms.MotionType = MotionType;
	Parms.Swing1LimitAngle = Swing1LimitAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAngularConstraintMotion                MotionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Swing2LimitAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularSwing2Limit(EAngularConstraintMotion MotionType, float Swing2LimitAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularSwing2Limit");

	Params::PhysicsConstraintComponent_SetAngularSwing2Limit Parms{};

	Parms.MotionType = MotionType;
	Parms.Swing2LimitAngle = Swing2LimitAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAngularConstraintMotion                ConstraintType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TwistLimitAngle                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularTwistLimit(EAngularConstraintMotion ConstraintType, float TwistLimitAngle)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularTwistLimit");

	Params::PhysicsConstraintComponent_SetAngularTwistLimit Parms{};

	Parms.ConstraintType = ConstraintType;
	Parms.TwistLimitAngle = TwistLimitAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableSwingDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableTwistDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularVelocityDrive");

	Params::PhysicsConstraintComponent_SetAngularVelocityDrive Parms{};

	Parms.bEnableSwingDrive = bEnableSwingDrive;
	Parms.bEnableTwistDrive = bEnableTwistDrive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveSLERP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableSLERP                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularVelocityDriveSLERP(bool bEnableSLERP)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularVelocityDriveSLERP");

	Params::PhysicsConstraintComponent_SetAngularVelocityDriveSLERP Parms{};

	Parms.bEnableSLERP = bEnableSLERP;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveTwistAndSwing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableTwistDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableSwingDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularVelocityDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularVelocityDriveTwistAndSwing");

	Params::PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing Parms{};

	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bEnableSwingDrive = bEnableSwingDrive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InVelTarget                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetAngularVelocityTarget(const struct FVector& InVelTarget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularVelocityTarget");

	Params::PhysicsConstraintComponent_SetAngularVelocityTarget Parms{};

	Parms.InVelTarget = std::move(InVelTarget);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetConstrainedComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component1                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName1                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              Component2                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName2                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetConstrainedComponents(class UPrimitiveComponent* Component1, class FName BoneName1, class UPrimitiveComponent* Component2, class FName BoneName2)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConstrainedComponents");

	Params::PhysicsConstraintComponent_SetConstrainedComponents Parms{};

	Parms.Component1 = Component1;
	Parms.BoneName1 = BoneName1;
	Parms.Component2 = Component2;
	Parms.BoneName2 = BoneName2;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// EConstraintFrame                        Frame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       RefFrame                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetConstraintReferenceFrame(EConstraintFrame Frame, const struct FTransform& RefFrame)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConstraintReferenceFrame");

	Params::PhysicsConstraintComponent_SetConstraintReferenceFrame Parms{};

	Parms.Frame = Frame;
	Parms.RefFrame = std::move(RefFrame);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// EConstraintFrame                        Frame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PriAxis                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SecAxis                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetConstraintReferenceOrientation(EConstraintFrame Frame, const struct FVector& PriAxis, const struct FVector& SecAxis)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConstraintReferenceOrientation");

	Params::PhysicsConstraintComponent_SetConstraintReferenceOrientation Parms{};

	Parms.Frame = Frame;
	Parms.PriAxis = std::move(PriAxis);
	Parms.SecAxis = std::move(SecAxis);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// EConstraintFrame                        Frame                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RefPosition                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetConstraintReferencePosition(EConstraintFrame Frame, const struct FVector& RefPosition)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetConstraintReferencePosition");

	Params::PhysicsConstraintComponent_SetConstraintReferencePosition Parms{};

	Parms.Frame = Frame;
	Parms.RefPosition = std::move(RefPosition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetDisableCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisableCollision                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetDisableCollision(bool bDisableCollision)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDisableCollision");

	Params::PhysicsConstraintComponent_SetDisableCollision Parms{};

	Parms.bDisableCollision = bDisableCollision;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearBreakable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLinearBreakable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearBreakThreshold                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearBreakable(bool bLinearBreakable, float LinearBreakThreshold)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearBreakable");

	Params::PhysicsConstraintComponent_SetLinearBreakable Parms{};

	Parms.bLinearBreakable = bLinearBreakable;
	Parms.LinearBreakThreshold = LinearBreakThreshold;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PositionStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VelocityStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForceLimit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearDriveParams");

	Params::PhysicsConstraintComponent_SetLinearDriveParams Parms{};

	Parms.PositionStrength = PositionStrength;
	Parms.VelocityStrength = VelocityStrength;
	Parms.InForceLimit = InForceLimit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearPlasticity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLinearPlasticity                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearPlasticityThreshold                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConstraintPlasticityType               PlasticityType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearPlasticity(bool bLinearPlasticity, float LinearPlasticityThreshold, EConstraintPlasticityType PlasticityType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearPlasticity");

	Params::PhysicsConstraintComponent_SetLinearPlasticity Parms{};

	Parms.bLinearPlasticity = bLinearPlasticity;
	Parms.LinearPlasticityThreshold = LinearPlasticityThreshold;
	Parms.PlasticityType = PlasticityType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableDriveX                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveY                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveZ                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearPositionDrive");

	Params::PhysicsConstraintComponent_SetLinearPositionDrive Parms{};

	Parms.bEnableDriveX = bEnableDriveX;
	Parms.bEnableDriveY = bEnableDriveY;
	Parms.bEnableDriveZ = bEnableDriveZ;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InPosTarget                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearPositionTarget(const struct FVector& InPosTarget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearPositionTarget");

	Params::PhysicsConstraintComponent_SetLinearPositionTarget Parms{};

	Parms.InPosTarget = std::move(InPosTarget);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableDriveX                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveY                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableDriveZ                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearVelocityDrive");

	Params::PhysicsConstraintComponent_SetLinearVelocityDrive Parms{};

	Parms.bEnableDriveX = bEnableDriveX;
	Parms.bEnableDriveY = bEnableDriveY;
	Parms.bEnableDriveZ = bEnableDriveZ;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InVelTarget                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearVelocityTarget(const struct FVector& InVelTarget)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearVelocityTarget");

	Params::PhysicsConstraintComponent_SetLinearVelocityTarget Parms{};

	Parms.InVelTarget = std::move(InVelTarget);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearXLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinearConstraintMotion                 ConstraintType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LimitSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearXLimit(ELinearConstraintMotion ConstraintType, float LimitSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearXLimit");

	Params::PhysicsConstraintComponent_SetLinearXLimit Parms{};

	Parms.ConstraintType = ConstraintType;
	Parms.LimitSize = LimitSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearYLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinearConstraintMotion                 ConstraintType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LimitSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearYLimit(ELinearConstraintMotion ConstraintType, float LimitSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearYLimit");

	Params::PhysicsConstraintComponent_SetLinearYLimit Parms{};

	Parms.ConstraintType = ConstraintType;
	Parms.LimitSize = LimitSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetLinearZLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinearConstraintMotion                 ConstraintType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LimitSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetLinearZLimit(ELinearConstraintMotion ConstraintType, float LimitSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearZLimit");

	Params::PhysicsConstraintComponent_SetLinearZLimit Parms{};

	Parms.ConstraintType = ConstraintType;
	Parms.LimitSize = LimitSize;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetOrientationDriveSLERP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableSLERP                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetOrientationDriveSLERP(bool bEnableSLERP)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOrientationDriveSLERP");

	Params::PhysicsConstraintComponent_SetOrientationDriveSLERP Parms{};

	Parms.bEnableSLERP = bEnableSLERP;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.SetOrientationDriveTwistAndSwing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableTwistDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableSwingDrive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsConstraintComponent::SetOrientationDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOrientationDriveTwistAndSwing");

	Params::PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing Parms{};

	Parms.bEnableTwistDrive = bEnableTwistDrive;
	Parms.bEnableSwingDrive = bEnableSwingDrive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsConstraintComponent.GetCurrentSwing1
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhysicsConstraintComponent::GetCurrentSwing1() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentSwing1");

	Params::PhysicsConstraintComponent_GetCurrentSwing1 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsConstraintComponent.GetCurrentSwing2
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhysicsConstraintComponent::GetCurrentSwing2() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentSwing2");

	Params::PhysicsConstraintComponent_GetCurrentSwing2 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsConstraintComponent.GetCurrentTwist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPhysicsConstraintComponent::GetCurrentTwist() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetCurrentTwist");

	Params::PhysicsConstraintComponent_GetCurrentTwist Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.AddAttribute
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationAttributeIdentifier    AttributeIdentifier                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::AddAttribute(const struct FAnimationAttributeIdentifier& AttributeIdentifier, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAttribute");

	Params::AnimationDataController_AddAttribute Parms{};

	Parms.AttributeIdentifier = std::move(AttributeIdentifier);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.AddBoneTrack
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IAnimationDataController::AddBoneTrack(class FName BoneName, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddBoneTrack");

	Params::AnimationDataController_AddBoneTrack Parms{};

	Parms.BoneName = BoneName;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.AddCurve
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   CurveFlags                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::AddCurve(const struct FAnimationCurveIdentifier& CurveId, int32 CurveFlags, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddCurve");

	Params::AnimationDataController_AddCurve Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.CurveFlags = CurveFlags;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.CloseBracket
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::CloseBracket(bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CloseBracket");

	Params::AnimationDataController_CloseBracket Parms{};

	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.DuplicateAttribute
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationAttributeIdentifier    AttributeIdentifier                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationAttributeIdentifier    NewAttributeIdentifier                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::DuplicateAttribute(const struct FAnimationAttributeIdentifier& AttributeIdentifier, const struct FAnimationAttributeIdentifier& NewAttributeIdentifier, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DuplicateAttribute");

	Params::AnimationDataController_DuplicateAttribute Parms{};

	Parms.AttributeIdentifier = std::move(AttributeIdentifier);
	Parms.NewAttributeIdentifier = std::move(NewAttributeIdentifier);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.DuplicateCurve
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CopyCurveId                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAnimationCurveIdentifier        NewCurveId                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::DuplicateCurve(const struct FAnimationCurveIdentifier& CopyCurveId, const struct FAnimationCurveIdentifier& NewCurveId, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DuplicateCurve");

	Params::AnimationDataController_DuplicateCurve Parms{};

	Parms.CopyCurveId = std::move(CopyCurveId);
	Parms.NewCurveId = std::move(NewCurveId);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.FindOrAddCurveNamesOnSkeleton
// (Native, Public, BlueprintCallable)
// Parameters:
// class USkeleton*                        Skeleton                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERawCurveTrackTypes                     SupportedCurveType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::FindOrAddCurveNamesOnSkeleton(class USkeleton* Skeleton, ERawCurveTrackTypes SupportedCurveType, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindOrAddCurveNamesOnSkeleton");

	Params::AnimationDataController_FindOrAddCurveNamesOnSkeleton Parms{};

	Parms.Skeleton = Skeleton;
	Parms.SupportedCurveType = SupportedCurveType;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.GetModel
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimDataModel*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimDataModel* IAnimationDataController::GetModel()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetModel");

	Params::AnimationDataController_GetModel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.InsertBoneTrack
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DesiredIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IAnimationDataController::InsertBoneTrack(class FName BoneName, int32 DesiredIndex, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InsertBoneTrack");

	Params::AnimationDataController_InsertBoneTrack Parms{};

	Parms.BoneName = BoneName;
	Parms.DesiredIndex = DesiredIndex;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.OpenBracket
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InTitle                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::OpenBracket(const class FText& InTitle, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OpenBracket");

	Params::AnimationDataController_OpenBracket Parms{};

	Parms.InTitle = std::move(InTitle);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.RemoveAllAttributes
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IAnimationDataController::RemoveAllAttributes(bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAllAttributes");

	Params::AnimationDataController_RemoveAllAttributes Parms{};

	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.RemoveAllAttributesForBone
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IAnimationDataController::RemoveAllAttributesForBone(const class FName& BoneName, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAllAttributesForBone");

	Params::AnimationDataController_RemoveAllAttributesForBone Parms{};

	Parms.BoneName = BoneName;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.RemoveAllBoneTracks
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::RemoveAllBoneTracks(bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAllBoneTracks");

	Params::AnimationDataController_RemoveAllBoneTracks Parms{};

	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.RemoveAllCurvesOfType
// (Native, Public, BlueprintCallable)
// Parameters:
// ERawCurveTrackTypes                     SupportedCurveType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::RemoveAllCurvesOfType(ERawCurveTrackTypes SupportedCurveType, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAllCurvesOfType");

	Params::AnimationDataController_RemoveAllCurvesOfType Parms{};

	Parms.SupportedCurveType = SupportedCurveType;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.RemoveAttribute
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationAttributeIdentifier    AttributeIdentifier                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::RemoveAttribute(const struct FAnimationAttributeIdentifier& AttributeIdentifier, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAttribute");

	Params::AnimationDataController_RemoveAttribute Parms{};

	Parms.AttributeIdentifier = std::move(AttributeIdentifier);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.RemoveAttributeKey
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationAttributeIdentifier    AttributeIdentifier                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::RemoveAttributeKey(const struct FAnimationAttributeIdentifier& AttributeIdentifier, float Time, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAttributeKey");

	Params::AnimationDataController_RemoveAttributeKey Parms{};

	Parms.AttributeIdentifier = std::move(AttributeIdentifier);
	Parms.Time = Time;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.RemoveBoneTrack
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::RemoveBoneTrack(class FName BoneName, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveBoneTrack");

	Params::AnimationDataController_RemoveBoneTrack Parms{};

	Parms.BoneName = BoneName;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.RemoveCurve
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::RemoveCurve(const struct FAnimationCurveIdentifier& CurveId, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveCurve");

	Params::AnimationDataController_RemoveCurve Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.RemoveCurveKey
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::RemoveCurveKey(const struct FAnimationCurveIdentifier& CurveId, float Time, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveCurveKey");

	Params::AnimationDataController_RemoveCurveKey Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.Time = Time;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.RemoveTransformCurveKey
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::RemoveTransformCurveKey(const struct FAnimationCurveIdentifier& CurveId, float Time, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveTransformCurveKey");

	Params::AnimationDataController_RemoveTransformCurveKey Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.Time = Time;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.RenameCurve
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveToRenameId                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FAnimationCurveIdentifier        NewCurveId                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::RenameCurve(const struct FAnimationCurveIdentifier& CurveToRenameId, const struct FAnimationCurveIdentifier& NewCurveId, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RenameCurve");

	Params::AnimationDataController_RenameCurve Parms{};

	Parms.CurveToRenameId = std::move(CurveToRenameId);
	Parms.NewCurveId = std::move(NewCurveId);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.Resize
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   T0                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   T1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::Resize(float Length, float T0, float T1, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Resize");

	Params::AnimationDataController_Resize Parms{};

	Parms.Length = Length;
	Parms.T0 = T0;
	Parms.T1 = T1;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.ResizePlayLength
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   T0                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   T1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::ResizePlayLength(float NewLength, float T0, float T1, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResizePlayLength");

	Params::AnimationDataController_ResizePlayLength Parms{};

	Parms.NewLength = NewLength;
	Parms.T0 = T0;
	Parms.T1 = T1;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.ScaleCurve
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Factor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::ScaleCurve(const struct FAnimationCurveIdentifier& CurveId, float Origin, float Factor, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ScaleCurve");

	Params::AnimationDataController_ScaleCurve Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.Origin = Origin;
	Parms.Factor = Factor;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.SetBoneTrackKeys
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PositionalKeys                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FQuat>                    RotationalKeys                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ScalingKeys                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::SetBoneTrackKeys(class FName BoneName, const TArray<struct FVector>& PositionalKeys, const TArray<struct FQuat>& RotationalKeys, const TArray<struct FVector>& ScalingKeys, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoneTrackKeys");

	Params::AnimationDataController_SetBoneTrackKeys Parms{};

	Parms.BoneName = BoneName;
	Parms.PositionalKeys = std::move(PositionalKeys);
	Parms.RotationalKeys = std::move(RotationalKeys);
	Parms.ScalingKeys = std::move(ScalingKeys);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.SetCurveColor
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::SetCurveColor(const struct FAnimationCurveIdentifier& CurveId, const struct FLinearColor& Color, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCurveColor");

	Params::AnimationDataController_SetCurveColor Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.Color = std::move(Color);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.SetCurveFlag
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAnimAssetCurveFlags                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::SetCurveFlag(const struct FAnimationCurveIdentifier& CurveId, EAnimAssetCurveFlags Flag, bool bState, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCurveFlag");

	Params::AnimationDataController_SetCurveFlag Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.Flag = Flag;
	Parms.bState = bState;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.SetCurveFlags
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::SetCurveFlags(const struct FAnimationCurveIdentifier& CurveId, int32 Flags_0, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCurveFlags");

	Params::AnimationDataController_SetCurveFlags Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.Flags_0 = Flags_0;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.SetCurveKey
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRichCurveKey                    Key                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::SetCurveKey(const struct FAnimationCurveIdentifier& CurveId, const struct FRichCurveKey& Key, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCurveKey");

	Params::AnimationDataController_SetCurveKey Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.Key = std::move(Key);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.SetCurveKeys
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FRichCurveKey>            CurveKeys                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::SetCurveKeys(const struct FAnimationCurveIdentifier& CurveId, const TArray<struct FRichCurveKey>& CurveKeys, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCurveKeys");

	Params::AnimationDataController_SetCurveKeys Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.CurveKeys = std::move(CurveKeys);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.SetFrameRate
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FFrameRate                       FrameRate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::SetFrameRate(const struct FFrameRate& FrameRate, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFrameRate");

	Params::AnimationDataController_SetFrameRate Parms{};

	Parms.FrameRate = std::move(FrameRate);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.SetModel
// (Native, Public, BlueprintCallable)
// Parameters:
// class UAnimDataModel*                   InModel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::SetModel(class UAnimDataModel* InModel)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetModel");

	Params::AnimationDataController_SetModel Parms{};

	Parms.InModel = InModel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.SetPlayLength
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::SetPlayLength(float Length, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlayLength");

	Params::AnimationDataController_SetPlayLength Parms{};

	Parms.Length = Length;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.AnimationDataController.SetTransformCurveKey
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::SetTransformCurveKey(const struct FAnimationCurveIdentifier& CurveId, float Time, const struct FTransform& Value, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTransformCurveKey");

	Params::AnimationDataController_SetTransformCurveKey Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.Time = Time;
	Parms.Value = std::move(Value);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.SetTransformCurveKeys
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAnimationCurveIdentifier        CurveId                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               TransformValues                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           TimeKeys                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAnimationDataController::SetTransformCurveKeys(const struct FAnimationCurveIdentifier& CurveId, const TArray<struct FTransform>& TransformValues, const TArray<float>& TimeKeys, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTransformCurveKeys");

	Params::AnimationDataController_SetTransformCurveKeys Parms{};

	Parms.CurveId = std::move(CurveId);
	Parms.TransformValues = std::move(TransformValues);
	Parms.TimeKeys = std::move(TimeKeys);
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.AnimationDataController.UpdateCurveNamesFromSkeleton
// (Native, Public, BlueprintCallable)
// Parameters:
// class USkeleton*                        Skeleton                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERawCurveTrackTypes                     SupportedCurveType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldTransact                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationDataController::UpdateCurveNamesFromSkeleton(const class USkeleton* Skeleton, ERawCurveTrackTypes SupportedCurveType, bool bShouldTransact)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("UpdateCurveNamesFromSkeleton");

	Params::AnimationDataController_UpdateCurveNamesFromSkeleton Parms{};

	Parms.Skeleton = Skeleton;
	Parms.SupportedCurveType = SupportedCurveType;
	Parms.bShouldTransact = bShouldTransact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ImportanceSamplingLibrary.BreakImportanceTexture
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FImportanceTexture               ImportanceTexture                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Texture                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EImportanceWeight                       WeightingFunc                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImportanceSamplingLibrary::BreakImportanceTexture(const struct FImportanceTexture& ImportanceTexture, class UTexture2D** Texture, EImportanceWeight* WeightingFunc)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakImportanceTexture");

	Params::ImportanceSamplingLibrary_BreakImportanceTexture Parms{};

	Parms.ImportanceTexture = std::move(ImportanceTexture);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Texture != nullptr)
		*Texture = Parms.Texture;

	if (WeightingFunc != nullptr)
		*WeightingFunc = Parms.WeightingFunc;
}


// Function Engine.ImportanceSamplingLibrary.ImportanceSample
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FImportanceTexture               Texture                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        Rand                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Samples                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        SamplePosition                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     SampleColor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SampleIntensity                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SampleSize                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImportanceSamplingLibrary::ImportanceSample(const struct FImportanceTexture& Texture, const struct FVector2D& Rand, int32 Samples, float Intensity, struct FVector2D* SamplePosition, struct FLinearColor* SampleColor, float* SampleIntensity, float* SampleSize)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ImportanceSample");

	Params::ImportanceSamplingLibrary_ImportanceSample Parms{};

	Parms.Texture = std::move(Texture);
	Parms.Rand = std::move(Rand);
	Parms.Samples = Samples;
	Parms.Intensity = Intensity;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (SamplePosition != nullptr)
		*SamplePosition = std::move(Parms.SamplePosition);

	if (SampleColor != nullptr)
		*SampleColor = std::move(Parms.SampleColor);

	if (SampleIntensity != nullptr)
		*SampleIntensity = Parms.SampleIntensity;

	if (SampleSize != nullptr)
		*SampleSize = Parms.SampleSize;
}


// Function Engine.ImportanceSamplingLibrary.MakeImportanceTexture
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EImportanceWeight                       WeightingFunc                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FImportanceTexture               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FImportanceTexture UImportanceSamplingLibrary::MakeImportanceTexture(class UTexture2D* Texture, EImportanceWeight WeightingFunc)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeImportanceTexture");

	Params::ImportanceSamplingLibrary_MakeImportanceTexture Parms{};

	Parms.Texture = Texture;
	Parms.WeightingFunc = WeightingFunc;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.NextSobolCell2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumCells                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        PreviousValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UImportanceSamplingLibrary::NextSobolCell2D(int32 Index_0, int32 NumCells, const struct FVector2D& PreviousValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NextSobolCell2D");

	Params::ImportanceSamplingLibrary_NextSobolCell2D Parms{};

	Parms.Index_0 = Index_0;
	Parms.NumCells = NumCells;
	Parms.PreviousValue = std::move(PreviousValue);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.NextSobolCell3D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumCells                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PreviousValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UImportanceSamplingLibrary::NextSobolCell3D(int32 Index_0, int32 NumCells, const struct FVector& PreviousValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NextSobolCell3D");

	Params::ImportanceSamplingLibrary_NextSobolCell3D Parms{};

	Parms.Index_0 = Index_0;
	Parms.NumCells = NumCells;
	Parms.PreviousValue = std::move(PreviousValue);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.NextSobolFloat
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Dimension                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PreviousValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UImportanceSamplingLibrary::NextSobolFloat(int32 Index_0, int32 Dimension, float PreviousValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NextSobolFloat");

	Params::ImportanceSamplingLibrary_NextSobolFloat Parms{};

	Parms.Index_0 = Index_0;
	Parms.Dimension = Dimension;
	Parms.PreviousValue = PreviousValue;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.RandomSobolCell2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumCells                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Cell                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UImportanceSamplingLibrary::RandomSobolCell2D(int32 Index_0, int32 NumCells, const struct FVector2D& Cell, const struct FVector2D& Seed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomSobolCell2D");

	Params::ImportanceSamplingLibrary_RandomSobolCell2D Parms{};

	Parms.Index_0 = Index_0;
	Parms.NumCells = NumCells;
	Parms.Cell = std::move(Cell);
	Parms.Seed = std::move(Seed);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.RandomSobolCell3D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumCells                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Cell                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UImportanceSamplingLibrary::RandomSobolCell3D(int32 Index_0, int32 NumCells, const struct FVector& Cell, const struct FVector& Seed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomSobolCell3D");

	Params::ImportanceSamplingLibrary_RandomSobolCell3D Parms{};

	Parms.Index_0 = Index_0;
	Parms.NumCells = NumCells;
	Parms.Cell = std::move(Cell);
	Parms.Seed = std::move(Seed);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.RandomSobolFloat
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Dimension                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UImportanceSamplingLibrary::RandomSobolFloat(int32 Index_0, int32 Dimension, float Seed)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RandomSobolFloat");

	Params::ImportanceSamplingLibrary_RandomSobolFloat Parms{};

	Parms.Index_0 = Index_0;
	Parms.Dimension = Dimension;
	Parms.Seed = Seed;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InputSettings.GetInputSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UInputSettings*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInputSettings* UInputSettings::GetInputSettings()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetInputSettings");

	Params::InputSettings_GetInputSettings Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InputSettings.AddActionMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputActionKeyMapping           KeyMapping                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bForceRebuildKeymaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettings::AddActionMapping(const struct FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddActionMapping");

	Params::InputSettings_AddActionMapping Parms{};

	Parms.KeyMapping = std::move(KeyMapping);
	Parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.InputSettings.AddAxisMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputAxisKeyMapping             KeyMapping                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bForceRebuildKeymaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettings::AddAxisMapping(const struct FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddAxisMapping");

	Params::InputSettings_AddAxisMapping Parms{};

	Parms.KeyMapping = std::move(KeyMapping);
	Parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.InputSettings.ForceRebuildKeymaps
// (Final, Native, Public, BlueprintCallable)

void UInputSettings::ForceRebuildKeymaps()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ForceRebuildKeymaps");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.InputSettings.RemoveActionMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputActionKeyMapping           KeyMapping                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bForceRebuildKeymaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettings::RemoveActionMapping(const struct FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveActionMapping");

	Params::InputSettings_RemoveActionMapping Parms{};

	Parms.KeyMapping = std::move(KeyMapping);
	Parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.InputSettings.RemoveAxisMapping
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputAxisKeyMapping             KeyMapping                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bForceRebuildKeymaps                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettings::RemoveAxisMapping(const struct FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveAxisMapping");

	Params::InputSettings_RemoveAxisMapping Parms{};

	Parms.KeyMapping = std::move(KeyMapping);
	Parms.bForceRebuildKeymaps = bForceRebuildKeymaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.InputSettings.SaveKeyMappings
// (Final, Native, Public, BlueprintCallable)

void UInputSettings::SaveKeyMappings()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SaveKeyMappings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.InputSettings.GetActionMappingByName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InActionName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputActionKeyMapping>   OutMappings                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInputSettings::GetActionMappingByName(const class FName InActionName, TArray<struct FInputActionKeyMapping>* OutMappings) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActionMappingByName");

	Params::InputSettings_GetActionMappingByName Parms{};

	Parms.InActionName = InActionName;

	UObject::ProcessEvent(Func, &Parms);

	if (OutMappings != nullptr)
		*OutMappings = std::move(Parms.OutMappings);
}


// Function Engine.InputSettings.GetActionNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ActionNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInputSettings::GetActionNames(TArray<class FName>* ActionNames) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActionNames");

	Params::InputSettings_GetActionNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ActionNames != nullptr)
		*ActionNames = std::move(Parms.ActionNames);
}


// Function Engine.InputSettings.GetAxisMappingByName
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InAxisName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInputAxisKeyMapping>     OutMappings                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInputSettings::GetAxisMappingByName(const class FName InAxisName, TArray<struct FInputAxisKeyMapping>* OutMappings) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAxisMappingByName");

	Params::InputSettings_GetAxisMappingByName Parms{};

	Parms.InAxisName = InAxisName;

	UObject::ProcessEvent(Func, &Parms);

	if (OutMappings != nullptr)
		*OutMappings = std::move(Parms.OutMappings);
}


// Function Engine.InputSettings.GetAxisNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     AxisNames                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UInputSettings::GetAxisNames(TArray<class FName>* AxisNames) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAxisNames");

	Params::InputSettings_GetAxisNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AxisNames != nullptr)
		*AxisNames = std::move(Parms.AxisNames);
}


// Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkelComp                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkeletalMeshSocket::InitializeSocketFromLocation(const class USkeletalMeshComponent* SkelComp, const struct FVector& WorldLocation, const struct FVector& WorldNormal)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InitializeSocketFromLocation");

	Params::SkeletalMeshSocket_InitializeSocketFromLocation Parms{};

	Parms.SkelComp = SkelComp;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.WorldNormal = std::move(WorldNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkeletalMeshSocket.GetSocketLocation
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           SkelComp                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USkeletalMeshSocket::GetSocketLocation(const class USkeletalMeshComponent* SkelComp) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetSocketLocation");

	Params::SkeletalMeshSocket_GetSocketLocation Parms{};

	Parms.SkelComp = SkelComp;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.InterpToMovementComponent.AddControlPointPosition
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPositionIsRelative                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::AddControlPointPosition(const struct FVector& Pos, bool bPositionIsRelative)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddControlPointPosition");

	Params::InterpToMovementComponent_AddControlPointPosition Parms{};

	Parms.Pos = std::move(Pos);
	Parms.bPositionIsRelative = bPositionIsRelative;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.InterpToMovementComponent.FinaliseControlPoints
// (Final, Native, Public, BlueprintCallable)

void UInterpToMovementComponent::FinaliseControlPoints()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FinaliseControlPoints");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.InterpToMovementComponent.ResetControlPoints
// (Final, Native, Public, BlueprintCallable)

void UInterpToMovementComponent::ResetControlPoints()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetControlPoints");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.InterpToMovementComponent.RestartMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InitialDirection                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::RestartMovement(float InitialDirection)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RestartMovement");

	Params::InterpToMovementComponent_RestartMovement Parms{};

	Parms.InitialDirection = InitialDirection;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.InterpToMovementComponent.StopSimulating
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInterpToMovementComponent::StopSimulating(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopSimulating");

	Params::InterpToMovementComponent_StopSimulating Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_Add
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   NewItem                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_Add(const TArray<int32>& TargetArray, const int32& NewItem)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Add");

	Params::KismetArrayLibrary_Array_Add Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.NewItem = NewItem;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_AddUnique
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   NewItem                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_AddUnique(const TArray<int32>& TargetArray, const int32& NewItem)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_AddUnique");

	Params::KismetArrayLibrary_Array_AddUnique Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.NewItem = NewItem;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Append
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           SourceArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Append(const TArray<int32>& TargetArray, const TArray<int32>& SourceArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Append");

	Params::KismetArrayLibrary_Array_Append Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.SourceArray = std::move(SourceArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_Clear
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Clear(const TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Clear");

	Params::KismetArrayLibrary_Array_Clear Parms{};

	Parms.TargetArray = std::move(TargetArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_Contains
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ItemToFind                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_Contains(const TArray<int32>& TargetArray, const int32& ItemToFind)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Contains");

	Params::KismetArrayLibrary_Array_Contains Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.ItemToFind = ItemToFind;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Find
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ItemToFind                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_Find(const TArray<int32>& TargetArray, const int32& ItemToFind)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Find");

	Params::KismetArrayLibrary_Array_Find Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.ItemToFind = ItemToFind;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Get
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Item                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Get(const TArray<int32>& TargetArray, int32 Index_0, int32* Item)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Get");

	Params::KismetArrayLibrary_Array_Get Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Item != nullptr)
		*Item = Parms.Item;
}


// Function Engine.KismetArrayLibrary.Array_Identical
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           ArrayA                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           ArrayB                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_Identical(const TArray<int32>& ArrayA, const TArray<int32>& ArrayB)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Identical");

	Params::KismetArrayLibrary_Array_Identical Parms{};

	Parms.ArrayA = std::move(ArrayA);
	Parms.ArrayB = std::move(ArrayB);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Insert
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   NewItem                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Insert(const TArray<int32>& TargetArray, const int32& NewItem, int32 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Insert");

	Params::KismetArrayLibrary_Array_Insert Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.NewItem = NewItem;
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_IsEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_IsEmpty(const TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_IsEmpty");

	Params::KismetArrayLibrary_Array_IsEmpty Parms{};

	Parms.TargetArray = std::move(TargetArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_IsNotEmpty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_IsNotEmpty(const TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_IsNotEmpty");

	Params::KismetArrayLibrary_Array_IsNotEmpty Parms{};

	Parms.TargetArray = std::move(TargetArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_IsValidIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   IndexToTest                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_IsValidIndex(const TArray<int32>& TargetArray, int32 IndexToTest)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_IsValidIndex");

	Params::KismetArrayLibrary_Array_IsValidIndex Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.IndexToTest = IndexToTest;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_LastIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_LastIndex(const TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_LastIndex");

	Params::KismetArrayLibrary_Array_LastIndex Parms{};

	Parms.TargetArray = std::move(TargetArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Length
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetArrayLibrary::Array_Length(const TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Length");

	Params::KismetArrayLibrary_Array_Length Parms{};

	Parms.TargetArray = std::move(TargetArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Random
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   OutItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Random(const TArray<int32>& TargetArray, int32* OutItem, int32* OutIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Random");

	Params::KismetArrayLibrary_Array_Random Parms{};

	Parms.TargetArray = std::move(TargetArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutItem != nullptr)
		*OutItem = Parms.OutItem;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;
}


// Function Engine.KismetArrayLibrary.Array_RandomFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRandomStream                    RandomStream                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   OutItem                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutIndex                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_RandomFromStream(const TArray<int32>& TargetArray, struct FRandomStream& RandomStream, int32* OutItem, int32* OutIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_RandomFromStream");

	Params::KismetArrayLibrary_Array_RandomFromStream Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.RandomStream = std::move(RandomStream);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	RandomStream = std::move(Parms.RandomStream);

	if (OutItem != nullptr)
		*OutItem = Parms.OutItem;

	if (OutIndex != nullptr)
		*OutIndex = Parms.OutIndex;
}


// Function Engine.KismetArrayLibrary.Array_Remove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   IndexToRemove                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Remove(const TArray<int32>& TargetArray, int32 IndexToRemove)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Remove");

	Params::KismetArrayLibrary_Array_Remove Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.IndexToRemove = IndexToRemove;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_RemoveItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Item                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetArrayLibrary::Array_RemoveItem(const TArray<int32>& TargetArray, const int32& Item)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_RemoveItem");

	Params::KismetArrayLibrary_Array_RemoveItem Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.Item = Item;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Resize
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Resize(const TArray<int32>& TargetArray, int32 Size)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Resize");

	Params::KismetArrayLibrary_Array_Resize Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.Size = Size;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_Reverse
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Reverse(const TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Reverse");

	Params::KismetArrayLibrary_Array_Reverse Parms{};

	Parms.TargetArray = std::move(TargetArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_Set
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Item                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSizeToFit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Set(const TArray<int32>& TargetArray, int32 Index_0, const int32& Item, bool bSizeToFit)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Set");

	Params::KismetArrayLibrary_Array_Set Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.Index_0 = Index_0;
	Parms.Item = Item;
	Parms.bSizeToFit = bSizeToFit;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_Shuffle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Shuffle(const TArray<int32>& TargetArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Shuffle");

	Params::KismetArrayLibrary_Array_Shuffle Parms{};

	Parms.TargetArray = std::move(TargetArray);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.Array_Swap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   FirstIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::Array_Swap(const TArray<int32>& TargetArray, int32 FirstIndex, int32 SecondIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Array_Swap");

	Params::KismetArrayLibrary_Array_Swap Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.FirstIndex = FirstIndex;
	Parms.SecondIndex = SecondIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetArrayLibrary.FilterArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               FilterClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   FilteredArray                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::FilterArray(const TArray<class AActor*>& TargetArray, TSubclassOf<class AActor> FilterClass, TArray<class AActor*>* FilteredArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FilterArray");

	Params::KismetArrayLibrary_FilterArray Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.FilterClass = FilterClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (FilteredArray != nullptr)
		*FilteredArray = std::move(Parms.FilteredArray);
}


// Function Engine.KismetArrayLibrary.SetArrayPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetArrayLibrary::SetArrayPropertyByName(class UObject* Object, class FName PropertyName, const TArray<int32>& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetArrayPropertyByName");

	Params::KismetArrayLibrary_SetArrayPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetInputLibrary.CalibrateTilt
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetInputLibrary::CalibrateTilt()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CalibrateTilt");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.KismetInputLibrary.EqualEqual_InputChordInputChord
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputChord                      A                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputChord                      B                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::EqualEqual_InputChordInputChord(const struct FInputChord& A, const struct FInputChord& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_InputChordInputChord");

	Params::KismetInputLibrary_EqualEqual_InputChordInputChord Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.EqualEqual_KeyKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             A                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             B                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::EqualEqual_KeyKey(const struct FKey& A, const struct FKey& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_KeyKey");

	Params::KismetInputLibrary_EqualEqual_KeyKey Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.GetAnalogValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnalogInputEvent                Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetInputLibrary::GetAnalogValue(const struct FAnalogInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAnalogValue");

	Params::KismetInputLibrary_GetAnalogValue Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.GetKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyEvent                        Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UKismetInputLibrary::GetKey(const struct FKeyEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetKey");

	Params::KismetInputLibrary_GetKey Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.GetUserIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyEvent                        Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetInputLibrary::GetUserIndex(const struct FKeyEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetUserIndex");

	Params::KismetInputLibrary_GetUserIndex Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputChord_GetDisplayName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputChord                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetInputLibrary::InputChord_GetDisplayName(const struct FInputChord& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputChord_GetDisplayName");

	Params::KismetInputLibrary_InputChord_GetDisplayName Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsAltDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsAltDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsAltDown");

	Params::KismetInputLibrary_InputEvent_IsAltDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsCommandDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsCommandDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsCommandDown");

	Params::KismetInputLibrary_InputEvent_IsCommandDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsControlDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsControlDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsControlDown");

	Params::KismetInputLibrary_InputEvent_IsControlDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsLeftAltDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsLeftAltDown");

	Params::KismetInputLibrary_InputEvent_IsLeftAltDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsLeftCommandDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsLeftCommandDown");

	Params::KismetInputLibrary_InputEvent_IsLeftCommandDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsLeftControlDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsLeftControlDown");

	Params::KismetInputLibrary_InputEvent_IsLeftControlDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsLeftShiftDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsLeftShiftDown");

	Params::KismetInputLibrary_InputEvent_IsLeftShiftDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRepeat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRepeat(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsRepeat");

	Params::KismetInputLibrary_InputEvent_IsRepeat Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRightAltDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsRightAltDown");

	Params::KismetInputLibrary_InputEvent_IsRightAltDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRightCommandDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsRightCommandDown");

	Params::KismetInputLibrary_InputEvent_IsRightCommandDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRightControlDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsRightControlDown");

	Params::KismetInputLibrary_InputEvent_IsRightControlDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsRightShiftDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsRightShiftDown");

	Params::KismetInputLibrary_InputEvent_IsRightShiftDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsShiftDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputEvent                      Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::InputEvent_IsShiftDown(const struct FInputEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("InputEvent_IsShiftDown");

	Params::KismetInputLibrary_InputEvent_IsShiftDown Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetDisplayName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetInputLibrary::Key_GetDisplayName(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_GetDisplayName");

	Params::KismetInputLibrary_Key_GetDisplayName Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetNavigationAction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUINavigationAction                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUINavigationAction UKismetInputLibrary::Key_GetNavigationAction(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_GetNavigationAction");

	Params::KismetInputLibrary_Key_GetNavigationAction Parms{};

	Parms.InKey = std::move(InKey);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetNavigationActionFromKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyEvent                        InKeyEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EUINavigationAction                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUINavigationAction UKismetInputLibrary::Key_GetNavigationActionFromKey(const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_GetNavigationActionFromKey");

	Params::KismetInputLibrary_Key_GetNavigationActionFromKey Parms{};

	Parms.InKeyEvent = std::move(InKeyEvent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromAnalog
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAnalogInputEvent                InAnalogEvent                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EUINavigation                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUINavigation UKismetInputLibrary::Key_GetNavigationDirectionFromAnalog(const struct FAnalogInputEvent& InAnalogEvent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_GetNavigationDirectionFromAnalog");

	Params::KismetInputLibrary_Key_GetNavigationDirectionFromAnalog Parms{};

	Parms.InAnalogEvent = std::move(InAnalogEvent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKeyEvent                        InKeyEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EUINavigation                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUINavigation UKismetInputLibrary::Key_GetNavigationDirectionFromKey(const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_GetNavigationDirectionFromKey");

	Params::KismetInputLibrary_Key_GetNavigationDirectionFromKey Parms{};

	Parms.InKeyEvent = std::move(InKeyEvent);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsAnalog
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsAnalog(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsAnalog");

	Params::KismetInputLibrary_Key_IsAnalog Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsAxis1D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsAxis1D(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsAxis1D");

	Params::KismetInputLibrary_Key_IsAxis1D Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsAxis2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsAxis2D(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsAxis2D");

	Params::KismetInputLibrary_Key_IsAxis2D Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsAxis3D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsAxis3D(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsAxis3D");

	Params::KismetInputLibrary_Key_IsAxis3D Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsButtonAxis
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsButtonAxis(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsButtonAxis");

	Params::KismetInputLibrary_Key_IsButtonAxis Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsDigital
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsDigital(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsDigital");

	Params::KismetInputLibrary_Key_IsDigital Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsGamepadKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsGamepadKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsGamepadKey");

	Params::KismetInputLibrary_Key_IsGamepadKey Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsKeyboardKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsKeyboardKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsKeyboardKey");

	Params::KismetInputLibrary_Key_IsKeyboardKey Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsModifierKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsModifierKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsModifierKey");

	Params::KismetInputLibrary_Key_IsModifierKey Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsMouseButton
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsMouseButton(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsMouseButton");

	Params::KismetInputLibrary_Key_IsMouseButton Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsValid(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsValid");

	Params::KismetInputLibrary_Key_IsValid Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsVectorAxis
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::Key_IsVectorAxis(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Key_IsVectorAxis");

	Params::KismetInputLibrary_Key_IsVectorAxis Parms{};

	Parms.Key = std::move(Key);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetInputLibrary::PointerEvent_GetCursorDelta(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetCursorDelta");

	Params::KismetInputLibrary_PointerEvent_GetCursorDelta Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey UKismetInputLibrary::PointerEvent_GetEffectingButton(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetEffectingButton");

	Params::KismetInputLibrary_PointerEvent_GetEffectingButton Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetInputLibrary::PointerEvent_GetGestureDelta(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetGestureDelta");

	Params::KismetInputLibrary_PointerEvent_GetGestureDelta Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetGestureType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ESlateGesture                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateGesture UKismetInputLibrary::PointerEvent_GetGestureType(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetGestureType");

	Params::KismetInputLibrary_PointerEvent_GetGestureType Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetInputLibrary::PointerEvent_GetLastScreenSpacePosition(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetLastScreenSpacePosition");

	Params::KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetInputLibrary::PointerEvent_GetPointerIndex(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetPointerIndex");

	Params::KismetInputLibrary_PointerEvent_GetPointerIndex Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKismetInputLibrary::PointerEvent_GetScreenSpacePosition(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetScreenSpacePosition");

	Params::KismetInputLibrary_PointerEvent_GetScreenSpacePosition Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetInputLibrary::PointerEvent_GetTouchpadIndex(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetTouchpadIndex");

	Params::KismetInputLibrary_PointerEvent_GetTouchpadIndex Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetInputLibrary::PointerEvent_GetUserIndex(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetUserIndex");

	Params::KismetInputLibrary_PointerEvent_GetUserIndex Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetInputLibrary::PointerEvent_GetWheelDelta(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_GetWheelDelta");

	Params::KismetInputLibrary_PointerEvent_GetWheelDelta Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FKey                             MouseButton                                            (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::PointerEvent_IsMouseButtonDown(const struct FPointerEvent& Input, const struct FKey& MouseButton)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_IsMouseButtonDown");

	Params::KismetInputLibrary_PointerEvent_IsMouseButtonDown Parms{};

	Parms.Input = std::move(Input);
	Parms.MouseButton = std::move(MouseButton);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPointerEvent                    Input                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetInputLibrary::PointerEvent_IsTouchEvent(const struct FPointerEvent& Input)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PointerEvent_IsTouchEvent");

	Params::KismetInputLibrary_PointerEvent_IsTouchEvent Parms{};

	Parms.Input = std::move(Input);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Bool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InBool                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Bool(const class FString& AppendTo, const class FString& Prefix, bool InBool, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Bool");

	Params::KismetStringLibrary_BuildString_Bool Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InBool = InBool;
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Color
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Color(const class FString& AppendTo, const class FString& Prefix, const struct FLinearColor& InColor, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Color");

	Params::KismetStringLibrary_BuildString_Color Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InColor = std::move(InColor);
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Float(const class FString& AppendTo, const class FString& Prefix, float InFloat, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Float");

	Params::KismetStringLibrary_BuildString_Float Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InFloat = InFloat;
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Int(const class FString& AppendTo, const class FString& Prefix, int32 inInt, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Int");

	Params::KismetStringLibrary_BuildString_Int Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.inInt = inInt;
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_IntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       InIntVector                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_IntVector(const class FString& AppendTo, const class FString& Prefix, const struct FIntVector& InIntVector, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_IntVector");

	Params::KismetStringLibrary_BuildString_IntVector Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InIntVector = std::move(InIntVector);
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Name
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Name(const class FString& AppendTo, const class FString& Prefix, class FName InName, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Name");

	Params::KismetStringLibrary_BuildString_Name Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InName = InName;
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Object
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObj                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Object(const class FString& AppendTo, const class FString& Prefix, class UObject* InObj, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Object");

	Params::KismetStringLibrary_BuildString_Object Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InObj = InObj;
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Rotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Rotator(const class FString& AppendTo, const class FString& Prefix, const struct FRotator& InRot, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Rotator");

	Params::KismetStringLibrary_BuildString_Rotator Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InRot = std::move(InRot);
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Vector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Vector(const class FString& AppendTo, const class FString& Prefix, const struct FVector& InVector, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Vector");

	Params::KismetStringLibrary_BuildString_Vector Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InVector = std::move(InVector);
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Vector2d
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AppendTo                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InVector2D                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::BuildString_Vector2d(const class FString& AppendTo, const class FString& Prefix, const struct FVector2D& InVector2D, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BuildString_Vector2d");

	Params::KismetStringLibrary_BuildString_Vector2d Parms{};

	Parms.AppendTo = std::move(AppendTo);
	Parms.Prefix = std::move(Prefix);
	Parms.InVector2D = std::move(InVector2D);
	Parms.Suffix = std::move(Suffix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Concat_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Concat_StrStr(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Concat_StrStr");

	Params::KismetStringLibrary_Concat_StrStr Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Contains
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SearchIn                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Substring                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSearchFromEnd                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::Contains(const class FString& SearchIn, const class FString& Substring, bool bUseCase, bool bSearchFromEnd)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Contains");

	Params::KismetStringLibrary_Contains Parms{};

	Parms.SearchIn = std::move(SearchIn);
	Parms.Substring = std::move(Substring);
	Parms.bUseCase = bUseCase;
	Parms.bSearchFromEnd = bSearchFromEnd;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_BoolToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    InBool                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_BoolToString(bool InBool)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_BoolToString");

	Params::KismetStringLibrary_Conv_BoolToString Parms{};

	Parms.InBool = InBool;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_ByteToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   InByte                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_ByteToString(uint8 InByte)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ByteToString");

	Params::KismetStringLibrary_Conv_ByteToString Parms{};

	Parms.InByte = InByte;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_ColorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_ColorToString(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ColorToString");

	Params::KismetStringLibrary_Conv_ColorToString Parms{};

	Parms.InColor = std::move(InColor);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_DoubleToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  InDouble                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_DoubleToString(double InDouble)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_DoubleToString");

	Params::KismetStringLibrary_Conv_DoubleToString Parms{};

	Parms.InDouble = InDouble;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_FloatToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_FloatToString(float InFloat)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_FloatToString");

	Params::KismetStringLibrary_Conv_FloatToString Parms{};

	Parms.InFloat = InFloat;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_Int64ToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_Int64ToString(int64 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Int64ToString");

	Params::KismetStringLibrary_Conv_Int64ToString Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_IntPointToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        InIntPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_IntPointToString(const struct FIntPoint& InIntPoint)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntPointToString");

	Params::KismetStringLibrary_Conv_IntPointToString Parms{};

	Parms.InIntPoint = std::move(InIntPoint);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_IntToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_IntToString(int32 inInt)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntToString");

	Params::KismetStringLibrary_Conv_IntToString Parms{};

	Parms.inInt = inInt;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_IntVectorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       InIntVec                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_IntVectorToString(const struct FIntVector& InIntVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_IntVectorToString");

	Params::KismetStringLibrary_Conv_IntVectorToString Parms{};

	Parms.InIntVec = std::move(InIntVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_MatrixToString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                          InMatrix                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_MatrixToString(const struct FMatrix& InMatrix)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_MatrixToString");

	Params::KismetStringLibrary_Conv_MatrixToString Parms{};

	Parms.InMatrix = std::move(InMatrix);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_NameToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_NameToString(class FName InName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_NameToString");

	Params::KismetStringLibrary_Conv_NameToString Parms{};

	Parms.InName = InName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_ObjectToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          InObj                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_ObjectToString(class UObject* InObj)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ObjectToString");

	Params::KismetStringLibrary_Conv_ObjectToString Parms{};

	Parms.InObj = InObj;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_RotatorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         InRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_RotatorToString(const struct FRotator& InRot)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_RotatorToString");

	Params::KismetStringLibrary_Conv_RotatorToString Parms{};

	Parms.InRot = std::move(InRot);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_StringToColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     OutConvertedColor                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetStringLibrary::Conv_StringToColor(const class FString& InString, struct FLinearColor* OutConvertedColor, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToColor");

	Params::KismetStringLibrary_Conv_StringToColor Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutConvertedColor != nullptr)
		*OutConvertedColor = std::move(Parms.OutConvertedColor);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;
}


// Function Engine.KismetStringLibrary.Conv_StringToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetStringLibrary::Conv_StringToFloat(const class FString& InString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToFloat");

	Params::KismetStringLibrary_Conv_StringToFloat Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_StringToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::Conv_StringToInt(const class FString& InString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToInt");

	Params::KismetStringLibrary_Conv_StringToInt Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_StringToName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKismetStringLibrary::Conv_StringToName(const class FString& InString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToName");

	Params::KismetStringLibrary_Conv_StringToName Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_StringToRotator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         OutConvertedRotator                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetStringLibrary::Conv_StringToRotator(const class FString& InString, struct FRotator* OutConvertedRotator, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToRotator");

	Params::KismetStringLibrary_Conv_StringToRotator Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutConvertedRotator != nullptr)
		*OutConvertedRotator = std::move(Parms.OutConvertedRotator);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;
}


// Function Engine.KismetStringLibrary.Conv_StringToVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutConvertedVector                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetStringLibrary::Conv_StringToVector(const class FString& InString, struct FVector* OutConvertedVector, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToVector");

	Params::KismetStringLibrary_Conv_StringToVector Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutConvertedVector != nullptr)
		*OutConvertedVector = std::move(Parms.OutConvertedVector);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;
}


// Function Engine.KismetStringLibrary.Conv_StringToVector2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutConvertedVector2D                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetStringLibrary::Conv_StringToVector2D(const class FString& InString, struct FVector2D* OutConvertedVector2D, bool* OutIsValid)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_StringToVector2D");

	Params::KismetStringLibrary_Conv_StringToVector2D Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutConvertedVector2D != nullptr)
		*OutConvertedVector2D = std::move(Parms.OutConvertedVector2D);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;
}


// Function Engine.KismetStringLibrary.Conv_TransformToString
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       InTrans                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_TransformToString(const struct FTransform& InTrans)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_TransformToString");

	Params::KismetStringLibrary_Conv_TransformToString Parms{};

	Parms.InTrans = std::move(InTrans);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_Vector2dToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_Vector2dToString(const struct FVector2D& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_Vector2dToString");

	Params::KismetStringLibrary_Conv_Vector2dToString Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_VectorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          InVec                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Conv_VectorToString(const struct FVector& InVec)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_VectorToString");

	Params::KismetStringLibrary_Conv_VectorToString Parms{};

	Parms.InVec = std::move(InVec);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.CullArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   inArray                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::CullArray(const class FString& SourceString, TArray<class FString>* inArray)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CullArray");

	Params::KismetStringLibrary_CullArray Parms{};

	Parms.SourceString = std::move(SourceString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (inArray != nullptr)
		*inArray = std::move(Parms.inArray);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.EndsWith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InSuffix                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchCase                             SearchCase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::EndsWith(const class FString& SourceString, const class FString& InSuffix, ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EndsWith");

	Params::KismetStringLibrary_EndsWith Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.InSuffix = std::move(InSuffix);
	Parms.SearchCase = SearchCase;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.EqualEqual_StriStri
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::EqualEqual_StriStri(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_StriStri");

	Params::KismetStringLibrary_EqualEqual_StriStri Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.EqualEqual_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::EqualEqual_StrStr(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_StrStr");

	Params::KismetStringLibrary_EqualEqual_StrStr Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.FindSubstring
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SearchIn                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Substring                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSearchFromEnd                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::FindSubstring(const class FString& SearchIn, const class FString& Substring, bool bUseCase, bool bSearchFromEnd, int32 StartPosition)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FindSubstring");

	Params::KismetStringLibrary_FindSubstring Parms{};

	Parms.SearchIn = std::move(SearchIn);
	Parms.Substring = std::move(Substring);
	Parms.bUseCase = bUseCase;
	Parms.bSearchFromEnd = bSearchFromEnd;
	Parms.StartPosition = StartPosition;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.GetCharacterArrayFromString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetStringLibrary::GetCharacterArrayFromString(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCharacterArrayFromString");

	Params::KismetStringLibrary_GetCharacterArrayFromString Parms{};

	Parms.SourceString = std::move(SourceString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.GetCharacterAsNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::GetCharacterAsNumber(const class FString& SourceString, int32 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCharacterAsNumber");

	Params::KismetStringLibrary_GetCharacterAsNumber Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.GetSubstring
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::GetSubstring(const class FString& SourceString, int32 StartIndex, int32 Length)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSubstring");

	Params::KismetStringLibrary_GetSubstring Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.StartIndex = StartIndex;
	Parms.Length = Length;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.IsEmpty
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::IsEmpty(const class FString& InString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsEmpty");

	Params::KismetStringLibrary_IsEmpty Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.IsNumeric
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::IsNumeric(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsNumeric");

	Params::KismetStringLibrary_IsNumeric Parms{};

	Parms.SourceString = std::move(SourceString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.JoinStringArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   SourceArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Separator                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::JoinStringArray(const TArray<class FString>& SourceArray, const class FString& Separator)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("JoinStringArray");

	Params::KismetStringLibrary_JoinStringArray Parms{};

	Parms.SourceArray = std::move(SourceArray);
	Parms.Separator = std::move(Separator);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Left
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Left(const class FString& SourceString, int32 Count)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Left");

	Params::KismetStringLibrary_Left Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.Count = Count;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.LeftChop
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::LeftChop(const class FString& SourceString, int32 Count)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LeftChop");

	Params::KismetStringLibrary_LeftChop Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.Count = Count;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.LeftPad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::LeftPad(const class FString& SourceString, int32 ChCount)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LeftPad");

	Params::KismetStringLibrary_LeftPad Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.ChCount = ChCount;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Len
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           S                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::Len(const class FString& S)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Len");

	Params::KismetStringLibrary_Len Parms{};

	Parms.S = std::move(S);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.MatchesWildcard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Wildcard                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchCase                             SearchCase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::MatchesWildcard(const class FString& SourceString, const class FString& Wildcard, ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MatchesWildcard");

	Params::KismetStringLibrary_MatchesWildcard Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.Wildcard = std::move(Wildcard);
	Parms.SearchCase = SearchCase;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Mid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Mid(const class FString& SourceString, int32 Start, int32 Count)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Mid");

	Params::KismetStringLibrary_Mid Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.Start = Start;
	Parms.Count = Count;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.NotEqual_StriStri
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::NotEqual_StriStri(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_StriStri");

	Params::KismetStringLibrary_NotEqual_StriStri Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.NotEqual_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::NotEqual_StrStr(const class FString& A, const class FString& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_StrStr");

	Params::KismetStringLibrary_NotEqual_StrStr Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.ParseIntoArray
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Delimiter                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CullEmptyStrings                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetStringLibrary::ParseIntoArray(const class FString& SourceString, const class FString& Delimiter, const bool CullEmptyStrings)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ParseIntoArray");

	Params::KismetStringLibrary_ParseIntoArray Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.Delimiter = std::move(Delimiter);
	Parms.CullEmptyStrings = CullEmptyStrings;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Replace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           From                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           To                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchCase                             SearchCase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Replace(const class FString& SourceString, const class FString& From, const class FString& To, ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Replace");

	Params::KismetStringLibrary_Replace Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.From = std::move(From);
	Parms.To = std::move(To);
	Parms.SearchCase = SearchCase;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.ReplaceInline
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           SourceString                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SearchText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReplacementText                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchCase                             SearchCase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetStringLibrary::ReplaceInline(class FString& SourceString, const class FString& SearchText, const class FString& ReplacementText, ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ReplaceInline");

	Params::KismetStringLibrary_ReplaceInline Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.SearchText = std::move(SearchText);
	Parms.ReplacementText = std::move(ReplacementText);
	Parms.SearchCase = SearchCase;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	SourceString = std::move(Parms.SourceString);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Reverse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Reverse(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Reverse");

	Params::KismetStringLibrary_Reverse Parms{};

	Parms.SourceString = std::move(SourceString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Right
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Right(const class FString& SourceString, int32 Count)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Right");

	Params::KismetStringLibrary_Right Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.Count = Count;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.RightChop
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::RightChop(const class FString& SourceString, int32 Count)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RightChop");

	Params::KismetStringLibrary_RightChop Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.Count = Count;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.RightPad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::RightPad(const class FString& SourceString, int32 ChCount)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RightPad");

	Params::KismetStringLibrary_RightPad Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.ChCount = ChCount;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Split
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LeftS                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RightS                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchCase                             SearchCase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchDir                              SearchDir                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::Split(const class FString& SourceString, const class FString& InStr, class FString* LeftS, class FString* RightS, ESearchCase SearchCase, ESearchDir SearchDir)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Split");

	Params::KismetStringLibrary_Split Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.InStr = std::move(InStr);
	Parms.SearchCase = SearchCase;
	Parms.SearchDir = SearchDir;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (LeftS != nullptr)
		*LeftS = std::move(Parms.LeftS);

	if (RightS != nullptr)
		*RightS = std::move(Parms.RightS);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.StartsWith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InPrefix                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESearchCase                             SearchCase                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetStringLibrary::StartsWith(const class FString& SourceString, const class FString& InPrefix, ESearchCase SearchCase)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StartsWith");

	Params::KismetStringLibrary_StartsWith Parms{};

	Parms.SourceString = std::move(SourceString);
	Parms.InPrefix = std::move(InPrefix);
	Parms.SearchCase = SearchCase;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.TimeSecondsToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InSeconds                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::TimeSecondsToString(float InSeconds)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TimeSecondsToString");

	Params::KismetStringLibrary_TimeSecondsToString Parms{};

	Parms.InSeconds = InSeconds;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.ToLower
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::ToLower(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ToLower");

	Params::KismetStringLibrary_ToLower Parms{};

	Parms.SourceString = std::move(SourceString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.ToUpper
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::ToUpper(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ToUpper");

	Params::KismetStringLibrary_ToUpper Parms{};

	Parms.SourceString = std::move(SourceString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.Trim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::Trim(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Trim");

	Params::KismetStringLibrary_Trim Parms{};

	Parms.SourceString = std::move(SourceString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetStringLibrary.TrimTrailing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SourceString                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetStringLibrary::TrimTrailing(const class FString& SourceString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TrimTrailing");

	Params::KismetStringLibrary_TrimTrailing Parms{};

	Parms.SourceString = std::move(SourceString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.AddFloatHistorySample
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDebugFloatHistory               FloatHistory                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDebugFloatHistory               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDebugFloatHistory UKismetSystemLibrary::AddFloatHistorySample(float Value, const struct FDebugFloatHistory& FloatHistory)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("AddFloatHistorySample");

	Params::KismetSystemLibrary_AddFloatHistorySample Parms{};

	Parms.Value = Value;
	Parms.FloatHistory = std::move(FloatHistory);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BeginTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Context                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Description                                            (Parm, NativeAccessSpecifierPublic)
// class UObject*                          PrimaryObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::BeginTransaction(const class FString& Context, const class FText& Description, class UObject* PrimaryObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BeginTransaction");

	Params::KismetSystemLibrary_BeginTransaction Parms{};

	Parms.Context = std::move(Context);
	Parms.Description = std::move(Description);
	Parms.PrimaryObject = PrimaryObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxOverlapActors(const class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BoxOverlapActors");

	Params::KismetSystemLibrary_BoxOverlapActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = std::move(BoxPos);
	Parms.BoxExtent = std::move(BoxExtent);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxPos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxOverlapComponents(const class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BoxOverlapComponents");

	Params::KismetSystemLibrary_BoxOverlapComponents Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxPos = std::move(BoxPos);
	Parms.Extent = std::move(Extent);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HalfSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceMulti(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BoxTraceMulti");

	Params::KismetSystemLibrary_BoxTraceMulti Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.HalfSize = std::move(HalfSize);
	Parms.Orientation = std::move(Orientation);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HalfSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceMultiByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BoxTraceMultiByProfile");

	Params::KismetSystemLibrary_BoxTraceMultiByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.HalfSize = std::move(HalfSize);
	Parms.Orientation = std::move(Orientation);
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HalfSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceMultiForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BoxTraceMultiForObjects");

	Params::KismetSystemLibrary_BoxTraceMultiForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.HalfSize = std::move(HalfSize);
	Parms.Orientation = std::move(Orientation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HalfSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceSingle(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BoxTraceSingle");

	Params::KismetSystemLibrary_BoxTraceSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.HalfSize = std::move(HalfSize);
	Parms.Orientation = std::move(Orientation);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HalfSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceSingleByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BoxTraceSingleByProfile");

	Params::KismetSystemLibrary_BoxTraceSingleByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.HalfSize = std::move(HalfSize);
	Parms.Orientation = std::move(Orientation);
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HalfSize                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Orientation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::BoxTraceSingleForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BoxTraceSingleForObjects");

	Params::KismetSystemLibrary_BoxTraceSingleForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.HalfSize = std::move(HalfSize);
	Parms.Orientation = std::move(Orientation);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BreakSoftClassPath
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftClassPath                   InSoftClassPath                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PathString                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::BreakSoftClassPath(const struct FSoftClassPath& InSoftClassPath, class FString* PathString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakSoftClassPath");

	Params::KismetSystemLibrary_BreakSoftClassPath Parms{};

	Parms.InSoftClassPath = std::move(InSoftClassPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PathString != nullptr)
		*PathString = std::move(Parms.PathString);
}


// Function Engine.KismetSystemLibrary.BreakSoftObjectPath
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath                  InSoftObjectPath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PathString                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::BreakSoftObjectPath(const struct FSoftObjectPath& InSoftObjectPath, class FString* PathString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("BreakSoftObjectPath");

	Params::KismetSystemLibrary_BreakSoftObjectPath Parms{};

	Parms.InSoftObjectPath = std::move(InSoftObjectPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (PathString != nullptr)
		*PathString = std::move(Parms.PathString);
}


// Function Engine.KismetSystemLibrary.CancelTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::CancelTransaction(const int32 Index_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CancelTransaction");

	Params::KismetSystemLibrary_CancelTransaction Parms{};

	Parms.Index_0 = Index_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.CanLaunchURL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CanLaunchURL(const class FString& URL)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CanLaunchURL");

	Params::KismetSystemLibrary_CanLaunchURL Parms{};

	Parms.URL = std::move(URL);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsulePos                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleOverlapActors(const class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CapsuleOverlapActors");

	Params::KismetSystemLibrary_CapsuleOverlapActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsulePos = std::move(CapsulePos);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsulePos                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleOverlapComponents(const class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CapsuleOverlapComponents");

	Params::KismetSystemLibrary_CapsuleOverlapComponents Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsulePos = std::move(CapsulePos);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceMulti(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CapsuleTraceMulti");

	Params::KismetSystemLibrary_CapsuleTraceMulti Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceMultiByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CapsuleTraceMultiByProfile");

	Params::KismetSystemLibrary_CapsuleTraceMultiByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceMultiForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CapsuleTraceMultiForObjects");

	Params::KismetSystemLibrary_CapsuleTraceMultiForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceSingle(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CapsuleTraceSingle");

	Params::KismetSystemLibrary_CapsuleTraceSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceSingleByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CapsuleTraceSingleByProfile");

	Params::KismetSystemLibrary_CapsuleTraceSingleByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::CapsuleTraceSingleForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CapsuleTraceSingleForObjects");

	Params::KismetSystemLibrary_CapsuleTraceSingleForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CollectGarbage
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetSystemLibrary::CollectGarbage()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CollectGarbage");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.KismetSystemLibrary.ComponentOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ComponentTransform                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::ComponentOverlapActors(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComponentOverlapActors");

	Params::KismetSystemLibrary_ComponentOverlapActors Parms{};

	Parms.Component = Component;
	Parms.ComponentTransform = std::move(ComponentTransform);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ComponentOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ComponentTransform                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::ComponentOverlapComponents(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ComponentOverlapComponents");

	Params::KismetSystemLibrary_ComponentOverlapComponents Parms{};

	Parms.Component = Component;
	Parms.ComponentTransform = std::move(ComponentTransform);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ControlScreensaver
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowScreenSaver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ControlScreensaver(bool bAllowScreenSaver)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ControlScreensaver");

	Params::KismetSystemLibrary_ControlScreensaver Parms{};

	Parms.bAllowScreenSaver = bAllowScreenSaver;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.Conv_ClassToSoftClassReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>              Class_0                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UKismetSystemLibrary::Conv_ClassToSoftClassReference(const TSubclassOf<class UObject>& Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ClassToSoftClassReference");

	Params::KismetSystemLibrary_Conv_ClassToSoftClassReference Parms{};

	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_InterfaceToObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class IInterface>      Interface                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::Conv_InterfaceToObject(const TScriptInterface<class IInterface>& Interface)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_InterfaceToObject");

	Params::KismetSystemLibrary_Conv_InterfaceToObject Parms{};

	Parms.Interface = Interface;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_ObjectToSoftObjectReference
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UKismetSystemLibrary::Conv_ObjectToSoftObjectReference(class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_ObjectToSoftObjectReference");

	Params::KismetSystemLibrary_Conv_ObjectToSoftObjectReference Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_PrimaryAssetIdToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::Conv_PrimaryAssetIdToString(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_PrimaryAssetIdToString");

	Params::KismetSystemLibrary_Conv_PrimaryAssetIdToString Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_PrimaryAssetTypeToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType                PrimaryAssetType                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::Conv_PrimaryAssetTypeToString(const struct FPrimaryAssetType& PrimaryAssetType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_PrimaryAssetTypeToString");

	Params::KismetSystemLibrary_Conv_PrimaryAssetTypeToString Parms{};

	Parms.PrimaryAssetType = std::move(PrimaryAssetType);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftClassPathToSoftClassRef
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftClassPath                   SoftClassPath                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UKismetSystemLibrary::Conv_SoftClassPathToSoftClassRef(const struct FSoftClassPath& SoftClassPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_SoftClassPathToSoftClassRef");

	Params::KismetSystemLibrary_Conv_SoftClassPathToSoftClassRef Parms{};

	Parms.SoftClassPath = std::move(SoftClassPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             SoftClass                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UObject> UKismetSystemLibrary::Conv_SoftClassReferenceToClass(const TSoftClassPtr<class UClass>& SoftClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_SoftClassReferenceToClass");

	Params::KismetSystemLibrary_Conv_SoftClassReferenceToClass Parms{};

	Parms.SoftClass = SoftClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             SoftClassReference                                     (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::Conv_SoftClassReferenceToString(const TSoftClassPtr<class UClass>& SoftClassReference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_SoftClassReferenceToString");

	Params::KismetSystemLibrary_Conv_SoftClassReferenceToString Parms{};

	Parms.SoftClassReference = SoftClassReference;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToObject
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           SoftObject                                             (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::Conv_SoftObjectReferenceToObject(const TSoftObjectPtr<class UObject>& SoftObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_SoftObjectReferenceToObject");

	Params::KismetSystemLibrary_Conv_SoftObjectReferenceToObject Parms{};

	Parms.SoftObject = SoftObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           SoftObjectReference                                    (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::Conv_SoftObjectReferenceToString(const TSoftObjectPtr<class UObject>& SoftObjectReference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_SoftObjectReferenceToString");

	Params::KismetSystemLibrary_Conv_SoftObjectReferenceToString Parms{};

	Parms.SoftObjectReference = SoftObjectReference;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftObjPathToSoftObjRef
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath                  SoftObjectPath                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UKismetSystemLibrary::Conv_SoftObjPathToSoftObjRef(const struct FSoftObjectPath& SoftObjectPath)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Conv_SoftObjPathToSoftObjRef");

	Params::KismetSystemLibrary_Conv_SoftObjPathToSoftObjRef Parms{};

	Parms.SoftObjectPath = std::move(SoftObjectPath);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ConvertToAbsolutePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::ConvertToAbsolutePath(const class FString& Filename)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertToAbsolutePath");

	Params::KismetSystemLibrary_ConvertToAbsolutePath Parms{};

	Parms.Filename = std::move(Filename);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ConvertToRelativePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::ConvertToRelativePath(const class FString& Filename)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertToRelativePath");

	Params::KismetSystemLibrary_ConvertToRelativePath Parms{};

	Parms.Filename = std::move(Filename);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          ObjectToModify                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::CreateCopyForUndoBuffer(class UObject* ObjectToModify)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateCopyForUndoBuffer");

	Params::KismetSystemLibrary_CreateCopyForUndoBuffer Parms{};

	Parms.ObjectToModify = ObjectToModify;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.Delay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::Delay(const class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("Delay");

	Params::KismetSystemLibrary_Delay Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Duration = Duration;
	Parms.LatentInfo = std::move(LatentInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DelayUntilNextTick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DelayUntilNextTick(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DelayUntilNextTick");

	Params::KismetSystemLibrary_DelayUntilNextTick Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DoesImplementInterface
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          TestObject                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           Interface                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::DoesImplementInterface(const class UObject* TestObject, TSubclassOf<class IInterface> Interface)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DoesImplementInterface");

	Params::KismetSystemLibrary_DoesImplementInterface Parms{};

	Parms.TestObject = TestObject;
	Parms.Interface = Interface;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.DrawDebugArrow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineStart                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineEnd                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArrowSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugArrow(const class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugArrow");

	Params::KismetSystemLibrary_DrawDebugArrow Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LineStart = std::move(LineStart);
	Parms.LineEnd = std::move(LineEnd);
	Parms.ArrowSize = ArrowSize;
	Parms.LineColor = std::move(LineColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugBox(const class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugBox");

	Params::KismetSystemLibrary_DrawDebugBox Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = std::move(Center);
	Parms.Extent = std::move(Extent);
	Parms.LineColor = std::move(LineColor);
	Parms.Rotation = std::move(Rotation);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugCamera
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ACameraActor*                     CameraActor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     CameraColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCamera(const class ACameraActor* CameraActor, const struct FLinearColor& CameraColor, float Duration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugCamera");

	Params::KismetSystemLibrary_DrawDebugCamera Parms{};

	Parms.CameraActor = CameraActor;
	Parms.CameraColor = std::move(CameraColor);
	Parms.Duration = Duration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugCapsule
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCapsule(const class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugCapsule");

	Params::KismetSystemLibrary_DrawDebugCapsule Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = std::move(Center);
	Parms.HalfHeight = HalfHeight;
	Parms.Radius = Radius;
	Parms.Rotation = std::move(Rotation);
	Parms.LineColor = std::move(LineColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugCircle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSegments                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          YAxis                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ZAxis                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawAxis                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCircle(const class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 NumSegments, const struct FLinearColor& LineColor, float Duration, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugCircle");

	Params::KismetSystemLibrary_DrawDebugCircle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.NumSegments = NumSegments;
	Parms.LineColor = std::move(LineColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;
	Parms.YAxis = std::move(YAxis);
	Parms.ZAxis = std::move(ZAxis);
	Parms.bDrawAxis = bDrawAxis;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugCone
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSides                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCone(const class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugCone");

	Params::KismetSystemLibrary_DrawDebugCone Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Length = Length;
	Parms.AngleWidth = AngleWidth;
	Parms.AngleHeight = AngleHeight;
	Parms.NumSides = NumSides;
	Parms.LineColor = std::move(LineColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumSides                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugConeInDegrees(const class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugConeInDegrees");

	Params::KismetSystemLibrary_DrawDebugConeInDegrees Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.Direction = std::move(Direction);
	Parms.Length = Length;
	Parms.AngleWidth = AngleWidth;
	Parms.AngleHeight = AngleHeight;
	Parms.NumSides = NumSides;
	Parms.LineColor = std::move(LineColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AxisLoc                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         AxisRot                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCoordinateSystem(const class UObject* WorldContextObject, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugCoordinateSystem");

	Params::KismetSystemLibrary_DrawDebugCoordinateSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AxisLoc = std::move(AxisLoc);
	Parms.AxisRot = std::move(AxisRot);
	Parms.Scale = Scale;
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugCylinder
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Segments                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugCylinder(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugCylinder");

	Params::KismetSystemLibrary_DrawDebugCylinder Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.Segments = Segments;
	Parms.LineColor = std::move(LineColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDebugFloatHistory               FloatHistory                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          DrawLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        DrawSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     DrawColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugFloatHistoryLocation(const class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FVector& DrawLocation, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugFloatHistoryLocation");

	Params::KismetSystemLibrary_DrawDebugFloatHistoryLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FloatHistory = std::move(FloatHistory);
	Parms.DrawLocation = std::move(DrawLocation);
	Parms.DrawSize = std::move(DrawSize);
	Parms.DrawColor = std::move(DrawColor);
	Parms.Duration = Duration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDebugFloatHistory               FloatHistory                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTransform                       DrawTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        DrawSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     DrawColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugFloatHistoryTransform(const class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FTransform& DrawTransform, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugFloatHistoryTransform");

	Params::KismetSystemLibrary_DrawDebugFloatHistoryTransform Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FloatHistory = std::move(FloatHistory);
	Parms.DrawTransform = std::move(DrawTransform);
	Parms.DrawSize = std::move(DrawSize);
	Parms.DrawColor = std::move(DrawColor);
	Parms.Duration = Duration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugFrustum
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       FrustumTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FLinearColor                     FrustumColor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugFrustum(const class UObject* WorldContextObject, const struct FTransform& FrustumTransform, const struct FLinearColor& FrustumColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugFrustum");

	Params::KismetSystemLibrary_DrawDebugFrustum Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FrustumTransform = std::move(FrustumTransform);
	Parms.FrustumColor = std::move(FrustumColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineStart                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineEnd                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugLine(const class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugLine");

	Params::KismetSystemLibrary_DrawDebugLine Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LineStart = std::move(LineStart);
	Parms.LineEnd = std::move(LineEnd);
	Parms.LineColor = std::move(LineColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlane                           PlaneCoordinates                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     PlaneColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugPlane(const class UObject* WorldContextObject, const struct FPlane& PlaneCoordinates, const struct FVector& Location, float Size, const struct FLinearColor& PlaneColor, float Duration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugPlane");

	Params::KismetSystemLibrary_DrawDebugPlane Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlaneCoordinates = std::move(PlaneCoordinates);
	Parms.Location = std::move(Location);
	Parms.Size = Size;
	Parms.PlaneColor = std::move(PlaneColor);
	Parms.Duration = Duration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     PointColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugPoint(const class UObject* WorldContextObject, const struct FVector& Position, float Size, const struct FLinearColor& PointColor, float Duration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugPoint");

	Params::KismetSystemLibrary_DrawDebugPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);
	Parms.Size = Size;
	Parms.PointColor = std::move(PointColor);
	Parms.Duration = Duration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugSphere
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Segments                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     LineColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugSphere(const class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32 Segments, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugSphere");

	Params::KismetSystemLibrary_DrawDebugSphere Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.Segments = Segments;
	Parms.LineColor = std::move(LineColor);
	Parms.Duration = Duration;
	Parms.Thickness = Thickness;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.DrawDebugString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TextLocation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TestBaseActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::DrawDebugString(const class UObject* WorldContextObject, const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("DrawDebugString");

	Params::KismetSystemLibrary_DrawDebugString Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TextLocation = std::move(TextLocation);
	Parms.Text = std::move(Text);
	Parms.TestBaseActor = TestBaseActor;
	Parms.TextColor = std::move(TextColor);
	Parms.Duration = Duration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.EndTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::EndTransaction()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EndTransaction");

	Params::KismetSystemLibrary_EndTransaction Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::EqualEqual_PrimaryAssetId(const struct FPrimaryAssetId& A, const struct FPrimaryAssetId& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_PrimaryAssetId");

	Params::KismetSystemLibrary_EqualEqual_PrimaryAssetId Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType                A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetType                B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::EqualEqual_PrimaryAssetType(const struct FPrimaryAssetType& A, const struct FPrimaryAssetType& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_PrimaryAssetType");

	Params::KismetSystemLibrary_EqualEqual_PrimaryAssetType Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.EqualEqual_SoftClassReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::EqualEqual_SoftClassReference(const TSoftClassPtr<class UClass>& A, const TSoftClassPtr<class UClass>& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_SoftClassReference");

	Params::KismetSystemLibrary_EqualEqual_SoftClassReference Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.EqualEqual_SoftObjectReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           A                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           B                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::EqualEqual_SoftObjectReference(const TSoftObjectPtr<class UObject>& A, const TSoftObjectPtr<class UObject>& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EqualEqual_SoftObjectReference");

	Params::KismetSystemLibrary_EqualEqual_SoftObjectReference Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ExecuteConsoleCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                SpecificPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ExecuteConsoleCommand(const class UObject* WorldContextObject, const class FString& Command, class APlayerController* SpecificPlayer)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ExecuteConsoleCommand");

	Params::KismetSystemLibrary_ExecuteConsoleCommand Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Command = std::move(Command);
	Parms.SpecificPlayer = SpecificPlayer;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.FlushDebugStrings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::FlushDebugStrings(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FlushDebugStrings");

	Params::KismetSystemLibrary_FlushDebugStrings Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.FlushPersistentDebugLines
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::FlushPersistentDebugLines(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("FlushPersistentDebugLines");

	Params::KismetSystemLibrary_FlushPersistentDebugLines Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.ForceCloseAdBanner
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetSystemLibrary::ForceCloseAdBanner()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ForceCloseAdBanner");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.KismetSystemLibrary.GetActorBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetActorBounds(const class AActor* Actor, struct FVector* Origin, struct FVector* BoxExtent)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetActorBounds");

	Params::KismetSystemLibrary_GetActorBounds Parms{};

	Parms.Actor = Actor;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);
}


// Function Engine.KismetSystemLibrary.GetActorListFromComponentList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*>      ComponentList                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActorList                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetActorListFromComponentList(const TArray<class UPrimitiveComponent*>& ComponentList, class UClass* ActorClassFilter, TArray<class AActor*>* OutActorList)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetActorListFromComponentList");

	Params::KismetSystemLibrary_GetActorListFromComponentList Parms{};

	Parms.ComponentList = std::move(ComponentList);
	Parms.ActorClassFilter = ActorClassFilter;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActorList != nullptr)
		*OutActorList = std::move(Parms.OutActorList);
}


// Function Engine.KismetSystemLibrary.GetAdIDCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetAdIDCount()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAdIDCount");

	Params::KismetSystemLibrary_GetAdIDCount Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetClassDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetClassDisplayName(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetClassDisplayName");

	Params::KismetSystemLibrary_GetClassDisplayName Parms{};

	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetClassFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UObject> UKismetSystemLibrary::GetClassFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetClassFromPrimaryAssetId");

	Params::KismetSystemLibrary_GetClassFromPrimaryAssetId Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetCommandLine
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetCommandLine()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCommandLine");

	Params::KismetSystemLibrary_GetCommandLine Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetComponentBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USceneComponent*                  Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BoxExtent                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetComponentBounds(const class USceneComponent* Component, struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetComponentBounds");

	Params::KismetSystemLibrary_GetComponentBounds Parms{};

	Parms.Component = Component;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);

	if (BoxExtent != nullptr)
		*BoxExtent = std::move(Parms.BoxExtent);

	if (SphereRadius != nullptr)
		*SphereRadius = Parms.SphereRadius;
}


// Function Engine.KismetSystemLibrary.GetConsoleVariableBoolValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetConsoleVariableBoolValue(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetConsoleVariableBoolValue");

	Params::KismetSystemLibrary_GetConsoleVariableBoolValue Parms{};

	Parms.VariableName = std::move(VariableName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetConsoleVariableFloatValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::GetConsoleVariableFloatValue(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetConsoleVariableFloatValue");

	Params::KismetSystemLibrary_GetConsoleVariableFloatValue Parms{};

	Parms.VariableName = std::move(VariableName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetConsoleVariableIntValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VariableName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetConsoleVariableIntValue(const class FString& VariableName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetConsoleVariableIntValue");

	Params::KismetSystemLibrary_GetConsoleVariableIntValue Parms{};

	Parms.VariableName = std::move(VariableName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetConvenientWindowedResolutions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FIntPoint>                Resolutions                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetConvenientWindowedResolutions(TArray<struct FIntPoint>* Resolutions)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetConvenientWindowedResolutions");

	Params::KismetSystemLibrary_GetConvenientWindowedResolutions Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Resolutions != nullptr)
		*Resolutions = std::move(Parms.Resolutions);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetCurrentBundleState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceCurrentState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutBundles                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetCurrentBundleState(const struct FPrimaryAssetId& PrimaryAssetId, bool bForceCurrentState, TArray<class FName>* OutBundles)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetCurrentBundleState");

	Params::KismetSystemLibrary_GetCurrentBundleState Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);
	Parms.bForceCurrentState = bForceCurrentState;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutBundles != nullptr)
		*OutBundles = std::move(Parms.OutBundles);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetDefaultLanguage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetDefaultLanguage()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDefaultLanguage");

	Params::KismetSystemLibrary_GetDefaultLanguage Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetDefaultLocale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetDefaultLocale()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDefaultLocale");

	Params::KismetSystemLibrary_GetDefaultLocale Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetDeviceId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetDeviceId()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDeviceId");

	Params::KismetSystemLibrary_GetDeviceId Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetDisplayName(const class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetDisplayName");

	Params::KismetSystemLibrary_GetDisplayName Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetEngineVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetEngineVersion()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEngineVersion");

	Params::KismetSystemLibrary_GetEngineVersion Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetFrameCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetSystemLibrary::GetFrameCount()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetFrameCount");

	Params::KismetSystemLibrary_GetFrameCount Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGameBundleId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetGameBundleId()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameBundleId");

	Params::KismetSystemLibrary_GetGameBundleId Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetGameName()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameName");

	Params::KismetSystemLibrary_GetGameName Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGamepadButtonGlyph
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ButtonKey                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ControllerIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UKismetSystemLibrary::GetGamepadButtonGlyph(const class FString& ButtonKey, int32 ControllerIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGamepadButtonGlyph");

	Params::KismetSystemLibrary_GetGamepadButtonGlyph Parms{};

	Parms.ButtonKey = std::move(ButtonKey);
	Parms.ControllerIndex = ControllerIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGamepadControllerName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetGamepadControllerName(int32 ControllerId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGamepadControllerName");

	Params::KismetSystemLibrary_GetGamepadControllerName Parms{};

	Parms.ControllerId = ControllerId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGameTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::GetGameTimeInSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameTimeInSeconds");

	Params::KismetSystemLibrary_GetGameTimeInSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetLocalCurrencyCode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetLocalCurrencyCode()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLocalCurrencyCode");

	Params::KismetSystemLibrary_GetLocalCurrencyCode Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetLocalCurrencySymbol()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLocalCurrencySymbol");

	Params::KismetSystemLibrary_GetLocalCurrencySymbol Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetMinYResolutionFor3DView
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetMinYResolutionFor3DView()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMinYResolutionFor3DView");

	Params::KismetSystemLibrary_GetMinYResolutionFor3DView Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetMinYResolutionForUI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetMinYResolutionForUI()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetMinYResolutionForUI");

	Params::KismetSystemLibrary_GetMinYResolutionForUI Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetObjectFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::GetObjectFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetObjectFromPrimaryAssetId");

	Params::KismetSystemLibrary_GetObjectFromPrimaryAssetId Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetObjectName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetObjectName(const class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetObjectName");

	Params::KismetSystemLibrary_GetObjectName Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetOuterObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::GetOuterObject(const class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetOuterObject");

	Params::KismetSystemLibrary_GetOuterObject Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPathName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetPathName(const class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPathName");

	Params::KismetSystemLibrary_GetPathName Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPlatformUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetPlatformUserDir()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlatformUserDir");

	Params::KismetSystemLibrary_GetPlatformUserDir Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPlatformUserName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetPlatformUserName()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPlatformUserName");

	Params::KismetSystemLibrary_GetPlatformUserName Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPreferredLanguages
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKismetSystemLibrary::GetPreferredLanguages()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPreferredLanguages");

	Params::KismetSystemLibrary_GetPreferredLanguages Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromClass
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>              Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromClass(TSubclassOf<class UObject> Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPrimaryAssetIdFromClass");

	Params::KismetSystemLibrary_GetPrimaryAssetIdFromClass Parms{};

	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromObject
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPrimaryAssetIdFromObject");

	Params::KismetSystemLibrary_GetPrimaryAssetIdFromObject Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftClassReference
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             SoftClassReference                                     (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromSoftClassReference(TSoftClassPtr<class UClass> SoftClassReference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPrimaryAssetIdFromSoftClassReference");

	Params::KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference Parms{};

	Parms.SoftClassReference = SoftClassReference;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftObjectReference
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           SoftObjectReference                                    (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UKismetSystemLibrary::GetPrimaryAssetIdFromSoftObjectReference(TSoftObjectPtr<class UObject> SoftObjectReference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPrimaryAssetIdFromSoftObjectReference");

	Params::KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference Parms{};

	Parms.SoftObjectReference = SoftObjectReference;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdList
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetType                PrimaryAssetType                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          OutPrimaryAssetIdList                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetPrimaryAssetIdList(const struct FPrimaryAssetType& PrimaryAssetType, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPrimaryAssetIdList");

	Params::KismetSystemLibrary_GetPrimaryAssetIdList Parms{};

	Parms.PrimaryAssetType = std::move(PrimaryAssetType);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPrimaryAssetIdList != nullptr)
		*OutPrimaryAssetIdList = std::move(Parms.OutPrimaryAssetIdList);
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetsWithBundleState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     RequiredBundles                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     ExcludedBundles                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetType>        ValidTypes                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bForceCurrentState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPrimaryAssetId>          OutPrimaryAssetIdList                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::GetPrimaryAssetsWithBundleState(const TArray<class FName>& RequiredBundles, const TArray<class FName>& ExcludedBundles, const TArray<struct FPrimaryAssetType>& ValidTypes, bool bForceCurrentState, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetPrimaryAssetsWithBundleState");

	Params::KismetSystemLibrary_GetPrimaryAssetsWithBundleState Parms{};

	Parms.RequiredBundles = std::move(RequiredBundles);
	Parms.ExcludedBundles = std::move(ExcludedBundles);
	Parms.ValidTypes = std::move(ValidTypes);
	Parms.bForceCurrentState = bForceCurrentState;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutPrimaryAssetIdList != nullptr)
		*OutPrimaryAssetIdList = std::move(Parms.OutPrimaryAssetIdList);
}


// Function Engine.KismetSystemLibrary.GetProjectContentDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetProjectContentDirectory()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProjectContentDirectory");

	Params::KismetSystemLibrary_GetProjectContentDirectory Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetProjectDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetProjectDirectory()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProjectDirectory");

	Params::KismetSystemLibrary_GetProjectDirectory Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetProjectSavedDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetProjectSavedDirectory()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetProjectSavedDirectory");

	Params::KismetSystemLibrary_GetProjectSavedDirectory Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetRenderingDetailMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetRenderingDetailMode()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRenderingDetailMode");

	Params::KismetSystemLibrary_GetRenderingDetailMode Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::GetRenderingMaterialQualityLevel()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetRenderingMaterialQualityLevel");

	Params::KismetSystemLibrary_GetRenderingMaterialQualityLevel Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetSoftClassReferenceFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UKismetSystemLibrary::GetSoftClassReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSoftClassReferenceFromPrimaryAssetId");

	Params::KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetSoftObjectReferenceFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UKismetSystemLibrary::GetSoftObjectReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSoftObjectReferenceFromPrimaryAssetId");

	Params::KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FIntPoint>                Resolutions                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetSupportedFullscreenResolutions(TArray<struct FIntPoint>* Resolutions)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSupportedFullscreenResolutions");

	Params::KismetSystemLibrary_GetSupportedFullscreenResolutions Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (Resolutions != nullptr)
		*Resolutions = std::move(Parms.Resolutions);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetSystemPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetSystemPath(const class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetSystemPath");

	Params::KismetSystemLibrary_GetSystemPath Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetUniqueDeviceId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::GetUniqueDeviceId()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetUniqueDeviceId");

	Params::KismetSystemLibrary_GetUniqueDeviceId Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::GetVolumeButtonsHandledBySystem()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetVolumeButtonsHandledBySystem");

	Params::KismetSystemLibrary_GetVolumeButtonsHandledBySystem Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.HideAdBanner
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetSystemLibrary::HideAdBanner()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HideAdBanner");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsControllerAssignedToGamepad(int32 ControllerId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsControllerAssignedToGamepad");

	Params::KismetSystemLibrary_IsControllerAssignedToGamepad Parms{};

	Parms.ControllerId = ControllerId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsDedicatedServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsDedicatedServer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsDedicatedServer");

	Params::KismetSystemLibrary_IsDedicatedServer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsInterstitialAdAvailable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsInterstitialAdAvailable()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsInterstitialAdAvailable");

	Params::KismetSystemLibrary_IsInterstitialAdAvailable Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsInterstitialAdRequested
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsInterstitialAdRequested()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsInterstitialAdRequested");

	Params::KismetSystemLibrary_IsInterstitialAdRequested Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsLoggedIn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                SpecificPlayer                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsLoggedIn(const class APlayerController* SpecificPlayer)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsLoggedIn");

	Params::KismetSystemLibrary_IsLoggedIn Parms{};

	Parms.SpecificPlayer = SpecificPlayer;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsPackagedForDistribution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsPackagedForDistribution()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsPackagedForDistribution");

	Params::KismetSystemLibrary_IsPackagedForDistribution Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsScreensaverEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsScreensaverEnabled()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsScreensaverEnabled");

	Params::KismetSystemLibrary_IsScreensaverEnabled Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsServer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsServer");

	Params::KismetSystemLibrary_IsServer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsSplitScreen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsSplitScreen(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsSplitScreen");

	Params::KismetSystemLibrary_IsSplitScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsStandalone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsStandalone(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsStandalone");

	Params::KismetSystemLibrary_IsStandalone Parms{};

	Parms.WorldContextObject = WorldContextObject;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsUnattended
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsUnattended()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsUnattended");

	Params::KismetSystemLibrary_IsUnattended Parms{};

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValid(const class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValid");

	Params::KismetSystemLibrary_IsValid Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidClass(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValidClass");

	Params::KismetSystemLibrary_IsValidClass Parms{};

	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValidPrimaryAssetId");

	Params::KismetSystemLibrary_IsValidPrimaryAssetId Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidPrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType                PrimaryAssetType                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidPrimaryAssetType(const struct FPrimaryAssetType& PrimaryAssetType)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValidPrimaryAssetType");

	Params::KismetSystemLibrary_IsValidPrimaryAssetType Parms{};

	Parms.PrimaryAssetType = std::move(PrimaryAssetType);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidSoftClassReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             SoftClassReference                                     (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidSoftClassReference(const TSoftClassPtr<class UClass>& SoftClassReference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValidSoftClassReference");

	Params::KismetSystemLibrary_IsValidSoftClassReference Parms{};

	Parms.SoftClassReference = SoftClassReference;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidSoftObjectReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           SoftObjectReference                                    (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::IsValidSoftObjectReference(const TSoftObjectPtr<class UObject>& SoftObjectReference)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("IsValidSoftObjectReference");

	Params::KismetSystemLibrary_IsValidSoftObjectReference Parms{};

	Parms.SoftObjectReference = SoftObjectReference;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_ClearAndInvalidateTimerHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_ClearAndInvalidateTimerHandle(const class UObject* WorldContextObject, struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_ClearAndInvalidateTimerHandle");

	Params::KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Handle = std::move(Parms.Handle);
}


// Function Engine.KismetSystemLibrary.K2_ClearTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_ClearTimer(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_ClearTimer");

	Params::KismetSystemLibrary_K2_ClearTimer Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_ClearTimerDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_ClearTimerDelegate");

	Params::KismetSystemLibrary_K2_ClearTimerDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.K2_ClearTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_ClearTimerHandle(const class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_ClearTimerHandle");

	Params::KismetSystemLibrary_K2_ClearTimerHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerElapsedTime(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_GetTimerElapsedTime");

	Params::KismetSystemLibrary_K2_GetTimerElapsedTime Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerElapsedTimeDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_GetTimerElapsedTimeDelegate");

	Params::KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerElapsedTimeHandle(const class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_GetTimerElapsedTimeHandle");

	Params::KismetSystemLibrary_K2_GetTimerElapsedTimeHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerRemainingTime(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_GetTimerRemainingTime");

	Params::KismetSystemLibrary_K2_GetTimerRemainingTime Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerRemainingTimeDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_GetTimerRemainingTimeDelegate");

	Params::KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::K2_GetTimerRemainingTimeHandle(const class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_GetTimerRemainingTimeHandle");

	Params::KismetSystemLibrary_K2_GetTimerRemainingTimeHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTimerHandle                     Handle                                                 (Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle UKismetSystemLibrary::K2_InvalidateTimerHandle(struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_InvalidateTimerHandle");

	Params::KismetSystemLibrary_K2_InvalidateTimerHandle Parms{};

	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	Handle = std::move(Parms.Handle);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerActive(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_IsTimerActive");

	Params::KismetSystemLibrary_K2_IsTimerActive Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerActiveDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_IsTimerActiveDelegate");

	Params::KismetSystemLibrary_K2_IsTimerActiveDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerActiveHandle(const class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_IsTimerActiveHandle");

	Params::KismetSystemLibrary_K2_IsTimerActiveHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerPaused
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerPaused(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_IsTimerPaused");

	Params::KismetSystemLibrary_K2_IsTimerPaused Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerPausedDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_IsTimerPausedDelegate");

	Params::KismetSystemLibrary_K2_IsTimerPausedDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsTimerPausedHandle(const class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_IsTimerPausedHandle");

	Params::KismetSystemLibrary_K2_IsTimerPausedHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_IsValidTimerHandle(const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_IsValidTimerHandle");

	Params::KismetSystemLibrary_K2_IsValidTimerHandle Parms{};

	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_PauseTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_PauseTimer(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_PauseTimer");

	Params::KismetSystemLibrary_K2_PauseTimer Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_PauseTimerDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_PauseTimerDelegate");

	Params::KismetSystemLibrary_K2_PauseTimerDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.K2_PauseTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_PauseTimerHandle(const class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_PauseTimerHandle");

	Params::KismetSystemLibrary_K2_PauseTimerHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.K2_SetTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InitialStartDelay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InitialStartDelayVariance                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle UKismetSystemLibrary::K2_SetTimer(class UObject* Object, const class FString& FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_SetTimer");

	Params::KismetSystemLibrary_K2_SetTimer Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);
	Parms.Time = Time;
	Parms.bLooping = bLooping;
	Parms.InitialStartDelay = InitialStartDelay;
	Parms.InitialStartDelayVariance = InitialStartDelayVariance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_SetTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLooping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InitialStartDelay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InitialStartDelayVariance                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle UKismetSystemLibrary::K2_SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_SetTimerDelegate");

	Params::KismetSystemLibrary_K2_SetTimerDelegate Parms{};

	Parms.Delegate = Delegate;
	Parms.Time = Time;
	Parms.bLooping = bLooping;
	Parms.InitialStartDelay = InitialStartDelay;
	Parms.InitialStartDelayVariance = InitialStartDelayVariance;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_SetTimerForNextTick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle UKismetSystemLibrary::K2_SetTimerForNextTick(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_SetTimerForNextTick");

	Params::KismetSystemLibrary_K2_SetTimerForNextTick Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_SetTimerForNextTickDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FTimerHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimerHandle UKismetSystemLibrary::K2_SetTimerForNextTickDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_SetTimerForNextTickDelegate");

	Params::KismetSystemLibrary_K2_SetTimerForNextTickDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_TimerExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_TimerExists(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_TimerExists");

	Params::KismetSystemLibrary_K2_TimerExists Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_TimerExistsDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_TimerExistsDelegate");

	Params::KismetSystemLibrary_K2_TimerExistsDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_TimerExistsHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::K2_TimerExistsHandle(const class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_TimerExistsHandle");

	Params::KismetSystemLibrary_K2_TimerExistsHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_UnPauseTimer(class UObject* Object, const class FString& FunctionName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_UnPauseTimer");

	Params::KismetSystemLibrary_K2_UnPauseTimer Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_UnPauseTimerDelegate(TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_UnPauseTimerDelegate");

	Params::KismetSystemLibrary_K2_UnPauseTimerDelegate Parms{};

	Parms.Delegate = Delegate;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimerHandle                     Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::K2_UnPauseTimerHandle(const class UObject* WorldContextObject, const struct FTimerHandle& Handle)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("K2_UnPauseTimerHandle");

	Params::KismetSystemLibrary_K2_UnPauseTimerHandle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.LaunchURL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LaunchURL(const class FString& URL)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LaunchURL");

	Params::KismetSystemLibrary_LaunchURL Parms{};

	Parms.URL = std::move(URL);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.LineTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceMulti(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LineTraceMulti");

	Params::KismetSystemLibrary_LineTraceMulti Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceMultiByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LineTraceMultiByProfile");

	Params::KismetSystemLibrary_LineTraceMultiByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceMultiForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LineTraceMultiForObjects");

	Params::KismetSystemLibrary_LineTraceMultiForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceSingle(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LineTraceSingle");

	Params::KismetSystemLibrary_LineTraceSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceSingleByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LineTraceSingleByProfile");

	Params::KismetSystemLibrary_LineTraceSingleByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::LineTraceSingleForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LineTraceSingleForObjects");

	Params::KismetSystemLibrary_LineTraceSingleForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LoadAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           Asset                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* Loaded)>  OnLoaded                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LoadAsset(const class UObject* WorldContextObject, TSoftObjectPtr<class UObject> Asset, TDelegate<void(class UObject* Loaded)> OnLoaded, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadAsset");

	Params::KismetSystemLibrary_LoadAsset Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Asset = Asset;
	Parms.OnLoaded = OnLoaded;
	Parms.LatentInfo = std::move(LatentInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.LoadAsset_Blocking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObject>           Asset                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKismetSystemLibrary::LoadAsset_Blocking(TSoftObjectPtr<class UObject> Asset)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadAsset_Blocking");

	Params::KismetSystemLibrary_LoadAsset_Blocking Parms{};

	Parms.Asset = Asset;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LoadAssetClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             AssetClass                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(TSubclassOf<class UObject> Loaded)>OnLoaded                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LoadAssetClass(const class UObject* WorldContextObject, TSoftClassPtr<class UClass> AssetClass, TDelegate<void(TSubclassOf<class UObject> Loaded)> OnLoaded, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadAssetClass");

	Params::KismetSystemLibrary_LoadAssetClass Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AssetClass = AssetClass;
	Parms.OnLoaded = OnLoaded;
	Parms.LatentInfo = std::move(LatentInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.LoadClassAsset_Blocking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             AssetClass                                             (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UKismetSystemLibrary::LoadClassAsset_Blocking(TSoftClassPtr<class UClass> AssetClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadClassAsset_Blocking");

	Params::KismetSystemLibrary_LoadClassAsset_Blocking Parms{};

	Parms.AssetClass = AssetClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LoadInterstitialAd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AdIdIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LoadInterstitialAd(int32 AdIdIndex)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadInterstitialAd");

	Params::KismetSystemLibrary_LoadInterstitialAd Parms{};

	Parms.AdIdIndex = AdIdIndex;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.LogString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrintToLog                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::LogString(const class FString& InString, bool bPrintToLog)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LogString");

	Params::KismetSystemLibrary_LogString Parms{};

	Parms.InString = std::move(InString);
	Parms.bPrintToLog = bPrintToLog;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.MakeLiteralBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::MakeLiteralBool(bool Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralBool");

	Params::KismetSystemLibrary_MakeLiteralBool Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKismetSystemLibrary::MakeLiteralByte(uint8 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralByte");

	Params::KismetSystemLibrary_MakeLiteralByte Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralDouble
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UKismetSystemLibrary::MakeLiteralDouble(double Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralDouble");

	Params::KismetSystemLibrary_MakeLiteralDouble Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKismetSystemLibrary::MakeLiteralFloat(float Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralFloat");

	Params::KismetSystemLibrary_MakeLiteralFloat Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKismetSystemLibrary::MakeLiteralInt(int32 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralInt");

	Params::KismetSystemLibrary_MakeLiteralInt Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKismetSystemLibrary::MakeLiteralInt64(int64 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralInt64");

	Params::KismetSystemLibrary_MakeLiteralInt64 Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKismetSystemLibrary::MakeLiteralName(class FName Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralName");

	Params::KismetSystemLibrary_MakeLiteralName Parms{};

	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::MakeLiteralString(const class FString& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralString");

	Params::KismetSystemLibrary_MakeLiteralString Parms{};

	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             Value                                                  (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UKismetSystemLibrary::MakeLiteralText(const class FText& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeLiteralText");

	Params::KismetSystemLibrary_MakeLiteralText Parms{};

	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeSoftClassPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PathString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftClassPath                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftClassPath UKismetSystemLibrary::MakeSoftClassPath(const class FString& PathString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeSoftClassPath");

	Params::KismetSystemLibrary_MakeSoftClassPath Parms{};

	Parms.PathString = std::move(PathString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeSoftObjectPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PathString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSoftObjectPath                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FSoftObjectPath UKismetSystemLibrary::MakeSoftObjectPath(const class FString& PathString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MakeSoftObjectPath");

	Params::KismetSystemLibrary_MakeSoftObjectPath Parms{};

	Parms.PathString = std::move(PathString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MoveComponentTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetRelativeLocation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         TargetRelativeRotation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEaseOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEaseIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceShortestRotationPath                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMoveComponentAction                    MoveAction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::MoveComponentTo(class USceneComponent* Component, const struct FVector& TargetRelativeLocation, const struct FRotator& TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, EMoveComponentAction MoveAction, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MoveComponentTo");

	Params::KismetSystemLibrary_MoveComponentTo Parms{};

	Parms.Component = Component;
	Parms.TargetRelativeLocation = std::move(TargetRelativeLocation);
	Parms.TargetRelativeRotation = std::move(TargetRelativeRotation);
	Parms.bEaseOut = bEaseOut;
	Parms.bEaseIn = bEaseIn;
	Parms.OverTime = OverTime;
	Parms.bForceShortestRotationPath = bForceShortestRotationPath;
	Parms.MoveAction = MoveAction;
	Parms.LatentInfo = std::move(LatentInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.NormalizeFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InFilename                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKismetSystemLibrary::NormalizeFilename(const class FString& InFilename)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NormalizeFilename");

	Params::KismetSystemLibrary_NormalizeFilename Parms{};

	Parms.InFilename = std::move(InFilename);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId                  A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::NotEqual_PrimaryAssetId(const struct FPrimaryAssetId& A, const struct FPrimaryAssetId& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_PrimaryAssetId");

	Params::KismetSystemLibrary_NotEqual_PrimaryAssetId Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType                A                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetType                B                                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::NotEqual_PrimaryAssetType(const struct FPrimaryAssetType& A, const struct FPrimaryAssetType& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_PrimaryAssetType");

	Params::KismetSystemLibrary_NotEqual_PrimaryAssetType Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.NotEqual_SoftClassReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             A                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             B                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::NotEqual_SoftClassReference(const TSoftClassPtr<class UClass>& A, const TSoftClassPtr<class UClass>& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_SoftClassReference");

	Params::KismetSystemLibrary_NotEqual_SoftClassReference Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.NotEqual_SoftObjectReference
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UObject>           A                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           B                                                      (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::NotEqual_SoftObjectReference(const TSoftObjectPtr<class UObject>& A, const TSoftObjectPtr<class UObject>& B)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("NotEqual_SoftObjectReference");

	Params::KismetSystemLibrary_NotEqual_SoftObjectReference Parms{};

	Parms.A = A;
	Parms.B = B;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ParseCommandLine
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           InCmdLine                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   OutTokens                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   OutSwitches                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TMap<class FString, class FString>      OutParams                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ParseCommandLine(const class FString& InCmdLine, TArray<class FString>* OutTokens, TArray<class FString>* OutSwitches, TMap<class FString, class FString>* OutParams)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ParseCommandLine");

	Params::KismetSystemLibrary_ParseCommandLine Parms{};

	Parms.InCmdLine = std::move(InCmdLine);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutTokens != nullptr)
		*OutTokens = std::move(Parms.OutTokens);

	if (OutSwitches != nullptr)
		*OutSwitches = std::move(Parms.OutSwitches);

	if (OutParams != nullptr)
		*OutParams = std::move(Parms.OutParams);
}


// Function Engine.KismetSystemLibrary.ParseParam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InParam                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::ParseParam(const class FString& InString, const class FString& InParam)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ParseParam");

	Params::KismetSystemLibrary_ParseParam Parms{};

	Parms.InString = std::move(InString);
	Parms.InParam = std::move(InParam);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ParseParamValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InParam                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutValue                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::ParseParamValue(const class FString& InString, const class FString& InParam, class FString* OutValue)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ParseParamValue");

	Params::KismetSystemLibrary_ParseParamValue Parms{};

	Parms.InString = std::move(InString);
	Parms.InParam = std::move(InParam);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.PrintString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrintToScreen                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrintToLog                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::PrintString(const class UObject* WorldContextObject, const class FString& InString, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PrintString");

	Params::KismetSystemLibrary_PrintString Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InString = std::move(InString);
	Parms.bPrintToScreen = bPrintToScreen;
	Parms.bPrintToLog = bPrintToLog;
	Parms.TextColor = std::move(TextColor);
	Parms.Duration = Duration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.PrintText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InText                                                 (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    bPrintToScreen                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrintToLog                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::PrintText(const class UObject* WorldContextObject, const class FText& InText, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PrintText");

	Params::KismetSystemLibrary_PrintText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InText = std::move(InText);
	Parms.bPrintToScreen = bPrintToScreen;
	Parms.bPrintToLog = bPrintToLog;
	Parms.TextColor = std::move(TextColor);
	Parms.Duration = Duration;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.PrintWarning
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::PrintWarning(const class FString& InString)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("PrintWarning");

	Params::KismetSystemLibrary_PrintWarning Parms{};

	Parms.InString = std::move(InString);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.QuitGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                SpecificPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuitPreference                         QuitPreference                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnorePlatformRestrictions                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::QuitGame(const class UObject* WorldContextObject, class APlayerController* SpecificPlayer, EQuitPreference QuitPreference, bool bIgnorePlatformRestrictions)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("QuitGame");

	Params::KismetSystemLibrary_QuitGame Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SpecificPlayer = SpecificPlayer;
	Parms.QuitPreference = QuitPreference;
	Parms.bIgnorePlatformRestrictions = bIgnorePlatformRestrictions;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetSystemLibrary::RegisterForRemoteNotifications()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RegisterForRemoteNotifications");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.KismetSystemLibrary.ResetGamepadAssignments
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetSystemLibrary::ResetGamepadAssignments()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ResetGamepadAssignments");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ResetGamepadAssignmentToController(int32 ControllerId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ResetGamepadAssignmentToController");

	Params::KismetSystemLibrary_ResetGamepadAssignmentToController Parms{};

	Parms.ControllerId = ControllerId;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.RetriggerableDelay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::RetriggerableDelay(const class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RetriggerableDelay");

	Params::KismetSystemLibrary_RetriggerableDelay Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Duration = Duration;
	Parms.LatentInfo = std::move(LatentInfo);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetBoolPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetBoolPropertyByName(class UObject* Object, class FName PropertyName, bool Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetBoolPropertyByName");

	Params::KismetSystemLibrary_SetBoolPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetBytePropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetBytePropertyByName(class UObject* Object, class FName PropertyName, uint8 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetBytePropertyByName");

	Params::KismetSystemLibrary_SetBytePropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetClassPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetClassPropertyByName(class UObject* Object, class FName PropertyName, TSubclassOf<class UObject> Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetClassPropertyByName");

	Params::KismetSystemLibrary_SetClassPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCollisionProfileName            Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetCollisionProfileNameProperty(class UObject* Object, class FName PropertyName, const struct FCollisionProfileName& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetCollisionProfileNameProperty");

	Params::KismetSystemLibrary_SetCollisionProfileNameProperty Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetColorPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetColorPropertyByName(class UObject* Object, class FName PropertyName, const struct FColor& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetColorPropertyByName");

	Params::KismetSystemLibrary_SetColorPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetDoublePropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetDoublePropertyByName(class UObject* Object, class FName PropertyName, double Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetDoublePropertyByName");

	Params::KismetSystemLibrary_SetDoublePropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetFieldPathPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TFieldPath<class FField>                Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetFieldPathPropertyByName(class UObject* Object, class FName PropertyName, const TFieldPath<class FField>& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetFieldPathPropertyByName");

	Params::KismetSystemLibrary_SetFieldPathPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetFloatPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetFloatPropertyByName(class UObject* Object, class FName PropertyName, float Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetFloatPropertyByName");

	Params::KismetSystemLibrary_SetFloatPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetGamepadsBlockDeviceFeedback
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetGamepadsBlockDeviceFeedback(bool bBlock)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetGamepadsBlockDeviceFeedback");

	Params::KismetSystemLibrary_SetGamepadsBlockDeviceFeedback Parms{};

	Parms.bBlock = bBlock;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetInt64PropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetInt64PropertyByName(class UObject* Object, class FName PropertyName, int64 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetInt64PropertyByName");

	Params::KismetSystemLibrary_SetInt64PropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetInterfacePropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IInterface>      Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetInterfacePropertyByName(class UObject* Object, class FName PropertyName, const TScriptInterface<class IInterface>& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetInterfacePropertyByName");

	Params::KismetSystemLibrary_SetInterfacePropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetIntPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetIntPropertyByName(class UObject* Object, class FName PropertyName, int32 Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetIntPropertyByName");

	Params::KismetSystemLibrary_SetIntPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetLinearColorPropertyByName(class UObject* Object, class FName PropertyName, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetLinearColorPropertyByName");

	Params::KismetSystemLibrary_SetLinearColorPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetNamePropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetNamePropertyByName(class UObject* Object, class FName PropertyName, const class FName& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetNamePropertyByName");

	Params::KismetSystemLibrary_SetNamePropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetObjectPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetObjectPropertyByName(class UObject* Object, class FName PropertyName, class UObject* Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetObjectPropertyByName");

	Params::KismetSystemLibrary_SetObjectPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetRotatorPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetRotatorPropertyByName(class UObject* Object, class FName PropertyName, const struct FRotator& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetRotatorPropertyByName");

	Params::KismetSystemLibrary_SetRotatorPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetSoftClassPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetSoftClassPropertyByName(class UObject* Object, class FName PropertyName, const TSoftClassPtr<class UClass>& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetSoftClassPropertyByName");

	Params::KismetSystemLibrary_SetSoftClassPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetSoftObjectPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetSoftObjectPropertyByName(class UObject* Object, class FName PropertyName, const TSoftObjectPtr<class UObject>& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetSoftObjectPropertyByName");

	Params::KismetSystemLibrary_SetSoftObjectPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetStringPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetStringPropertyByName(class UObject* Object, class FName PropertyName, const class FString& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetStringPropertyByName");

	Params::KismetSystemLibrary_SetStringPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetStructurePropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGenericStruct                   Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetStructurePropertyByName(class UObject* Object, class FName PropertyName, const struct FGenericStruct& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetStructurePropertyByName");

	Params::KismetSystemLibrary_SetStructurePropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetSuppressViewportTransitionMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetSuppressViewportTransitionMessage(const class UObject* WorldContextObject, bool bState)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetSuppressViewportTransitionMessage");

	Params::KismetSystemLibrary_SetSuppressViewportTransitionMessage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.bState = bState;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetTextPropertyByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetTextPropertyByName(class UObject* Object, class FName PropertyName, const class FText& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetTextPropertyByName");

	Params::KismetSystemLibrary_SetTextPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetTransformPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetTransformPropertyByName(class UObject* Object, class FName PropertyName, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetTransformPropertyByName");

	Params::KismetSystemLibrary_SetTransformPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetUserActivity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUserActivity                    UserActivity                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetUserActivity(const struct FUserActivity& UserActivity)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetUserActivity");

	Params::KismetSystemLibrary_SetUserActivity Parms{};

	Parms.UserActivity = std::move(UserActivity);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetVectorPropertyByName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetVectorPropertyByName(class UObject* Object, class FName PropertyName, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetVectorPropertyByName");

	Params::KismetSystemLibrary_SetVectorPropertyByName Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;
	Parms.Value = std::move(Value);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetVolumeButtonsHandledBySystem(bool bEnabled)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetVolumeButtonsHandledBySystem");

	Params::KismetSystemLibrary_SetVolumeButtonsHandledBySystem Parms{};

	Parms.bEnabled = bEnabled;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SetWindowTitle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Title                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SetWindowTitle(const class FText& Title)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetWindowTitle");

	Params::KismetSystemLibrary_SetWindowTitle Parms{};

	Parms.Title = std::move(Title);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.ShowAdBanner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AdIdIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowOnBottomOfScreen                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ShowAdBanner(int32 AdIdIndex, bool bShowOnBottomOfScreen)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ShowAdBanner");

	Params::KismetSystemLibrary_ShowAdBanner Parms{};

	Parms.AdIdIndex = AdIdIndex;
	Parms.bShowOnBottomOfScreen = bShowOnBottomOfScreen;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.ShowInterstitialAd
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetSystemLibrary::ShowInterstitialAd()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ShowInterstitialAd");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                SpecificPlayer                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ShowPlatformSpecificAchievementsScreen(const class APlayerController* SpecificPlayer)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ShowPlatformSpecificAchievementsScreen");

	Params::KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen Parms{};

	Parms.SpecificPlayer = SpecificPlayer;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::ShowPlatformSpecificLeaderboardScreen(const class FString& CategoryName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ShowPlatformSpecificLeaderboardScreen");

	Params::KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen Parms{};

	Parms.CategoryName = std::move(CategoryName);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SnapshotObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::SnapshotObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SnapshotObject");

	Params::KismetSystemLibrary_SnapshotObject Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.SphereOverlapActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpherePos                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ActorClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereOverlapActors(const class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SphereOverlapActors");

	Params::KismetSystemLibrary_SphereOverlapActors Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SpherePos = std::move(SpherePos);
	Parms.SphereRadius = SphereRadius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorClassFilter = ActorClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SpherePos                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UClass*                           ComponentClassFilter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereOverlapComponents(const class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, const TArray<EObjectTypeQuery>& ObjectTypes, class UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SphereOverlapComponents");

	Params::KismetSystemLibrary_SphereOverlapComponents Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SpherePos = std::move(SpherePos);
	Parms.SphereRadius = SphereRadius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ComponentClassFilter = ComponentClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceMulti(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SphereTraceMulti");

	Params::KismetSystemLibrary_SphereTraceMulti Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceMultiByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SphereTraceMultiByProfile");

	Params::KismetSystemLibrary_SphereTraceMultiByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceMultiForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SphereTraceMultiForObjects");

	Params::KismetSystemLibrary_SphereTraceMultiForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceSingle(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SphereTraceSingle");

	Params::KismetSystemLibrary_SphereTraceSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceSingleByProfile(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SphereTraceSingleByProfile");

	Params::KismetSystemLibrary_SphereTraceSingleByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKismetSystemLibrary::SphereTraceSingleForObjects(const class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SphereTraceSingleForObjects");

	Params::KismetSystemLibrary_SphereTraceSingleForObjects Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function Engine.KismetSystemLibrary.StackTrace
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetSystemLibrary::StackTrace()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("StackTrace");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.KismetSystemLibrary.TransactObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::TransactObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("TransactObject");

	Params::KismetSystemLibrary_TransactObject Parms{};

	Parms.Object = Object;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.UnloadPrimaryAsset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId                  PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::UnloadPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnloadPrimaryAsset");

	Params::KismetSystemLibrary_UnloadPrimaryAsset Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.UnloadPrimaryAssetList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId>          PrimaryAssetIdList                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKismetSystemLibrary::UnloadPrimaryAssetList(const TArray<struct FPrimaryAssetId>& PrimaryAssetIdList)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnloadPrimaryAssetList");

	Params::KismetSystemLibrary_UnloadPrimaryAssetList Parms{};

	Parms.PrimaryAssetIdList = std::move(PrimaryAssetIdList);

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.KismetSystemLibrary.UnregisterForRemoteNotifications
// (Final, Native, Static, Public, BlueprintCallable)

void UKismetSystemLibrary::UnregisterForRemoteNotifications()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("UnregisterForRemoteNotifications");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.LevelStreamingDynamic.LoadLevelInstance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LevelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OptionalLevelNameOverride                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULevelStreamingDynamic>OptionalLevelStreamingClass                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreamingDynamic*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreamingDynamic* ULevelStreamingDynamic::LoadLevelInstance(class UObject* WorldContextObject, const class FString& LevelName, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess, const class FString& OptionalLevelNameOverride, TSubclassOf<class ULevelStreamingDynamic> OptionalLevelStreamingClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadLevelInstance");

	Params::LevelStreamingDynamic_LoadLevelInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LevelName = std::move(LevelName);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.OptionalLevelNameOverride = std::move(OptionalLevelNameOverride);
	Parms.OptionalLevelStreamingClass = OptionalLevelStreamingClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	return Parms.ReturnValue;
}


// Function Engine.LevelStreamingDynamic.LoadLevelInstanceBySoftObjectPtr
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            Level                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutSuccess                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OptionalLevelNameOverride                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULevelStreamingDynamic>OptionalLevelStreamingClass                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreamingDynamic*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreamingDynamic* ULevelStreamingDynamic::LoadLevelInstanceBySoftObjectPtr(class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> Level, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess, const class FString& OptionalLevelNameOverride, TSubclassOf<class ULevelStreamingDynamic> OptionalLevelStreamingClass)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LoadLevelInstanceBySoftObjectPtr");

	Params::LevelStreamingDynamic_LoadLevelInstanceBySoftObjectPtr Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Level = Level;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.OptionalLevelNameOverride = std::move(OptionalLevelNameOverride);
	Parms.OptionalLevelStreamingClass = OptionalLevelStreamingClass;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	if (bOutSuccess != nullptr)
		*bOutSuccess = Parms.bOutSuccess;

	return Parms.ReturnValue;
}


// Function Engine.LightWeightInstanceBlueprintFunctionLibrary.ConvertActorToLightWeightInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActorInstanceHandle             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActorInstanceHandle ULightWeightInstanceBlueprintFunctionLibrary::ConvertActorToLightWeightInstance(class AActor* Actor)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ConvertActorToLightWeightInstance");

	Params::LightWeightInstanceBlueprintFunctionLibrary_ConvertActorToLightWeightInstance Parms{};

	Parms.Actor = Actor;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LightWeightInstanceBlueprintFunctionLibrary.CreateNewLightWeightInstance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UClass*                           ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UDataLayer*                       Layer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActorInstanceHandle             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActorInstanceHandle ULightWeightInstanceBlueprintFunctionLibrary::CreateNewLightWeightInstance(class UClass* ActorClass, const struct FTransform& Transform, class UDataLayer* Layer, class UWorld* World)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateNewLightWeightInstance");

	Params::LightWeightInstanceBlueprintFunctionLibrary_CreateNewLightWeightInstance Parms{};

	Parms.ActorClass = ActorClass;
	Parms.Transform = std::move(Transform);
	Parms.Layer = Layer;
	Parms.World = World;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.LightWeightInstanceManager.OnRep_Transforms
// (Native, Protected)

void ALightWeightInstanceManager::OnRep_Transforms()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Transforms");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.LightWeightInstanceStaticMeshManager.OnRep_StaticMesh
// (Final, Native, Protected)

void ALightWeightInstanceStaticMeshManager::OnRep_StaticMesh()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_StaticMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.LODSyncComponent.GetLODSyncDebugText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULODSyncComponent::GetLODSyncDebugText() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLODSyncDebugText");

	Params::LODSyncComponent_GetLODSyncDebugText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.CopyInterpParameters
// (Final, Native, Public)
// Parameters:
// class UMaterialInstance*                Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::CopyInterpParameters(class UMaterialInstance* Source)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CopyInterpParameters");

	Params::MaterialInstanceDynamic_CopyInterpParameters Parms{};

	Parms.Source = Source;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.CopyParameterOverrides
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                MaterialInstance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::CopyParameterOverrides(class UMaterialInstance* MaterialInstance)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CopyParameterOverrides");

	Params::MaterialInstanceDynamic_CopyParameterOverrides Parms{};

	Parms.MaterialInstance = MaterialInstance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuickParametersOnly                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::K2_CopyMaterialInstanceParameters(class UMaterialInterface* Source, bool bQuickParametersOnly)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_CopyMaterialInstanceParameters");

	Params::MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters Parms{};

	Parms.Source = Source;
	Parms.bQuickParametersOnly = bQuickParametersOnly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaterialInstanceDynamic::K2_GetScalarParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetScalarParameterValue");

	Params::MaterialInstanceDynamic_K2_GetScalarParameterValue Parms{};

	Parms.ParameterName = ParameterName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValueByInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMaterialInstanceDynamic::K2_GetScalarParameterValueByInfo(const struct FMaterialParameterInfo& ParameterInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetScalarParameterValueByInfo");

	Params::MaterialInstanceDynamic_K2_GetScalarParameterValueByInfo Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UMaterialInstanceDynamic::K2_GetTextureParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetTextureParameterValue");

	Params::MaterialInstanceDynamic_K2_GetTextureParameterValue Parms{};

	Parms.ParameterName = ParameterName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValueByInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UMaterialInstanceDynamic::K2_GetTextureParameterValueByInfo(const struct FMaterialParameterInfo& ParameterInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetTextureParameterValueByInfo");

	Params::MaterialInstanceDynamic_K2_GetTextureParameterValueByInfo Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UMaterialInstanceDynamic::K2_GetVectorParameterValue(class FName ParameterName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetVectorParameterValue");

	Params::MaterialInstanceDynamic_K2_GetVectorParameterValue Parms{};

	Parms.ParameterName = ParameterName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValueByInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UMaterialInstanceDynamic::K2_GetVectorParameterValueByInfo(const struct FMaterialParameterInfo& ParameterInfo)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_GetVectorParameterValueByInfo");

	Params::MaterialInstanceDynamic_K2_GetVectorParameterValueByInfo Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                SourceA                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                SourceB                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::K2_InterpolateMaterialInstanceParams(class UMaterialInstance* SourceA, class UMaterialInstance* SourceB, float Alpha)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_InterpolateMaterialInstanceParams");

	Params::MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams Parms{};

	Parms.SourceA = SourceA;
	Parms.SourceB = SourceB;
	Parms.Alpha = Alpha;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.SetRuntimeVirtualTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeVirtualTexture*           Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetRuntimeVirtualTextureParameterValue(class FName ParameterName, class URuntimeVirtualTexture* Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRuntimeVirtualTextureParameterValue");

	Params::MaterialInstanceDynamic_SetRuntimeVirtualTextureParameterValue Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.SetRuntimeVirtualTextureParameterValueByInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URuntimeVirtualTexture*           Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetRuntimeVirtualTextureParameterValueByInfo(const struct FMaterialParameterInfo& ParameterInfo, class URuntimeVirtualTexture* Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRuntimeVirtualTextureParameterValueByInfo");

	Params::MaterialInstanceDynamic_SetRuntimeVirtualTextureParameterValueByInfo Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.SetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetScalarParameterValue(class FName ParameterName, float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarParameterValue");

	Params::MaterialInstanceDynamic_SetScalarParameterValue Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.SetScalarParameterValueByInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetScalarParameterValueByInfo(const struct FMaterialParameterInfo& ParameterInfo, float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetScalarParameterValueByInfo");

	Params::MaterialInstanceDynamic_SetScalarParameterValueByInfo Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.SetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetTextureParameterValue(class FName ParameterName, class UTexture* Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextureParameterValue");

	Params::MaterialInstanceDynamic_SetTextureParameterValue Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.SetTextureParameterValueByInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetTextureParameterValueByInfo(const struct FMaterialParameterInfo& ParameterInfo, class UTexture* Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextureParameterValueByInfo");

	Params::MaterialInstanceDynamic_SetTextureParameterValueByInfo Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.SetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetVectorParameterValue(class FName ParameterName, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorParameterValue");

	Params::MaterialInstanceDynamic_SetVectorParameterValue Parms{};

	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MaterialInstanceDynamic.SetVectorParameterValueByInfo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialInstanceDynamic::SetVectorParameterValueByInfo(const struct FMaterialParameterInfo& ParameterInfo, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorParameterValueByInfo");

	Params::MaterialInstanceDynamic_SetVectorParameterValueByInfo Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PostProcessVolume.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APostProcessVolume::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddOrUpdateBlendable");

	Params::PostProcessVolume_AddOrUpdateBlendable Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PostProcessComponent.AddOrUpdateBlendable
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlendableInterface>InBlendableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPostProcessComponent::AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddOrUpdateBlendable");

	Params::PostProcessComponent_AddOrUpdateBlendable Parms{};

	Parms.InBlendableObject = InBlendableObject;
	Parms.InWeight = InWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.RadialForceActor.DisableForce
// (Native, Public, BlueprintCallable)

void ARadialForceActor::DisableForce()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("DisableForce");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.RadialForceActor.EnableForce
// (Native, Public, BlueprintCallable)

void ARadialForceActor::EnableForce()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableForce");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.RadialForceActor.FireImpulse
// (Native, Public, BlueprintCallable)

void ARadialForceActor::FireImpulse()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FireImpulse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.RadialForceActor.ToggleForce
// (Native, Public, BlueprintCallable)

void ARadialForceActor::ToggleForce()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ToggleForce");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.MatineeActor.ChangePlaybackDirection
// (Native, Public, BlueprintCallable)

void AMatineeActor::ChangePlaybackDirection()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ChangePlaybackDirection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.MatineeActor.EnableGroupByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           GroupName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatineeActor::EnableGroupByName(const class FString& GroupName, bool bEnable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("EnableGroupByName");

	Params::MatineeActor_EnableGroupByName Parms{};

	Parms.GroupName = std::move(GroupName);
	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MatineeActor.Pause
// (Native, Public, BlueprintCallable)

void AMatineeActor::Pause()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Pause");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.MatineeActor.Play
// (Native, Public, BlueprintCallable)

void AMatineeActor::Play()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Play");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.MatineeActor.Reverse
// (Native, Public, BlueprintCallable)

void AMatineeActor::Reverse()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Reverse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.MatineeActor.SetLoopingState
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewLooping                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatineeActor::SetLoopingState(bool bNewLooping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLoopingState");

	Params::MatineeActor_SetLoopingState Parms{};

	Parms.bNewLooping = bNewLooping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MatineeActor.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bJump                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMatineeActor::SetPosition(float NewPosition, bool bJump)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPosition");

	Params::MatineeActor_SetPosition Parms{};

	Parms.NewPosition = NewPosition;
	Parms.bJump = bJump;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.MatineeActor.Stop
// (Native, Public, BlueprintCallable)

void AMatineeActor::Stop()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Stop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.NetPushModelHelpers.MarkPropertyDirty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNetPushModelHelpers::MarkPropertyDirty(class UObject* Object, class FName PropertyName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MarkPropertyDirty");

	Params::NetPushModelHelpers_MarkPropertyDirty Parms{};

	Parms.Object = Object;
	Parms.PropertyName = PropertyName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.NetPushModelHelpers.MarkPropertyDirtyFromRepIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RepIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNetPushModelHelpers::MarkPropertyDirtyFromRepIndex(class UObject* Object, int32 RepIndex, class FName PropertyName)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("MarkPropertyDirtyFromRepIndex");

	Params::NetPushModelHelpers_MarkPropertyDirtyFromRepIndex Parms{};

	Parms.Object = Object;
	Parms.RepIndex = RepIndex;
	Parms.PropertyName = PropertyName;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.GrabComponent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GrabLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConstrainRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::GrabComponent(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GrabComponent");

	Params::PhysicsHandleComponent_GrabComponent Parms{};

	Parms.Component = Component;
	Parms.InBoneName = InBoneName;
	Parms.GrabLocation = std::move(GrabLocation);
	Parms.bConstrainRotation = bConstrainRotation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.GrabComponentAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GrabLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::GrabComponentAtLocation(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& GrabLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GrabComponentAtLocation");

	Params::PhysicsHandleComponent_GrabComponentAtLocation Parms{};

	Parms.Component = Component;
	Parms.InBoneName = InBoneName;
	Parms.GrabLocation = std::move(GrabLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.GrabComponentAtLocationWithRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::GrabComponentAtLocationWithRotation(class UPrimitiveComponent* Component, class FName InBoneName, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GrabComponentAtLocationWithRotation");

	Params::PhysicsHandleComponent_GrabComponentAtLocationWithRotation Parms{};

	Parms.Component = Component;
	Parms.InBoneName = InBoneName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.ReleaseComponent
// (Native, Public, BlueprintCallable)

void UPhysicsHandleComponent::ReleaseComponent()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReleaseComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.PhysicsHandleComponent.SetAngularDamping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewAngularDamping                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetAngularDamping(float NewAngularDamping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularDamping");

	Params::PhysicsHandleComponent_SetAngularDamping Parms{};

	Parms.NewAngularDamping = NewAngularDamping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.SetAngularStiffness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewAngularStiffness                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetAngularStiffness(float NewAngularStiffness)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetAngularStiffness");

	Params::PhysicsHandleComponent_SetAngularStiffness Parms{};

	Parms.NewAngularStiffness = NewAngularStiffness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.SetInterpolationSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewInterpolationSpeed                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetInterpolationSpeed(float NewInterpolationSpeed)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetInterpolationSpeed");

	Params::PhysicsHandleComponent_SetInterpolationSpeed Parms{};

	Parms.NewInterpolationSpeed = NewInterpolationSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.SetLinearDamping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLinearDamping                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetLinearDamping(float NewLinearDamping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearDamping");

	Params::PhysicsHandleComponent_SetLinearDamping Parms{};

	Parms.NewLinearDamping = NewLinearDamping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.SetLinearStiffness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLinearStiffness                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetLinearStiffness(float NewLinearStiffness)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearStiffness");

	Params::PhysicsHandleComponent_SetLinearStiffness Parms{};

	Parms.NewLinearStiffness = NewLinearStiffness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.SetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetTargetLocation(const struct FVector& NewLocation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTargetLocation");

	Params::PhysicsHandleComponent_SetTargetLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetTargetLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTargetLocationAndRotation");

	Params::PhysicsHandleComponent_SetTargetLocationAndRotation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.NewRotation = std::move(NewRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.SetTargetRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::SetTargetRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTargetRotation");

	Params::PhysicsHandleComponent_SetTargetRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PhysicsHandleComponent.GetGrabbedComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UPhysicsHandleComponent::GetGrabbedComponent() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetGrabbedComponent");

	Params::PhysicsHandleComponent_GetGrabbedComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          TargetLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         TargetRotation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UPhysicsHandleComponent::GetTargetLocationAndRotation(struct FVector* TargetLocation, struct FRotator* TargetRotation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTargetLocationAndRotation");

	Params::PhysicsHandleComponent_GetTargetLocationAndRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TargetLocation != nullptr)
		*TargetLocation = std::move(Parms.TargetLocation);

	if (TargetRotation != nullptr)
		*TargetRotation = std::move(Parms.TargetRotation);
}


// Function Engine.PlanarReflection.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlanarReflection::OnInterpToggle(bool bEnable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnInterpToggle");

	Params::PlanarReflection_OnInterpToggle Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PlatformEventsComponent.IsInLaptopMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformEventsComponent::IsInLaptopMode()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInLaptopMode");

	Params::PlatformEventsComponent_IsInLaptopMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlatformEventsComponent.IsInTabletMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformEventsComponent::IsInTabletMode()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsInTabletMode");

	Params::PlatformEventsComponent_IsInTabletMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlatformEventsComponent::SupportsConvertibleLaptops()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SupportsConvertibleLaptops");

	Params::PlatformEventsComponent_SupportsConvertibleLaptops Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlatformInterfaceWebResponse.GetHeader
// (Native, Public, HasOutParams)
// Parameters:
// int32                                   HeaderIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Header                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatformInterfaceWebResponse::GetHeader(int32 HeaderIndex, class FString* Header, class FString* Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHeader");

	Params::PlatformInterfaceWebResponse_GetHeader Parms{};

	Parms.HeaderIndex = HeaderIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Header != nullptr)
		*Header = std::move(Parms.Header);

	if (Value != nullptr)
		*Value = std::move(Parms.Value);
}


// Function Engine.PlatformInterfaceWebResponse.GetHeaderValue
// (Native, Public)
// Parameters:
// class FString                           HeaderName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UPlatformInterfaceWebResponse::GetHeaderValue(const class FString& HeaderName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetHeaderValue");

	Params::PlatformInterfaceWebResponse_GetHeaderValue Parms{};

	Parms.HeaderName = std::move(HeaderName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PlatformInterfaceWebResponse.GetNumHeaders
// (Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlatformInterfaceWebResponse::GetNumHeaders()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumHeaders");

	Params::PlatformInterfaceWebResponse_GetNumHeaders Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PointLight.SetLightFalloffExponent
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLightFalloffExponent                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APointLight::SetLightFalloffExponent(float NewLightFalloffExponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightFalloffExponent");

	Params::PointLight_SetLightFalloffExponent Parms{};

	Parms.NewLightFalloffExponent = NewLightFalloffExponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PointLight.SetRadius
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APointLight::SetRadius(float NewRadius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRadius");

	Params::PointLight_SetRadius Parms{};

	Parms.NewRadius = NewRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PoseableMeshComponent.CopyPoseFromSkeletalComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InComponentToCopy                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::CopyPoseFromSkeletalComponent(class USkeletalMeshComponent* InComponentToCopy)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CopyPoseFromSkeletalComponent");

	Params::PoseableMeshComponent_CopyPoseFromSkeletalComponent Parms{};

	Parms.InComponentToCopy = InComponentToCopy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PoseableMeshComponent.GetBoneLocationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoneSpaces                             BoneSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPoseableMeshComponent::GetBoneLocationByName(class FName BoneName, EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneLocationByName");

	Params::PoseableMeshComponent_GetBoneLocationByName Parms{};

	Parms.BoneName = BoneName;
	Parms.BoneSpace = BoneSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PoseableMeshComponent.GetBoneRotationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoneSpaces                             BoneSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UPoseableMeshComponent::GetBoneRotationByName(class FName BoneName, EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneRotationByName");

	Params::PoseableMeshComponent_GetBoneRotationByName Parms{};

	Parms.BoneName = BoneName;
	Parms.BoneSpace = BoneSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PoseableMeshComponent.GetBoneScaleByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoneSpaces                             BoneSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPoseableMeshComponent::GetBoneScaleByName(class FName BoneName, EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneScaleByName");

	Params::PoseableMeshComponent_GetBoneScaleByName Parms{};

	Parms.BoneName = BoneName;
	Parms.BoneSpace = BoneSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PoseableMeshComponent.GetBoneTransformByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoneSpaces                             BoneSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UPoseableMeshComponent::GetBoneTransformByName(class FName BoneName, EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoneTransformByName");

	Params::PoseableMeshComponent_GetBoneTransformByName Parms{};

	Parms.BoneName = BoneName;
	Parms.BoneSpace = BoneSpace;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.PoseableMeshComponent.ResetBoneTransformByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::ResetBoneTransformByName(class FName BoneName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ResetBoneTransformByName");

	Params::PoseableMeshComponent_ResetBoneTransformByName Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PoseableMeshComponent.SetBoneLocationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoneSpaces                             BoneSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::SetBoneLocationByName(class FName BoneName, const struct FVector& InLocation, EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoneLocationByName");

	Params::PoseableMeshComponent_SetBoneLocationByName Parms{};

	Parms.BoneName = BoneName;
	Parms.InLocation = std::move(InLocation);
	Parms.BoneSpace = BoneSpace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PoseableMeshComponent.SetBoneRotationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EBoneSpaces                             BoneSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::SetBoneRotationByName(class FName BoneName, const struct FRotator& InRotation, EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoneRotationByName");

	Params::PoseableMeshComponent_SetBoneRotationByName Parms{};

	Parms.BoneName = BoneName;
	Parms.InRotation = std::move(InRotation);
	Parms.BoneSpace = BoneSpace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PoseableMeshComponent.SetBoneScaleByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InScale3D                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoneSpaces                             BoneSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::SetBoneScaleByName(class FName BoneName, const struct FVector& InScale3D, EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoneScaleByName");

	Params::PoseableMeshComponent_SetBoneScaleByName Parms{};

	Parms.BoneName = BoneName;
	Parms.InScale3D = std::move(InScale3D);
	Parms.BoneSpace = BoneSpace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.PoseableMeshComponent.SetBoneTransformByName
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EBoneSpaces                             BoneSpace                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseableMeshComponent::SetBoneTransformByName(class FName BoneName, const struct FTransform& InTransform, EBoneSpaces BoneSpace)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBoneTransformByName");

	Params::PoseableMeshComponent_SetBoneTransformByName Parms{};

	Parms.BoneName = BoneName;
	Parms.InTransform = std::move(InTransform);
	Parms.BoneSpace = BoneSpace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.RectLightComponent.SetBarnDoorAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetBarnDoorAngle(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBarnDoorAngle");

	Params::RectLightComponent_SetBarnDoorAngle Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.RectLightComponent.SetBarnDoorLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetBarnDoorLength(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetBarnDoorLength");

	Params::RectLightComponent_SetBarnDoorLength Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.RectLightComponent.SetSourceHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetSourceHeight(float NewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSourceHeight");

	Params::RectLightComponent_SetSourceHeight Parms{};

	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.RectLightComponent.SetSourceTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetSourceTexture(class UTexture* bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSourceTexture");

	Params::RectLightComponent_SetSourceTexture Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.RectLightComponent.SetSourceWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URectLightComponent::SetSourceWidth(float bNewValue)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSourceWidth");

	Params::RectLightComponent_SetSourceWidth Parms{};

	Parms.bNewValue = bNewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ReplaySubsystem.RequestCheckpoint
// (Final, Native, Public, BlueprintCallable)

void UReplaySubsystem::RequestCheckpoint()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RequestCheckpoint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.ReplaySubsystem.GetActiveReplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UReplaySubsystem::GetActiveReplayName() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetActiveReplayName");

	Params::ReplaySubsystem_GetActiveReplayName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ReplaySubsystem.GetReplayCurrentTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UReplaySubsystem::GetReplayCurrentTime() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetReplayCurrentTime");

	Params::ReplaySubsystem_GetReplayCurrentTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ReplaySubsystem.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UReplaySubsystem::IsPlaying() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlaying");

	Params::ReplaySubsystem_IsPlaying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ReplaySubsystem.IsRecording
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UReplaySubsystem::IsRecording() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsRecording");

	Params::ReplaySubsystem_IsRecording Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.RuntimeVirtualTextureComponent.Invalidate
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBoxSphereBounds                 WorldBounds                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void URuntimeVirtualTextureComponent::Invalidate(const struct FBoxSphereBounds& WorldBounds)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Invalidate");

	Params::RuntimeVirtualTextureComponent_Invalidate Parms{};

	Parms.WorldBounds = std::move(WorldBounds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCapture2D.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASceneCapture2D::OnInterpToggle(bool bEnable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnInterpToggle");

	Params::SceneCapture2D_OnInterpToggle Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SceneCaptureComponentCube.CaptureScene
// (Final, Native, Public, BlueprintCallable)

void USceneCaptureComponentCube::CaptureScene()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CaptureScene");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SceneCaptureCube.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASceneCaptureCube::OnInterpToggle(bool bEnable)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnInterpToggle");

	Params::SceneCaptureCube_OnInterpToggle Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.RecaptureSky
// (Final, Native, Public, BlueprintCallable)

void USkyLightComponent::RecaptureSky()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RecaptureSky");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.SkyLightComponent.SetCubemap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureCube*                     NewCubemap                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetCubemap(class UTextureCube* NewCubemap)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCubemap");

	Params::SkyLightComponent_SetCubemap Parms{};

	Parms.NewCubemap = NewCubemap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetCubemapBlend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureCube*                     SourceCubemap                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureCube*                     DestinationCubemap                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendFraction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetCubemapBlend(class UTextureCube* SourceCubemap, class UTextureCube* DestinationCubemap, float InBlendFraction)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetCubemapBlend");

	Params::SkyLightComponent_SetCubemapBlend Parms{};

	Parms.SourceCubemap = SourceCubemap;
	Parms.DestinationCubemap = DestinationCubemap;
	Parms.InBlendFraction = InBlendFraction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetIndirectLightingIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetIndirectLightingIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIndirectLightingIntensity");

	Params::SkyLightComponent_SetIndirectLightingIntensity Parms{};

	Parms.NewIntensity = NewIntensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIntensity");

	Params::SkyLightComponent_SetIntensity Parms{};

	Parms.NewIntensity = NewIntensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     NewLightColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetLightColor(const struct FLinearColor& NewLightColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLightColor");

	Params::SkyLightComponent_SetLightColor Parms{};

	Parms.NewLightColor = std::move(NewLightColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetLowerHemisphereColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InLowerHemisphereColor                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetLowerHemisphereColor(const struct FLinearColor& InLowerHemisphereColor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLowerHemisphereColor");

	Params::SkyLightComponent_SetLowerHemisphereColor Parms{};

	Parms.InLowerHemisphereColor = std::move(InLowerHemisphereColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetMinOcclusion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InMinOcclusion                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetMinOcclusion(float InMinOcclusion)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinOcclusion");

	Params::SkyLightComponent_SetMinOcclusion Parms{};

	Parms.InMinOcclusion = InMinOcclusion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetOcclusionContrast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOcclusionContrast                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetOcclusionContrast(float InOcclusionContrast)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOcclusionContrast");

	Params::SkyLightComponent_SetOcclusionContrast Parms{};

	Parms.InOcclusionContrast = InOcclusionContrast;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetOcclusionExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOcclusionExponent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetOcclusionExponent(float InOcclusionExponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOcclusionExponent");

	Params::SkyLightComponent_SetOcclusionExponent Parms{};

	Parms.InOcclusionExponent = InOcclusionExponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetOcclusionTint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                           InTint                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetOcclusionTint(const struct FColor& InTint)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOcclusionTint");

	Params::SkyLightComponent_SetOcclusionTint Parms{};

	Parms.InTint = std::move(InTint);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SkyLightComponent.SetVolumetricScatteringIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkyLightComponent::SetVolumetricScatteringIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVolumetricScatteringIntensity");

	Params::SkyLightComponent_SetVolumetricScatteringIntensity Parms{};

	Parms.NewIntensity = NewIntensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.AddEnvelopeFollowerDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<float>& Envelope)>OnSubmixEnvelopeBP                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USoundSubmix::AddEnvelopeFollowerDelegate(const class UObject* WorldContextObject, const TDelegate<void(TArray<float>& Envelope)>& OnSubmixEnvelopeBP)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddEnvelopeFollowerDelegate");

	Params::SoundSubmix_AddEnvelopeFollowerDelegate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OnSubmixEnvelopeBP = OnSubmixEnvelopeBP;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.AddSpectralAnalysisDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoundSubmixSpectralAnalysisBandSettings>InBandSettings                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<float>& Magnitude)>OnSubmixSpectralAnalysisBP                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   UpdateRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DecibelNoiseFloor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoNormalize                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoAutoRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AutoRangeAttackTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AutoRangeReleaseTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::AddSpectralAnalysisDelegate(const class UObject* WorldContextObject, const TArray<struct FSoundSubmixSpectralAnalysisBandSettings>& InBandSettings, const TDelegate<void(TArray<float>& Magnitude)>& OnSubmixSpectralAnalysisBP, float UpdateRate, float DecibelNoiseFloor, bool bDoNormalize, bool bDoAutoRange, float AutoRangeAttackTime, float AutoRangeReleaseTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddSpectralAnalysisDelegate");

	Params::SoundSubmix_AddSpectralAnalysisDelegate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InBandSettings = std::move(InBandSettings);
	Parms.OnSubmixSpectralAnalysisBP = OnSubmixSpectralAnalysisBP;
	Parms.UpdateRate = UpdateRate;
	Parms.DecibelNoiseFloor = DecibelNoiseFloor;
	Parms.bDoNormalize = bDoNormalize;
	Parms.bDoAutoRange = bDoAutoRange;
	Parms.AutoRangeAttackTime = AutoRangeAttackTime;
	Parms.AutoRangeReleaseTime = AutoRangeReleaseTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.RemoveSpectralAnalysisDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<float>& Magnitude)>OnSubmixSpectralAnalysisBP                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USoundSubmix::RemoveSpectralAnalysisDelegate(const class UObject* WorldContextObject, const TDelegate<void(TArray<float>& Magnitude)>& OnSubmixSpectralAnalysisBP)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveSpectralAnalysisDelegate");

	Params::SoundSubmix_RemoveSpectralAnalysisDelegate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OnSubmixSpectralAnalysisBP = OnSubmixSpectralAnalysisBP;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.SetSubmixOutputVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InOutputVolume                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::SetSubmixOutputVolume(const class UObject* WorldContextObject, float InOutputVolume)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSubmixOutputVolume");

	Params::SoundSubmix_SetSubmixOutputVolume Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InOutputVolume = InOutputVolume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.StartEnvelopeFollowing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StartEnvelopeFollowing(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartEnvelopeFollowing");

	Params::SoundSubmix_StartEnvelopeFollowing Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.StartRecordingOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExpectedDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StartRecordingOutput(const class UObject* WorldContextObject, float ExpectedDuration)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartRecordingOutput");

	Params::SoundSubmix_StartRecordingOutput Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ExpectedDuration = ExpectedDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.StartSpectralAnalysis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFFTSize                                FFTSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFFTPeakInterpolationMethod             InterpolationMethod                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFFTWindowType                          WindowType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HopSize                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAudioSpectrumType                      SpectrumType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StartSpectralAnalysis(const class UObject* WorldContextObject, EFFTSize FFTSize, EFFTPeakInterpolationMethod InterpolationMethod, EFFTWindowType WindowType, float HopSize, EAudioSpectrumType SpectrumType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StartSpectralAnalysis");

	Params::SoundSubmix_StartSpectralAnalysis Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FFTSize = FFTSize;
	Parms.InterpolationMethod = InterpolationMethod;
	Parms.WindowType = WindowType;
	Parms.HopSize = HopSize;
	Parms.SpectrumType = SpectrumType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.StopEnvelopeFollowing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StopEnvelopeFollowing(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopEnvelopeFollowing");

	Params::SoundSubmix_StopEnvelopeFollowing Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.StopRecordingOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAudioRecordingExportType               ExportType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundWave*                       ExistingSoundWaveToOverwrite                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StopRecordingOutput(const class UObject* WorldContextObject, EAudioRecordingExportType ExportType, const class FString& Name_0, const class FString& Path, class USoundWave* ExistingSoundWaveToOverwrite)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopRecordingOutput");

	Params::SoundSubmix_StopRecordingOutput Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ExportType = ExportType;
	Parms.Name_0 = std::move(Name_0);
	Parms.Path = std::move(Path);
	Parms.ExistingSoundWaveToOverwrite = ExistingSoundWaveToOverwrite;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmix.StopSpectralAnalysis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USoundSubmix::StopSpectralAnalysis(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("StopSpectralAnalysis");

	Params::SoundSubmix_StopSpectralAnalysis Parms{};

	Parms.WorldContextObject = WorldContextObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SoundSubmixWidgetInterface.OnConstructed
// (Event, Public, BlueprintEvent)
// Parameters:
// class USoundSubmixBase*                 SoundSubmix                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISoundSubmixWidgetInterface::OnConstructed(class USoundSubmixBase* SoundSubmix)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnConstructed");

	Params::SoundSubmixWidgetInterface_OnConstructed Parms{};

	Parms.SoundSubmix = SoundSubmix;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.SpringArmComponent.GetTargetRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator USpringArmComponent::GetTargetRotation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTargetRotation");

	Params::SpringArmComponent_GetTargetRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SpringArmComponent.GetUnfixedCameraPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USpringArmComponent::GetUnfixedCameraPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUnfixedCameraPosition");

	Params::SpringArmComponent_GetUnfixedCameraPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SpringArmComponent.IsCollisionFixApplied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpringArmComponent::IsCollisionFixApplied() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsCollisionFixApplied");

	Params::SpringArmComponent_IsCollisionFixApplied Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.CreateStaticMeshDescription
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshDescription*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshDescription* UStaticMesh::CreateStaticMeshDescription(class UObject* Outer_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("CreateStaticMeshDescription");

	Params::StaticMesh_CreateStaticMeshDescription Parms{};

	Parms.Outer_0 = Outer_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.AddMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UStaticMesh::AddMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddMaterial");

	Params::StaticMesh_AddMaterial Parms{};

	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.AddSocket
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshSocket*                Socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMesh::AddSocket(class UStaticMeshSocket* Socket)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddSocket");

	Params::StaticMesh_AddSocket Parms{};

	Parms.Socket = Socket;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMesh.BuildFromStaticMeshDescriptions
// (Final, RequiredAPI, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UStaticMeshDescription*>   StaticMeshDescriptions                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bBuildSimpleCollision                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFastBuild                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMesh::BuildFromStaticMeshDescriptions(const TArray<class UStaticMeshDescription*>& StaticMeshDescriptions, bool bBuildSimpleCollision, bool bFastBuild)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("BuildFromStaticMeshDescriptions");

	Params::StaticMesh_BuildFromStaticMeshDescriptions Parms{};

	Parms.StaticMeshDescriptions = std::move(StaticMeshDescriptions);
	Parms.bBuildSimpleCollision = bBuildSimpleCollision;
	Parms.bFastBuild = bFastBuild;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMesh.GetStaticMeshDescription
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshDescription*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshDescription* UStaticMesh::GetStaticMeshDescription(int32 LODIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStaticMeshDescription");

	Params::StaticMesh_GetStaticMeshDescription Parms{};

	Parms.LODIndex = LODIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.RemoveSocket
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshSocket*                Socket                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStaticMesh::RemoveSocket(class UStaticMeshSocket* Socket)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveSocket");

	Params::StaticMesh_RemoveSocket Parms{};

	Parms.Socket = Socket;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMesh.SetStaticMaterials
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FStaticMaterial>          InStaticMaterials                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UStaticMesh::SetStaticMaterials(const TArray<struct FStaticMaterial>& InStaticMaterials)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStaticMaterials");

	Params::StaticMesh_SetStaticMaterials Parms{};

	Parms.InStaticMaterials = std::move(InStaticMaterials);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StaticMesh.FindSocket
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshSocket*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshSocket* UStaticMesh::FindSocket(class FName InSocketName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("FindSocket");

	Params::StaticMesh_FindSocket Parms{};

	Parms.InSocketName = InSocketName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetBoundingBox
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UStaticMesh::GetBoundingBox() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBoundingBox");

	Params::StaticMesh_GetBoundingBox Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetBounds
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds UStaticMesh::GetBounds() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetBounds");

	Params::StaticMesh_GetBounds Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   MaterialIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UStaticMesh::GetMaterial(int32 MaterialIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterial");

	Params::StaticMesh_GetMaterial Parms{};

	Parms.MaterialIndex = MaterialIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetMaterialIndex
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             MaterialSlotName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStaticMesh::GetMaterialIndex(class FName MaterialSlotName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMaterialIndex");

	Params::StaticMesh_GetMaterialIndex Parms{};

	Parms.MaterialSlotName = MaterialSlotName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetMinimumLODForPlatform
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             PlatformName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStaticMesh::GetMinimumLODForPlatform(const class FName& PlatformName) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinimumLODForPlatform");

	Params::StaticMesh_GetMinimumLODForPlatform Parms{};

	Parms.PlatformName = PlatformName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetMinimumLODForPlatforms
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                PlatformMinimumLODs                                    (Parm, OutParm, NativeAccessSpecifierPublic)

void UStaticMesh::GetMinimumLODForPlatforms(TMap<class FName, int32>* PlatformMinimumLODs) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinimumLODForPlatforms");

	Params::StaticMesh_GetMinimumLODForPlatforms Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlatformMinimumLODs != nullptr)
		*PlatformMinimumLODs = std::move(Parms.PlatformMinimumLODs);
}


// Function Engine.StaticMesh.GetMinimumLODForQualityLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             QualityLevel                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStaticMesh::GetMinimumLODForQualityLevel(const class FName& QualityLevel) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinimumLODForQualityLevel");

	Params::StaticMesh_GetMinimumLODForQualityLevel Parms{};

	Parms.QualityLevel = QualityLevel;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetMinimumLODForQualityLevels
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class FName, int32>                QualityLevelMinimumLODs                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UStaticMesh::GetMinimumLODForQualityLevels(TMap<class FName, int32>* QualityLevelMinimumLODs) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetMinimumLODForQualityLevels");

	Params::StaticMesh_GetMinimumLODForQualityLevels Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (QualityLevelMinimumLODs != nullptr)
		*QualityLevelMinimumLODs = std::move(Parms.QualityLevelMinimumLODs);
}


// Function Engine.StaticMesh.GetNumLODs
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStaticMesh::GetNumLODs() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumLODs");

	Params::StaticMesh_GetNumLODs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetNumSections
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InLOD                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStaticMesh::GetNumSections(int32 InLOD) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumSections");

	Params::StaticMesh_GetNumSections Parms{};

	Parms.InLOD = InLOD;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StaticMesh.GetStaticMaterials
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FStaticMaterial>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FStaticMaterial> UStaticMesh::GetStaticMaterials() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetStaticMaterials");

	Params::StaticMesh_GetStaticMaterials Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StereoLayerShapeCylinder.SetHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerShapeCylinder::SetHeight(int32 InHeight)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHeight");

	Params::StereoLayerShapeCylinder_SetHeight Parms{};

	Parms.InHeight = InHeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerShapeCylinder.SetOverlayArc
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InOverlayArc                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerShapeCylinder::SetOverlayArc(float InOverlayArc)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetOverlayArc");

	Params::StereoLayerShapeCylinder_SetOverlayArc Parms{};

	Parms.InOverlayArc = InOverlayArc;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerShapeCylinder.SetRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerShapeCylinder::SetRadius(float InRadius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRadius");

	Params::StereoLayerShapeCylinder_SetRadius Parms{};

	Parms.InRadius = InRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerShapeEquirect.SetEquirectProps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FEquirectProps                   InScaleBiases                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UStereoLayerShapeEquirect::SetEquirectProps(const struct FEquirectProps& InScaleBiases)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEquirectProps");

	Params::StereoLayerShapeEquirect_SetEquirectProps Parms{};

	Parms.InScaleBiases = std::move(InScaleBiases);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerComponent.MarkTextureForUpdate
// (Final, Native, Public, BlueprintCallable)

void UStereoLayerComponent::MarkTextureForUpdate()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("MarkTextureForUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.StereoLayerComponent.SetEquirectProps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FEquirectProps                   InScaleBiases                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetEquirectProps(const struct FEquirectProps& InScaleBiases)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetEquirectProps");

	Params::StereoLayerComponent_SetEquirectProps Parms{};

	Parms.InScaleBiases = std::move(InScaleBiases);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerComponent.SetLeftTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         InTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetLeftTexture(class UTexture* InTexture)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLeftTexture");

	Params::StereoLayerComponent_SetLeftTexture Parms{};

	Parms.InTexture = InTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerComponent.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetPriority(int32 InPriority)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPriority");

	Params::StereoLayerComponent_SetPriority Parms{};

	Parms.InPriority = InPriority;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerComponent.SetQuadSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InQuadSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetQuadSize(const struct FVector2D& InQuadSize)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetQuadSize");

	Params::StereoLayerComponent_SetQuadSize Parms{};

	Parms.InQuadSize = std::move(InQuadSize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerComponent.SetTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         InTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetTexture(class UTexture* InTexture)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTexture");

	Params::StereoLayerComponent_SetTexture Parms{};

	Parms.InTexture = InTexture;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerComponent.SetUVRect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBox2D                           InUVRect                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UStereoLayerComponent::SetUVRect(const struct FBox2D& InUVRect)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetUVRect");

	Params::StereoLayerComponent_SetUVRect Parms{};

	Parms.InUVRect = std::move(InUVRect);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerComponent.GetLeftTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UStereoLayerComponent::GetLeftTexture() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetLeftTexture");

	Params::StereoLayerComponent_GetLeftTexture Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StereoLayerComponent.GetPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UStereoLayerComponent::GetPriority() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPriority");

	Params::StereoLayerComponent_GetPriority Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StereoLayerComponent.GetQuadSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UStereoLayerComponent::GetQuadSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetQuadSize");

	Params::StereoLayerComponent_GetQuadSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StereoLayerComponent.GetTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UStereoLayerComponent::GetTexture() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTexture");

	Params::StereoLayerComponent_GetTexture Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StereoLayerComponent.GetUVRect
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox2D                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FBox2D UStereoLayerComponent::GetUVRect() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetUVRect");

	Params::StereoLayerComponent_GetUVRect Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.StereoLayerFunctionLibrary.EnableAutoLoadingSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InAutoShowEnabled                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerFunctionLibrary::EnableAutoLoadingSplashScreen(bool InAutoShowEnabled)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EnableAutoLoadingSplashScreen");

	Params::StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen Parms{};

	Parms.InAutoShowEnabled = InAutoShowEnabled;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerFunctionLibrary.HideSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)

void UStereoLayerFunctionLibrary::HideSplashScreen()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("HideSplashScreen");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.StereoLayerFunctionLibrary.SetSplashScreen
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowLoadingMovie                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowOnSet                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStereoLayerFunctionLibrary::SetSplashScreen(class UTexture* Texture, const struct FVector2D& Scale, const struct FVector& Offset, bool bShowLoadingMovie, bool bShowOnSet)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("SetSplashScreen");

	Params::StereoLayerFunctionLibrary_SetSplashScreen Parms{};

	Parms.Texture = Texture;
	Parms.Scale = std::move(Scale);
	Parms.Offset = std::move(Offset);
	Parms.bShowLoadingMovie = bShowLoadingMovie;
	Parms.bShowOnSet = bShowOnSet;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.StereoLayerFunctionLibrary.ShowSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)

void UStereoLayerFunctionLibrary::ShowSplashScreen()
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("ShowSplashScreen");

	StaticClss->DefaultObject->ProcessEvent(Func, nullptr);
}


// Function Engine.SubsystemBlueprintLibrary.GetAudioEngineSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAudioEngineSubsystem>Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioEngineSubsystem*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioEngineSubsystem* USubsystemBlueprintLibrary::GetAudioEngineSubsystem(class UObject* ContextObject, TSubclassOf<class UAudioEngineSubsystem> Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetAudioEngineSubsystem");

	Params::SubsystemBlueprintLibrary_GetAudioEngineSubsystem Parms{};

	Parms.ContextObject = ContextObject;
	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetEngineSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UEngineSubsystem>     Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEngineSubsystem*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEngineSubsystem* USubsystemBlueprintLibrary::GetEngineSubsystem(TSubclassOf<class UEngineSubsystem> Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetEngineSubsystem");

	Params::SubsystemBlueprintLibrary_GetEngineSubsystem Parms{};

	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetGameInstanceSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameInstanceSubsystem>Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameInstanceSubsystem*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameInstanceSubsystem* USubsystemBlueprintLibrary::GetGameInstanceSubsystem(class UObject* ContextObject, TSubclassOf<class UGameInstanceSubsystem> Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetGameInstanceSubsystem");

	Params::SubsystemBlueprintLibrary_GetGameInstanceSubsystem Parms{};

	Parms.ContextObject = ContextObject;
	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULocalPlayerSubsystem>Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULocalPlayerSubsystem*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayerSubsystem* USubsystemBlueprintLibrary::GetLocalPlayerSubsystem(class UObject* ContextObject, TSubclassOf<class ULocalPlayerSubsystem> Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLocalPlayerSubsystem");

	Params::SubsystemBlueprintLibrary_GetLocalPlayerSubsystem Parms{};

	Parms.ContextObject = ContextObject;
	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubSystemFromPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ULocalPlayerSubsystem>Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULocalPlayerSubsystem*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayerSubsystem* USubsystemBlueprintLibrary::GetLocalPlayerSubSystemFromPlayerController(class APlayerController* PlayerController, TSubclassOf<class ULocalPlayerSubsystem> Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetLocalPlayerSubSystemFromPlayerController");

	Params::SubsystemBlueprintLibrary_GetLocalPlayerSubSystemFromPlayerController Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetWorldSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UWorldSubsystem>      Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorldSubsystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorldSubsystem* USubsystemBlueprintLibrary::GetWorldSubsystem(class UObject* ContextObject, TSubclassOf<class UWorldSubsystem> Class_0)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("GetWorldSubsystem");

	Params::SubsystemBlueprintLibrary_GetWorldSubsystem Parms{};

	Parms.ContextObject = ContextObject;
	Parms.Class_0 = Class_0;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TextRenderComponent.K2_SetText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Value                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTextRenderComponent::K2_SetText(const class FText& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("K2_SetText");

	Params::TextRenderComponent_K2_SetText Parms{};

	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetFont
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFont*                            Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetFont(class UFont* Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFont");

	Params::TextRenderComponent_SetFont Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizTextAligment                      Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetHorizontalAlignment(EHorizTextAligment Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizontalAlignment");

	Params::TextRenderComponent_SetHorizontalAlignment Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetHorizSpacingAdjust
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetHorizSpacingAdjust(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetHorizSpacingAdjust");

	Params::TextRenderComponent_SetHorizSpacingAdjust Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetTextMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetTextMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextMaterial");

	Params::TextRenderComponent_SetTextMaterial Parms{};

	Parms.Material = Material;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetTextRenderColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                           Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetTextRenderColor(const struct FColor& Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTextRenderColor");

	Params::TextRenderComponent_SetTextRenderColor Parms{};

	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalTextAligment                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetVerticalAlignment(EVerticalTextAligment Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVerticalAlignment");

	Params::TextRenderComponent_SetVerticalAlignment Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetVertSpacingAdjust
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetVertSpacingAdjust(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVertSpacingAdjust");

	Params::TextRenderComponent_SetVertSpacingAdjust Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetWorldSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetWorldSize(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWorldSize");

	Params::TextRenderComponent_SetWorldSize Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetXScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetXScale(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetXScale");

	Params::TextRenderComponent_SetXScale Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.SetYScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextRenderComponent::SetYScale(float Value)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetYScale");

	Params::TextRenderComponent_SetYScale Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TextRenderComponent.GetTextLocalSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTextRenderComponent::GetTextLocalSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTextLocalSize");

	Params::TextRenderComponent_GetTextLocalSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TextRenderComponent.GetTextWorldSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTextRenderComponent::GetTextWorldSize() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTextWorldSize");

	Params::TextRenderComponent_GetTextWorldSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimelineComponent.OnRep_Timeline
// (Final, Native, Public)

void UTimelineComponent::OnRep_Timeline()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Timeline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.TimelineComponent.Play
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UTimelineComponent::Play()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Play");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.TimelineComponent.PlayFromStart
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UTimelineComponent::PlayFromStart()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("PlayFromStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.TimelineComponent.Reverse
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UTimelineComponent::Reverse()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Reverse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.TimelineComponent.ReverseFromEnd
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UTimelineComponent::ReverseFromEnd()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReverseFromEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.TimelineComponent.SetFloatCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveFloat*                      NewFloatCurve                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FloatTrackName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetFloatCurve(class UCurveFloat* NewFloatCurve, class FName FloatTrackName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetFloatCurve");

	Params::TimelineComponent_SetFloatCurve Parms{};

	Parms.NewFloatCurve = NewFloatCurve;
	Parms.FloatTrackName = FloatTrackName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetIgnoreTimeDilation
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewIgnoreTimeDilation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIgnoreTimeDilation");

	Params::TimelineComponent_SetIgnoreTimeDilation Parms{};

	Parms.bNewIgnoreTimeDilation = bNewIgnoreTimeDilation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetLinearColorCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveLinearColor*                NewLinearColorCurve                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LinearColorTrackName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetLinearColorCurve(class UCurveLinearColor* NewLinearColorCurve, class FName LinearColorTrackName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLinearColorCurve");

	Params::TimelineComponent_SetLinearColorCurve Parms{};

	Parms.NewLinearColorCurve = NewLinearColorCurve;
	Parms.LinearColorTrackName = LinearColorTrackName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetLooping
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewLooping                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetLooping(bool bNewLooping)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetLooping");

	Params::TimelineComponent_SetLooping Parms{};

	Parms.bNewLooping = bNewLooping;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetNewTime
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetNewTime(float NewTime)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNewTime");

	Params::TimelineComponent_SetNewTime Parms{};

	Parms.NewTime = NewTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetPlaybackPosition
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireEvents                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFireUpdate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlaybackPosition");

	Params::TimelineComponent_SetPlaybackPosition Parms{};

	Parms.NewPosition = NewPosition;
	Parms.bFireEvents = bFireEvents;
	Parms.bFireUpdate = bFireUpdate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetPlayRate
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetPlayRate(float NewRate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetPlayRate");

	Params::TimelineComponent_SetPlayRate Parms{};

	Parms.NewRate = NewRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetTimelineLength
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetTimelineLength(float NewLength)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTimelineLength");

	Params::TimelineComponent_SetTimelineLength Parms{};

	Parms.NewLength = NewLength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetTimelineLengthMode
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// ETimelineLengthMode                     NewLengthMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetTimelineLengthMode(ETimelineLengthMode NewLengthMode)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetTimelineLengthMode");

	Params::TimelineComponent_SetTimelineLengthMode Parms{};

	Parms.NewLengthMode = NewLengthMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.SetVectorCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveVector*                     NewVectorCurve                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             VectorTrackName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimelineComponent::SetVectorCurve(class UCurveVector* NewVectorCurve, class FName VectorTrackName)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetVectorCurve");

	Params::TimelineComponent_SetVectorCurve Parms{};

	Parms.NewVectorCurve = NewVectorCurve;
	Parms.VectorTrackName = VectorTrackName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.TimelineComponent.Stop
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UTimelineComponent::Stop()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Stop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.TimelineComponent.GetIgnoreTimeDilation
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimelineComponent::GetIgnoreTimeDilation() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetIgnoreTimeDilation");

	Params::TimelineComponent_GetIgnoreTimeDilation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimelineComponent.GetPlaybackPosition
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimelineComponent::GetPlaybackPosition() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlaybackPosition");

	Params::TimelineComponent_GetPlaybackPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimelineComponent.GetPlayRate
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimelineComponent::GetPlayRate() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPlayRate");

	Params::TimelineComponent_GetPlayRate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimelineComponent.GetTimelineLength
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimelineComponent::GetTimelineLength() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTimelineLength");

	Params::TimelineComponent_GetTimelineLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimelineComponent.IsLooping
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimelineComponent::IsLooping() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsLooping");

	Params::TimelineComponent_IsLooping Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimelineComponent.IsPlaying
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimelineComponent::IsPlaying() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsPlaying");

	Params::TimelineComponent_IsPlaying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TimelineComponent.IsReversing
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimelineComponent::IsReversing() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsReversing");

	Params::TimelineComponent_IsReversing Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.AuthorizeAccounts
// (Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwitterIntegrationBase::AuthorizeAccounts()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AuthorizeAccounts");

	Params::TwitterIntegrationBase_AuthorizeAccounts Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.CanShowTweetUI
// (Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwitterIntegrationBase::CanShowTweetUI()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CanShowTweetUI");

	Params::TwitterIntegrationBase_CanShowTweetUI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.GetAccountName
// (Native, Public)
// Parameters:
// int32                                   AccountIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTwitterIntegrationBase::GetAccountName(int32 AccountIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetAccountName");

	Params::TwitterIntegrationBase_GetAccountName Parms{};

	Parms.AccountIndex = AccountIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.GetNumAccounts
// (Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTwitterIntegrationBase::GetNumAccounts()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetNumAccounts");

	Params::TwitterIntegrationBase_GetNumAccounts Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.Init
// (Native, Public)

void UTwitterIntegrationBase::Init()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Init");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.TwitterIntegrationBase.ShowTweetUI
// (Native, Public)
// Parameters:
// class FString                           InitialMessage                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Picture                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwitterIntegrationBase::ShowTweetUI(const class FString& InitialMessage, const class FString& URL, const class FString& Picture)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ShowTweetUI");

	Params::TwitterIntegrationBase_ShowTweetUI Parms{};

	Parms.InitialMessage = std::move(InitialMessage);
	Parms.URL = std::move(URL);
	Parms.Picture = std::move(Picture);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.TwitterRequest
// (Native, Public, HasOutParams)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ParamKeysAndValues                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ETwitterRequestMethod                   RequestMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AccountIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTwitterIntegrationBase::TwitterRequest(const class FString& URL, const TArray<class FString>& ParamKeysAndValues, ETwitterRequestMethod RequestMethod, int32 AccountIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("TwitterRequest");

	Params::TwitterIntegrationBase_TwitterRequest Parms{};

	Parms.URL = std::move(URL);
	Parms.ParamKeysAndValues = std::move(ParamKeysAndValues);
	Parms.RequestMethod = RequestMethod;
	Parms.AccountIndex = AccountIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.VectorFieldComponent.SetIntensity
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVectorFieldComponent::SetIntensity(float NewIntensity)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetIntensity");

	Params::VectorFieldComponent_SetIntensity Parms{};

	Parms.NewIntensity = NewIntensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ViewportStatsSubsystem.AddDisplayDelegate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(class FText* OutText, struct FLinearColor* OutColor)>Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UViewportStatsSubsystem::AddDisplayDelegate(const TDelegate<void(class FText* OutText, struct FLinearColor* OutColor)>& Delegate)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddDisplayDelegate");

	Params::ViewportStatsSubsystem_AddDisplayDelegate Parms{};

	Parms.Delegate = Delegate;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Engine.ViewportStatsSubsystem.AddTimedDisplay
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FText                             Text                                                   (Parm, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UViewportStatsSubsystem::AddTimedDisplay(const class FText& Text, const struct FLinearColor& Color, float Duration)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddTimedDisplay");

	Params::ViewportStatsSubsystem_AddTimedDisplay Parms{};

	Parms.Text = std::move(Text);
	Parms.Color = std::move(Color);
	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.ViewportStatsSubsystem.RemoveDisplayDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   IndexToRemove                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UViewportStatsSubsystem::RemoveDisplayDelegate(const int32 IndexToRemove)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveDisplayDelegate");

	Params::ViewportStatsSubsystem_RemoveDisplayDelegate Parms{};

	Parms.IndexToRemove = IndexToRemove;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.VisualLoggerKismetLibrary.EnableRecording
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::EnableRecording(bool bEnabled)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("EnableRecording");

	Params::VisualLoggerKismetLibrary_EnableRecording Parms{};

	Parms.bEnabled = bEnabled;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.VisualLoggerKismetLibrary.LogBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             BoxShape                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ObjectColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LogCategory                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToMessageLog                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::LogBox(class UObject* WorldContextObject, const struct FBox& BoxShape, const class FString& Text, const struct FLinearColor& ObjectColor, class FName LogCategory, bool bAddToMessageLog)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LogBox");

	Params::VisualLoggerKismetLibrary_LogBox Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BoxShape = std::move(BoxShape);
	Parms.Text = std::move(Text);
	Parms.ObjectColor = std::move(ObjectColor);
	Parms.LogCategory = LogCategory;
	Parms.bAddToMessageLog = bAddToMessageLog;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.VisualLoggerKismetLibrary.LogLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ObjectColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LogCategory                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToMessageLog                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::LogLocation(class UObject* WorldContextObject, const struct FVector& Location, const class FString& Text, const struct FLinearColor& ObjectColor, float Radius, class FName LogCategory, bool bAddToMessageLog)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LogLocation");

	Params::VisualLoggerKismetLibrary_LogLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Location = std::move(Location);
	Parms.Text = std::move(Text);
	Parms.ObjectColor = std::move(ObjectColor);
	Parms.Radius = Radius;
	Parms.LogCategory = LogCategory;
	Parms.bAddToMessageLog = bAddToMessageLog;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.VisualLoggerKismetLibrary.LogSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentStart                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentEnd                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ObjectColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CategoryName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToMessageLog                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::LogSegment(class UObject* WorldContextObject, const struct FVector& SegmentStart, const struct FVector& SegmentEnd, const class FString& Text, const struct FLinearColor& ObjectColor, const float Thickness, class FName CategoryName, bool bAddToMessageLog)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LogSegment");

	Params::VisualLoggerKismetLibrary_LogSegment Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SegmentStart = std::move(SegmentStart);
	Parms.SegmentEnd = std::move(SegmentEnd);
	Parms.Text = std::move(Text);
	Parms.ObjectColor = std::move(ObjectColor);
	Parms.Thickness = Thickness;
	Parms.CategoryName = CategoryName;
	Parms.bAddToMessageLog = bAddToMessageLog;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.VisualLoggerKismetLibrary.LogText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LogCategory                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAddToMessageLog                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::LogText(class UObject* WorldContextObject, const class FString& Text, class FName LogCategory, bool bAddToMessageLog)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("LogText");

	Params::VisualLoggerKismetLibrary_LogText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Text = std::move(Text);
	Parms.LogCategory = LogCategory;
	Parms.bAddToMessageLog = bAddToMessageLog;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.VisualLoggerKismetLibrary.RedirectVislog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          SourceOwner                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          DestinationOwner                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVisualLoggerKismetLibrary::RedirectVislog(class UObject* SourceOwner, class UObject* DestinationOwner)
{
	static class UFunction* Func = nullptr;
	class UClass* StaticClss = StaticClass();

	if (Func == nullptr)
		Func = StaticClss->FindFunction("RedirectVislog");

	Params::VisualLoggerKismetLibrary_RedirectVislog Parms{};

	Parms.SourceOwner = SourceOwner;
	Parms.DestinationOwner = DestinationOwner;

	StaticClss->DefaultObject->ProcessEvent(Func, &Parms);
}


// Function Engine.WindDirectionalSourceComponent.SetMaximumGustAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNewMaxGust                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetMaximumGustAmount(float InNewMaxGust)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMaximumGustAmount");

	Params::WindDirectionalSourceComponent_SetMaximumGustAmount Parms{};

	Parms.InNewMaxGust = InNewMaxGust;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.WindDirectionalSourceComponent.SetMinimumGustAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNewMinGust                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetMinimumGustAmount(float InNewMinGust)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetMinimumGustAmount");

	Params::WindDirectionalSourceComponent_SetMinimumGustAmount Parms{};

	Parms.InNewMinGust = InNewMinGust;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.WindDirectionalSourceComponent.SetRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNewRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetRadius(float InNewRadius)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetRadius");

	Params::WindDirectionalSourceComponent_SetRadius Parms{};

	Parms.InNewRadius = InNewRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.WindDirectionalSourceComponent.SetSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNewSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetSpeed(float InNewSpeed)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetSpeed");

	Params::WindDirectionalSourceComponent_SetSpeed Parms{};

	Parms.InNewSpeed = InNewSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.WindDirectionalSourceComponent.SetStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InNewStrength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetStrength(float InNewStrength)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetStrength");

	Params::WindDirectionalSourceComponent_SetStrength Parms{};

	Parms.InNewStrength = InNewStrength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.WindDirectionalSourceComponent.SetWindType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWindSourceType                         InNewType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindDirectionalSourceComponent::SetWindType(EWindSourceType InNewType)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetWindType");

	Params::WindDirectionalSourceComponent_SetWindType Parms{};

	Parms.InNewType = InNewType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Engine.WorldPartitionRuntimeLevelStreamingCell.OnLevelHidden
// (Final, Native, Private)

void UWorldPartitionRuntimeLevelStreamingCell::OnLevelHidden()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnLevelHidden");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.WorldPartitionRuntimeLevelStreamingCell.OnLevelShown
// (Final, Native, Private)

void UWorldPartitionRuntimeLevelStreamingCell::OnLevelShown()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnLevelShown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Engine.WorldPartitionSubsystem.IsStreamingCompleted
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWorldPartitionRuntimeCellState         QueryState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FWorldPartitionStreamingQuerySource>QuerySources                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bExactState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldPartitionSubsystem::IsStreamingCompleted(EWorldPartitionRuntimeCellState QueryState, const TArray<struct FWorldPartitionStreamingQuerySource>& QuerySources, bool bExactState) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("IsStreamingCompleted");

	Params::WorldPartitionSubsystem_IsStreamingCompleted Parms{};

	Parms.QueryState = QueryState;
	Parms.QuerySources = std::move(QuerySources);
	Parms.bExactState = bExactState;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

